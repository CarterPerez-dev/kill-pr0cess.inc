This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
src/
  components/
    Fractals/
      FractalCanvas.tsx
      FractalControls.tsx
      FractalInfo.tsx
    GitHub/
      ProjectCard.tsx
      ProjectDetail.tsx
      ProjectFilters.tsx
      ProjectGrid.tsx
    Layout/
      Footer.tsx
      Header.tsx
      Layout.tsx
    Performance/
      BenchmarkChart.tsx
      MetricsDisplay.tsx
      SystemMonitor.tsx
      TechStackInfo.tsx
    UI/
      Button.tsx
      Card.tsx
      ErrorBoundary.tsx
      LoadingSpinner.tsx
    Counter.tsx
    Nav.tsx
  hooks/
    useFractals.ts
    useGitHub.ts
    usePerformance.ts
    useWebVitals.ts
  pages/
    About.tsx
    Home.tsx
    Performance.tsx
    Projects.tsx
  routes/
    _layout.tsx
    [...404].tsx
    index.tsx
    performance.tsx 
    projects.tsx
  services/
    api.ts
    fractals.ts
    github.ts
    performance.ts
  styles/
    components.css
    global.css
  utils/
    animations.ts
    canvas.ts
    performance.ts
    theme.ts
  app.css
  app.tsx
  entry-client.tsx
  entry-server.tsx
  global.d.ts
.gitignore
app.config.ts
Dockerfile.dev
Dockerfile.prod
package.json
postcss.config.js
tailwind.config.js
tsconfig.json
vite-plugin-solid-patch.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(npm run dev:*)"
    ],
    "deny": []
  }
}
</file>

<file path="src/components/Fractals/FractalCanvas.tsx">
/*
 * Interactive fractal visualization component with real-time backend communication and smooth user controls.
 * I'm implementing canvas-based rendering with zoom/pan controls, performance monitoring, and seamless integration with the Rust backend API.
 */

import { Component, createSignal, onMount, onCleanup, createEffect } from 'solid-js';

interface FractalCanvasProps {
  width?: number;
  height?: number;
  fractalType?: 'mandelbrot' | 'julia';
  onPerformanceUpdate?: (metrics: PerformanceMetrics) => void;
}

interface PerformanceMetrics {
  computationTime: number;
  networkTime: number;
  totalTime: number;
  pixelsPerSecond: number;
  zoomLevel: number;
  pixelsComputed: number;
}

interface FractalResponse {
  data: number[];
  width: number;
  height: number;
  computation_time_ms: number;
  zoom_level: number;
  parameters: any;
  performance_metrics: {
    pixels_per_second: number;
    parallel_efficiency: number;
    memory_usage_mb: number;
    cpu_utilization: number;
  };
}

export const FractalCanvas: Component<FractalCanvasProps> = (props) => {
  let canvasRef: HTMLCanvasElement | undefined;
  let animationFrameId: number | undefined;

  // Core fractal parameters - I'm setting up reactive state for smooth interaction
  const [zoom, setZoom] = createSignal(1.0);
  const [centerX, setCenterX] = createSignal(props.fractalType === 'julia' ? 0.0 : -0.5);
  const [centerY, setCenterY] = createSignal(0.0);
  const [maxIterations, setMaxIterations] = createSignal(100);
  
  // Julia set specific parameters
  const [juliaC, setJuliaC] = createSignal({ real: -0.7, imag: 0.27015 });
  
  // Interaction state
  const [isDragging, setIsDragging] = createSignal(false);
  const [lastMousePos, setLastMousePos] = createSignal({ x: 0, y: 0 });
  const [isLoading, setIsLoading] = createSignal(false);
  
  // Performance tracking
  const [currentMetrics, setCurrentMetrics] = createSignal<PerformanceMetrics | null>(null);
  const [renderHistory, setRenderHistory] = createSignal<PerformanceMetrics[]>([]);

  const width = () => props.width || 800;
  const height = () => props.height || 600;
  const fractalType = () => props.fractalType || 'mandelbrot';

  // I'm setting up automatic re-rendering when parameters change
  createEffect(() => {
    if (canvasRef) {
      debouncedRender();
    }
  });

  onMount(() => {
    if (canvasRef) {
      initializeCanvas();
      renderFractal();
    }
  });

  onCleanup(() => {
    if (animationFrameId) {
      cancelAnimationFrame(animationFrameId);
    }
  });

  const initializeCanvas = () => {
    if (!canvasRef) return;
    
    const ctx = canvasRef.getContext('2d');
    if (!ctx) return;

    // I'm setting up canvas with optimal settings for performance
    ctx.imageSmoothingEnabled = false;
    canvasRef.style.cursor = 'crosshair';
  };

  const renderFractal = async () => {
    if (!canvasRef || isLoading()) return;

    setIsLoading(true);
    const startTime = performance.now();

    try {
      // I'm building the API request with current parameters
      const params = new URLSearchParams({
        width: width().toString(),
        height: height().toString(),
        center_x: centerX().toString(),
        center_y: centerY().toString(),
        zoom: zoom().toString(),
        max_iterations: maxIterations().toString(),
      });

      // Add Julia-specific parameters if needed
      if (fractalType() === 'julia') {
        params.append('c_real', juliaC().real.toString());
        params.append('c_imag', juliaC().imag.toString());
      }

      const endpoint = fractalType() === 'mandelbrot' 
        ? `/api/fractals/mandelbrot?${params}`
        : `/api/fractals/julia?${params}`;

      const response = await fetch(endpoint);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const fractalData: FractalResponse = await response.json();
      const networkTime = performance.now() - startTime;

      // I'm converting the response data to ImageData for canvas rendering
      await renderToCanvas(fractalData);

      // Update performance metrics
      const metrics: PerformanceMetrics = {
        computationTime: fractalData.computation_time_ms,
        networkTime: networkTime - fractalData.computation_time_ms,
        totalTime: networkTime,
        pixelsPerSecond: fractalData.performance_metrics.pixels_per_second,
        zoomLevel: zoom(),
        pixelsComputed: fractalData.width * fractalData.height,
      };

      setCurrentMetrics(metrics);
      updateRenderHistory(metrics);
      
      // Notify parent component if callback provided
      props.onPerformanceUpdate?.(metrics);

    } catch (error) {
      console.error('Fractal generation failed:', error);
      displayError(error.message);
    } finally {
      setIsLoading(false);
    }
  };

  const renderToCanvas = async (fractalData: FractalResponse) => {
    if (!canvasRef) return;

    const ctx = canvasRef.getContext('2d');
    if (!ctx) return;

    // I'm converting the raw RGBA data from the backend into ImageData
    const imageData = new ImageData(
      new Uint8ClampedArray(fractalData.data),
      fractalData.width,
      fractalData.height
    );

    // Clear canvas and render the fractal
    ctx.clearRect(0, 0, width(), height());
    ctx.putImageData(imageData, 0, 0);
  };

  const displayError = (message: string) => {
    if (!canvasRef) return;

    const ctx = canvasRef.getContext('2d');
    if (!ctx) return;

    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, width(), height());
    
    ctx.fillStyle = '#ef4444';
    ctx.font = '16px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Error: ' + message, width() / 2, height() / 2);
  };

  // I'm implementing smooth debounced rendering to prevent excessive API calls
  let renderTimeout: number | undefined;
  const debouncedRender = () => {
    if (renderTimeout) clearTimeout(renderTimeout);
    renderTimeout = setTimeout(renderFractal, 150);
  };

  // Mouse and touch interaction handlers
  const handleWheel = (e: WheelEvent) => {
    e.preventDefault();
    
    const rect = canvasRef!.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // I'm implementing smooth zoom with cursor-centered scaling
    const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
    const newZoom = zoom() * zoomFactor;
    
    // Prevent extreme zoom levels that could cause performance issues
    if (newZoom < 0.1 || newZoom > 1e12) return;
    
    // Calculate new center point to zoom toward cursor
    const scale = 4.0 / zoom();
    const mouseWorldX = centerX() + (mouseX - width() / 2) * scale / width();
    const mouseWorldY = centerY() + (mouseY - height() / 2) * scale / height();
    
    const newScale = 4.0 / newZoom;
    const newCenterX = mouseWorldX - (mouseX - width() / 2) * newScale / width();
    const newCenterY = mouseWorldY - (mouseY - height() / 2) * newScale / height();
    
    setZoom(newZoom);
    setCenterX(newCenterX);
    setCenterY(newCenterY);
    
    // Adjust iteration count based on zoom for optimal detail vs performance
    const optimalIterations = Math.min(100 + Math.floor(Math.log10(newZoom) * 50), 2000);
    setMaxIterations(Math.max(50, optimalIterations));
  };

  const handleMouseDown = (e: MouseEvent) => {
    setIsDragging(true);
    setLastMousePos({ x: e.clientX, y: e.clientY });
    canvasRef!.style.cursor = 'grabbing';
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (!isDragging()) return;
    
    const deltaX = e.clientX - lastMousePos().x;
    const deltaY = e.clientY - lastMousePos().y;
    
    const scale = 4.0 / zoom();
    const worldDeltaX = -deltaX * scale / width();
    const worldDeltaY = -deltaY * scale / height();
    
    setCenterX(centerX() + worldDeltaX);
    setCenterY(centerY() + worldDeltaY);
    setLastMousePos({ x: e.clientX, y: e.clientY });
  };

  const handleMouseUp = () => {
    setIsDragging(false);
    canvasRef!.style.cursor = 'crosshair';
  };

  // Touch support for mobile devices
  const handleTouchStart = (e: TouchEvent) => {
    e.preventDefault();
    if (e.touches.length === 1) {
      const touch = e.touches[0];
      handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY } as MouseEvent);
    }
  };

  const handleTouchMove = (e: TouchEvent) => {
    e.preventDefault();
    if (e.touches.length === 1 && isDragging()) {
      const touch = e.touches[0];
      handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY } as MouseEvent);
    }
  };

  const updateRenderHistory = (metrics: PerformanceMetrics) => {
    setRenderHistory(prev => {
      const updated = [...prev, metrics];
      return updated.slice(-50); // Keep last 50 renders for analysis
    });
  };

  const getAveragePerformance = () => {
    const history = renderHistory();
    if (history.length === 0) return null;
    
    const avg = history.reduce((acc, curr) => ({
      computationTime: acc.computationTime + curr.computationTime,
      networkTime: acc.networkTime + curr.networkTime,
      totalTime: acc.totalTime + curr.totalTime,
      pixelsPerSecond: acc.pixelsPerSecond + curr.pixelsPerSecond,
    }), { computationTime: 0, networkTime: 0, totalTime: 0, pixelsPerSecond: 0 });

    return {
      computationTime: avg.computationTime / history.length,
      networkTime: avg.networkTime / history.length,
      totalTime: avg.totalTime / history.length,
      pixelsPerSecond: avg.pixelsPerSecond / history.length,
    };
  };

  return (
    <div class="relative overflow-hidden rounded-lg border border-neutral-800 bg-black">
      {/* Main fractal canvas */}
      <canvas
        ref={canvasRef}
        width={width()}
        height={height()}
        class="block"
        onWheel={handleWheel}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleMouseUp}
      />

      {/* Loading overlay */}
      <div class={`absolute inset-0 bg-black/80 flex items-center justify-center transition-opacity duration-300 ${
        isLoading() ? 'opacity-100' : 'opacity-0 pointer-events-none'
      }`}>
        <div class="text-center text-neutral-300">
          <div class="w-12 h-12 border-2 border-neutral-600 border-t-neutral-300 rounded-full animate-spin mx-auto mb-3"></div>
          <div class="text-sm font-mono">Computing fractal...</div>
          <div class="text-xs text-neutral-500 mt-1">
            {zoom() > 1000 ? 'Deep zoom - please wait' : 'Processing'}
          </div>
        </div>
      </div>

      {/* Performance metrics overlay */}
      <div class="absolute top-3 left-3 bg-black/90 backdrop-blur-sm rounded border border-neutral-700 p-3 text-xs font-mono text-neutral-300 min-w-[200px]">
        <div class="text-neutral-400 font-semibold mb-2 text-sm">PERFORMANCE</div>
        {currentMetrics() && (
          <div class="space-y-1">
            <div class="flex justify-between">
              <span>Backend:</span>
              <span class="text-green-400">{currentMetrics()!.computationTime}ms</span>
            </div>
            <div class="flex justify-between">
              <span>Network:</span>
              <span class="text-yellow-400">{Math.round(currentMetrics()!.networkTime)}ms</span>
            </div>
            <div class="flex justify-between">
              <span>Zoom:</span>
              <span class="text-purple-400">{zoom().toExponential(2)}</span>
            </div>
            <div class="flex justify-between">
              <span>Pixels/sec:</span>
              <span class="text-cyan-400">{Math.round(currentMetrics()!.pixelsPerSecond).toLocaleString()}</span>
            </div>
            <div class="flex justify-between">
              <span>Resolution:</span>
              <span class="text-neutral-400">{width()}×{height()}</span>
            </div>
          </div>
        )}
        {getAveragePerformance() && (
          <div class="mt-3 pt-2 border-t border-neutral-700">
            <div class="text-neutral-500 text-xs mb-1">Average ({renderHistory().length} renders)</div>
            <div class="flex justify-between text-xs">
              <span>Backend:</span>
              <span class="text-green-400">{Math.round(getAveragePerformance()!.computationTime)}ms</span>
            </div>
          </div>
        )}
      </div>

      {/* Julia set controls (if applicable) */}
      {fractalType() === 'julia' && (
        <div class="absolute top-3 right-3 bg-black/90 backdrop-blur-sm rounded border border-neutral-700 p-3 text-xs font-mono text-neutral-300">
          <div class="text-neutral-400 font-semibold mb-2">JULIA PARAMETERS</div>
          <div class="space-y-2">
            <div>
              <label class="block text-neutral-500 mb-1">C Real</label>
              <input
                type="range"
                min="-2"
                max="2"
                step="0.01"
                value={juliaC().real}
                onInput={(e) => setJuliaC(prev => ({ ...prev, real: parseFloat(e.currentTarget.value) }))}
                class="w-full h-1 bg-neutral-700 rounded appearance-none slider"
              />
              <div class="text-xs text-neutral-400 mt-1">{juliaC().real.toFixed(3)}</div>
            </div>
            <div>
              <label class="block text-neutral-500 mb-1">C Imaginary</label>
              <input
                type="range"
                min="-2"
                max="2"
                step="0.01"
                value={juliaC().imag}
                onInput={(e) => setJuliaC(prev => ({ ...prev, imag: parseFloat(e.currentTarget.value) }))}
                class="w-full h-1 bg-neutral-700 rounded appearance-none slider"
              />
              <div class="text-xs text-neutral-400 mt-1">{juliaC().imag.toFixed(3)}</div>
            </div>
          </div>
        </div>
      )}

      {/* Control instructions */}
      <div class="absolute bottom-3 right-3 bg-black/90 backdrop-blur-sm rounded border border-neutral-700 p-3 text-xs text-neutral-400">
        <div class="space-y-1">
          <div>Scroll: Zoom • Drag: Pan</div>
          <div class="text-neutral-500">
            Powered by <span class="text-orange-400">Rust</span> + <span class="text-blue-400">Axum</span>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/Fractals/FractalControls.tsx">
/*
 * Interactive fractal parameter controls providing real-time adjustment of mathematical visualization parameters with immediate visual feedback.
 * I'm implementing comprehensive controls for zoom, center position, iterations, and fractal-specific parameters while maintaining the dark, eerie aesthetic throughout the control interface.
 */

import { Component, createSignal, createEffect, Show, For } from 'solid-js';
import { Card } from '../UI/Card';

interface FractalControlsProps {
  fractalType: 'mandelbrot' | 'julia';
  parameters: {
    zoom: number;
    centerX: number;
    centerY: number;
    maxIterations: number;
    juliaConstant?: { real: number; imag: number };
  };
  onParameterChange: (params: Partial<FractalControlsProps['parameters']>) => void;
  isGenerating?: boolean;
  performanceMetrics?: {
    computationTime: number;
    pixelsPerSecond: number;
    parallelEfficiency: number;
  };
}

export const FractalControls: Component<FractalControlsProps> = (props) => {
  const [isExpanded, setIsExpanded] = createSignal(true);
  const [activeTab, setActiveTab] = createSignal<'basic' | 'advanced' | 'presets'>('basic');

  // I'm creating preset configurations for common fractal views
  const presets = () => [
    {
      name: 'Classic Mandelbrot',
      type: 'mandelbrot' as const,
      params: { zoom: 1.0, centerX: -0.5, centerY: 0.0, maxIterations: 100 }
    },
    {
      name: 'Seahorse Valley',
      type: 'mandelbrot' as const,
      params: { zoom: 1000, centerX: -0.743643887037151, centerY: 0.13182590420533, maxIterations: 300 }
    },
    {
      name: 'Lightning',
      type: 'mandelbrot' as const,
      params: { zoom: 100, centerX: -1.8, centerY: 0, maxIterations: 250 }
    },
    {
      name: 'Classic Julia',
      type: 'julia' as const,
      params: { zoom: 1.0, centerX: 0.0, centerY: 0.0, maxIterations: 150, juliaConstant: { real: -0.7, imag: 0.27015 } }
    },
    {
      name: 'Dragon Julia',
      type: 'julia' as const,
      params: { zoom: 1.0, centerX: 0.0, centerY: 0.0, maxIterations: 200, juliaConstant: { real: -0.8, imag: 0.156 } }
    }
  ];

  const formatNumber = (num: number, decimals: number = 6): string => {
    if (Math.abs(num) > 1000) {
      return num.toExponential(3);
    }
    return num.toFixed(decimals);
  };

  const getPerformanceRating = (pixelsPerSecond: number): string => {
    if (pixelsPerSecond > 10000) return 'Exceptional';
    if (pixelsPerSecond > 5000) return 'Excellent';
    if (pixelsPerSecond > 2000) return 'Very Good';
    if (pixelsPerSecond > 1000) return 'Good';
    if (pixelsPerSecond > 500) return 'Fair';
    return 'Needs Optimization';
  };

  return (
    <div class="fixed top-4 right-4 w-80 z-20">
      <Card variant="glass" padding="none" class="backdrop-blur-md border-neutral-700">
        {/* Header */}
        <div class="flex items-center justify-between p-4 border-b border-neutral-700">
          <h3 class="font-mono text-sm text-neutral-300 tracking-wide">
            FRACTAL CONTROLS
          </h3>
          <button
            onClick={() => setIsExpanded(!isExpanded())}
            class="text-neutral-500 hover:text-neutral-300 transition-colors duration-200"
          >
            {isExpanded() ? '−' : '+'}
          </button>
        </div>

        <Show when={isExpanded()}>
          {/* Tab Navigation */}
          <div class="flex border-b border-neutral-800">
            {(['basic', 'advanced', 'presets'] as const).map((tab) => (
              <button
                onClick={() => setActiveTab(tab)}
                class={`flex-1 px-3 py-2 text-xs font-mono uppercase tracking-wide transition-colors duration-200 ${
                  activeTab() === tab
                    ? 'bg-neutral-800 text-neutral-200 border-b-2 border-cyan-400'
                    : 'text-neutral-500 hover:text-neutral-300'
                }`}
              >
                {tab}
              </button>
            ))}
          </div>

          {/* Basic Controls */}
          <Show when={activeTab() === 'basic'}>
            <div class="p-4 space-y-4">
              {/* Zoom Control */}
              <div>
                <div class="flex justify-between items-center mb-2">
                  <label class="text-xs text-neutral-500 font-mono uppercase">Zoom</label>
                  <span class="text-xs text-neutral-400 font-mono">
                    {formatNumber(props.parameters.zoom)}
                  </span>
                </div>
                <input
                  type="range"
                  min={Math.log10(0.1)}
                  max={Math.log10(1e12)}
                  step="0.1"
                  value={Math.log10(props.parameters.zoom)}
                  onInput={(e) => props.onParameterChange({
                    zoom: Math.pow(10, parseFloat(e.currentTarget.value))
                  })}
                  class="w-full h-2 bg-neutral-800 rounded-lg appearance-none slider cursor-pointer"
                  disabled={props.isGenerating}
                />
              </div>

              {/* Center X Control */}
              <div>
                <div class="flex justify-between items-center mb-2">
                  <label class="text-xs text-neutral-500 font-mono uppercase">Center X</label>
                  <span class="text-xs text-neutral-400 font-mono">
                    {formatNumber(props.parameters.centerX)}
                  </span>
                </div>
                <input
                  type="range"
                  min="-2"
                  max="2"
                  step="0.001"
                  value={props.parameters.centerX}
                  onInput={(e) => props.onParameterChange({
                    centerX: parseFloat(e.currentTarget.value)
                  })}
                  class="w-full h-2 bg-neutral-800 rounded-lg appearance-none slider cursor-pointer"
                  disabled={props.isGenerating}
                />
              </div>

              {/* Center Y Control */}
              <div>
                <div class="flex justify-between items-center mb-2">
                  <label class="text-xs text-neutral-500 font-mono uppercase">Center Y</label>
                  <span class="text-xs text-neutral-400 font-mono">
                    {formatNumber(props.parameters.centerY)}
                  </span>
                </div>
                <input
                  type="range"
                  min="-2"
                  max="2"
                  step="0.001"
                  value={props.parameters.centerY}
                  onInput={(e) => props.onParameterChange({
                    centerY: parseFloat(e.currentTarget.value)
                  })}
                  class="w-full h-2 bg-neutral-800 rounded-lg appearance-none slider cursor-pointer"
                  disabled={props.isGenerating}
                />
              </div>

              {/* Max Iterations */}
              <div>
                <div class="flex justify-between items-center mb-2">
                  <label class="text-xs text-neutral-500 font-mono uppercase">Iterations</label>
                  <span class="text-xs text-neutral-400 font-mono">
                    {props.parameters.maxIterations}
                  </span>
                </div>
                <input
                  type="range"
                  min="50"
                  max="2000"
                  step="10"
                  value={props.parameters.maxIterations}
                  onInput={(e) => props.onParameterChange({
                    maxIterations: parseInt(e.currentTarget.value)
                  })}
                  class="w-full h-2 bg-neutral-800 rounded-lg appearance-none slider cursor-pointer"
                  disabled={props.isGenerating}
                />
              </div>

              {/* Julia Constant Controls */}
              <Show when={props.fractalType === 'julia'}>
                <div class="pt-3 border-t border-neutral-800">
                  <div class="text-xs text-neutral-500 font-mono uppercase mb-3">Julia Constant</div>

                  <div class="space-y-3">
                    <div>
                      <div class="flex justify-between items-center mb-2">
                        <label class="text-xs text-neutral-600">Real</label>
                        <span class="text-xs text-neutral-400 font-mono">
                          {formatNumber(props.parameters.juliaConstant?.real || 0, 4)}
                        </span>
                      </div>
                      <input
                        type="range"
                        min="-2"
                        max="2"
                        step="0.01"
                        value={props.parameters.juliaConstant?.real || 0}
                        onInput={(e) => props.onParameterChange({
                          juliaConstant: {
                            real: parseFloat(e.currentTarget.value),
                            imag: props.parameters.juliaConstant?.imag || 0
                          }
                        })}
                        class="w-full h-2 bg-neutral-800 rounded-lg appearance-none slider cursor-pointer"
                        disabled={props.isGenerating}
                      />
                    </div>

                    <div>
                      <div class="flex justify-between items-center mb-2">
                        <label class="text-xs text-neutral-600">Imaginary</label>
                        <span class="text-xs text-neutral-400 font-mono">
                          {formatNumber(props.parameters.juliaConstant?.imag || 0, 4)}
                        </span>
                      </div>
                      <input
                        type="range"
                        min="-2"
                        max="2"
                        step="0.01"
                        value={props.parameters.juliaConstant?.imag || 0}
                        onInput={(e) => props.onParameterChange({
                          juliaConstant: {
                            real: props.parameters.juliaConstant?.real || 0,
                            imag: parseFloat(e.currentTarget.value)
                          }
                        })}
                        class="w-full h-2 bg-neutral-800 rounded-lg appearance-none slider cursor-pointer"
                        disabled={props.isGenerating}
                      />
                    </div>
                  </div>
                </div>
              </Show>
            </div>
          </Show>

          {/* Advanced Controls */}
          <Show when={activeTab() === 'advanced'}>
            <div class="p-4 space-y-4">
              {/* Performance Metrics */}
              <Show when={props.performanceMetrics}>
                <div class="bg-neutral-900/50 rounded-lg p-3 space-y-2">
                  <div class="text-xs text-neutral-500 font-mono uppercase mb-2">Performance</div>

                  <div class="flex justify-between text-xs">
                    <span class="text-neutral-600">Computation:</span>
                    <span class="text-neutral-400 font-mono">
                      {props.performanceMetrics!.computationTime}ms
                    </span>
                  </div>

                  <div class="flex justify-between text-xs">
                    <span class="text-neutral-600">Pixels/sec:</span>
                    <span class="text-neutral-400 font-mono">
                      {Math.round(props.performanceMetrics!.pixelsPerSecond).toLocaleString()}
                    </span>
                  </div>

                  <div class="flex justify-between text-xs">
                    <span class="text-neutral-600">Parallel Eff:</span>
                    <span class="text-neutral-400 font-mono">
                      {(props.performanceMetrics!.parallelEfficiency * 100).toFixed(1)}%
                    </span>
                  </div>

                  <div class="flex justify-between text-xs">
                    <span class="text-neutral-600">Rating:</span>
                    <span class="text-cyan-400 font-mono text-xs">
                      {getPerformanceRating(props.performanceMetrics!.pixelsPerSecond)}
                    </span>
                  </div>
                </div>
              </Show>

              {/* Manual Input Fields */}
              <div class="space-y-3">
                <div class="text-xs text-neutral-500 font-mono uppercase">Manual Input</div>

                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="text-xs text-neutral-600 block mb-1">Center X</label>
                    <input
                      type="number"
                      step="0.000001"
                      value={props.parameters.centerX}
                      onInput={(e) => props.onParameterChange({
                        centerX: parseFloat(e.currentTarget.value)
                      })}
                      class="w-full bg-neutral-900 border border-neutral-700 rounded px-2 py-1 text-xs font-mono text-neutral-300 focus:border-cyan-400 focus:outline-none"
                      disabled={props.isGenerating}
                    />
                  </div>

                  <div>
                    <label class="text-xs text-neutral-600 block mb-1">Center Y</label>
                    <input
                      type="number"
                      step="0.000001"
                      value={props.parameters.centerY}
                      onInput={(e) => props.onParameterChange({
                        centerY: parseFloat(e.currentTarget.value)
                      })}
                      class="w-full bg-neutral-900 border border-neutral-700 rounded px-2 py-1 text-xs font-mono text-neutral-300 focus:border-cyan-400 focus:outline-none"
                      disabled={props.isGenerating}
                    />
                  </div>
                </div>

                <div>
                  <label class="text-xs text-neutral-600 block mb-1">Zoom Level</label>
                  <input
                    type="number"
                    step="0.1"
                    value={props.parameters.zoom}
                    onInput={(e) => props.onParameterChange({
                      zoom: parseFloat(e.currentTarget.value)
                    })}
                    class="w-full bg-neutral-900 border border-neutral-700 rounded px-2 py-1 text-xs font-mono text-neutral-300 focus:border-cyan-400 focus:outline-none"
                    disabled={props.isGenerating}
                  />
                </div>
              </div>

              {/* Reset Button */}
              <button
                onClick={() => props.onParameterChange({
                  zoom: 1.0,
                  centerX: props.fractalType === 'mandelbrot' ? -0.5 : 0.0,
                  centerY: 0.0,
                  maxIterations: props.fractalType === 'mandelbrot' ? 100 : 150
                })}
                class="w-full mt-4 px-3 py-2 bg-neutral-800 hover:bg-neutral-700 border border-neutral-600 text-neutral-300 rounded text-xs font-mono uppercase tracking-wide transition-colors duration-200"
                disabled={props.isGenerating}
              >
                Reset to Default
              </button>
            </div>
          </Show>

          {/* Presets */}
          <Show when={activeTab() === 'presets'}>
            <div class="p-4 space-y-2">
              <For each={presets().filter(p => p.type === props.fractalType)}>
                {(preset) => (
                  <button
                    onClick={() => props.onParameterChange(preset.params)}
                    class="w-full text-left p-3 bg-neutral-900/30 hover:bg-neutral-800/50 border border-neutral-800 hover:border-neutral-700 rounded transition-colors duration-200"
                    disabled={props.isGenerating}
                  >
                    <div class="text-xs font-mono text-neutral-300 mb-1">
                      {preset.name}
                    </div>
                    <div class="text-xs text-neutral-600">
                      Zoom: {preset.params.zoom} • Iterations: {preset.params.maxIterations}
                    </div>
                  </button>
                )}
              </For>
            </div>
          </Show>

          {/* Generation Status */}
          <Show when={props.isGenerating}>
            <div class="p-4 border-t border-neutral-800">
              <div class="flex items-center gap-2 text-xs text-neutral-500">
                <div class="w-3 h-3 border border-cyan-400 border-t-transparent rounded-full animate-spin"></div>
                <span class="font-mono">Computing fractal...</span>
              </div>
            </div>
          </Show>
        </Show>
      </Card>
    </div>
  );
};
</file>

<file path="src/components/Fractals/FractalInfo.tsx">
/*
 * Fractal information display component providing detailed mathematical and computational context for the current fractal visualization.
 * I'm implementing comprehensive fractal metadata presentation including mathematical properties, performance analysis, and theoretical background in the dark aesthetic framework.
 */

import { Component, createSignal, Show, For } from 'solid-js';
import { Card } from '../UI/Card';

interface FractalInfoProps {
  fractalType: 'mandelbrot' | 'julia';
  parameters: {
    zoom: number;
    centerX: number;
    centerY: number;
    maxIterations: number;
    juliaConstant?: { real: number; imag: number };
  };
  metadata?: {
    computationTime: number;
    pixelsComputed: number;
    pixelsPerSecond: number;
    parallelEfficiency: number;
    memoryUsage: number;
    iterationsUsed: number;
  };
  visible?: boolean;
  onToggle?: () => void;
}

export const FractalInfo: Component<FractalInfoProps> = (props) => {
  const [activeSection, setActiveSection] = createSignal<'math' | 'performance' | 'theory'>('math');

  // I'm calculating derived mathematical properties
  const getMathematicalProperties = () => {
    const { zoom, centerX, centerY, maxIterations } = props.parameters;

    const pixelSize = 4.0 / zoom;
    const escapeRadius = 2.0;
    const aspectRatio = 4.0 / 3.0; // Assuming 4:3 aspect ratio

    return {
      pixelSize,
      escapeRadius,
      aspectRatio,
      complexPlaneWidth: pixelSize * 800, // Assuming 800px width
      complexPlaneHeight: pixelSize * 600, // Assuming 600px height
      magnification: zoom,
      centerPoint: `${centerX.toFixed(10)} + ${centerY.toFixed(10)}i`,
      iterationDepth: maxIterations
    };
  };

  // I'm providing theoretical background for each fractal type
  const getTheoreticalInfo = () => {
    if (props.fractalType === 'mandelbrot') {
      return {
        title: 'The Mandelbrot Set',
        definition: 'The set of complex numbers c for which the function f(z) = z² + c does not diverge when iterated from z = 0.',
        discoverer: 'Benoit Mandelbrot (1980)',
        dimension: 'Hausdorff dimension ≈ 2',
        properties: [
          'Self-similar at different scales',
          'Connected set with intricate boundary',
          'Contains miniature copies of itself',
          'Exhibits fractal geometry'
        ],
        equation: 'z_{n+1} = z_n² + c',
        significance: 'Demonstrates how simple mathematical rules can generate infinite complexity.'
      };
    } else {
      const { real, imag } = props.parameters.juliaConstant || { real: 0, imag: 0 };
      return {
        title: 'Julia Sets',
        definition: `The set of complex numbers z for which the iteration z² + c remains bounded, where c = ${real.toFixed(4)} + ${imag.toFixed(4)}i.`,
        discoverer: 'Gaston Julia (1918)',
        dimension: 'Hausdorff dimension varies',
        properties: [
          'Connected or totally disconnected',
          'Fractal boundary structure',
          'Sensitive to parameter changes',
          'Related to Mandelbrot set'
        ],
        equation: `z_{n+1} = z_n² + (${real.toFixed(4)} + ${imag.toFixed(4)}i)`,
        significance: 'Each point in the Mandelbrot set corresponds to a connected Julia set.'
      };
    }
  };

  // I'm analyzing performance characteristics
  const getPerformanceAnalysis = () => {
    if (!props.metadata) return null;

    const { computationTime, pixelsComputed, pixelsPerSecond, parallelEfficiency, memoryUsage } = props.metadata;

    const efficiency = pixelsPerSecond > 10000 ? 'Exceptional' :
                      pixelsPerSecond > 5000 ? 'Excellent' :
                      pixelsPerSecond > 2000 ? 'Very Good' :
                      pixelsPerSecond > 1000 ? 'Good' : 'Fair';

    const parallelRating = parallelEfficiency > 0.8 ? 'Excellent' :
                          parallelEfficiency > 0.6 ? 'Good' :
                          parallelEfficiency > 0.4 ? 'Fair' : 'Poor';

    return {
      efficiency,
      parallelRating,
      computationRate: (pixelsComputed / computationTime * 1000).toFixed(0),
      memoryEfficiency: memoryUsage < 100 ? 'Excellent' : memoryUsage < 500 ? 'Good' : 'Heavy'
    };
  };

  const formatNumber = (num: number, decimals: number = 2): string => {
    if (Math.abs(num) > 1000000) {
      return (num / 1000000).toFixed(1) + 'M';
    } else if (Math.abs(num) > 1000) {
      return (num / 1000).toFixed(1) + 'K';
    }
    return num.toFixed(decimals);
  };

  const mathematicalProps = getMathematicalProperties();
  const theoreticalInfo = getTheoreticalInfo();
  const performanceAnalysis = getPerformanceAnalysis();

  return (
    <Show when={props.visible}>
      <div class="fixed bottom-4 left-4 w-96 z-20">
        <Card variant="glass" padding="none" class="backdrop-blur-md border-neutral-700">
          {/* Header */}
          <div class="flex items-center justify-between p-4 border-b border-neutral-700">
            <h3 class="font-mono text-sm text-neutral-300 tracking-wide">
              FRACTAL ANALYSIS
            </h3>
            <button
              onClick={props.onToggle}
              class="text-neutral-500 hover:text-neutral-300 transition-colors duration-200"
            >
              ✕
            </button>
          </div>

          {/* Tab Navigation */}
          <div class="flex border-b border-neutral-800">
            {(['math', 'performance', 'theory'] as const).map((tab) => (
              <button
                onClick={() => setActiveSection(tab)}
                class={`flex-1 px-3 py-2 text-xs font-mono uppercase tracking-wide transition-colors duration-200 ${
                  activeSection() === tab
                    ? 'bg-neutral-800 text-neutral-200 border-b-2 border-cyan-400'
                    : 'text-neutral-500 hover:text-neutral-300'
                }`}
              >
                {tab}
              </button>
            ))}
          </div>

          {/* Mathematical Properties */}
          <Show when={activeSection() === 'math'}>
            <div class="p-4 space-y-4">
              <div class="bg-neutral-900/50 rounded-lg p-3">
                <div class="text-xs text-neutral-500 font-mono uppercase mb-2">Complex Plane</div>
                <div class="space-y-2 text-xs">
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Center:</span>
                    <span class="text-neutral-400 font-mono">{mathematicalProps.centerPoint}</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Magnification:</span>
                    <span class="text-neutral-400 font-mono">{formatNumber(mathematicalProps.magnification)}</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Pixel Size:</span>
                    <span class="text-neutral-400 font-mono">{mathematicalProps.pixelSize.toExponential(3)}</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Plane Width:</span>
                    <span class="text-neutral-400 font-mono">{mathematicalProps.complexPlaneWidth.toFixed(6)}</span>
                  </div>
                </div>
              </div>

              <div class="bg-neutral-900/50 rounded-lg p-3">
                <div class="text-xs text-neutral-500 font-mono uppercase mb-2">Computation</div>
                <div class="space-y-2 text-xs">
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Max Iterations:</span>
                    <span class="text-neutral-400 font-mono">{mathematicalProps.iterationDepth}</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Escape Radius:</span>
                    <span class="text-neutral-400 font-mono">{mathematicalProps.escapeRadius}</span>
                  </div>
                  <Show when={props.parameters.juliaConstant}>
                    <div class="flex justify-between">
                      <span class="text-neutral-600">Julia Constant:</span>
                      <span class="text-neutral-400 font-mono">
                        {props.parameters.juliaConstant!.real.toFixed(4)} + {props.parameters.juliaConstant!.imag.toFixed(4)}i
                      </span>
                    </div>
                  </Show>
                </div>
              </div>

              <div class="text-xs text-neutral-600 italic leading-relaxed">
                "In the infinite complexity of fractals, we glimpse the mathematical underpinnings of chaos and beauty."
              </div>
            </div>
          </Show>

          {/* Performance Analysis */}
          <Show when={activeSection() === 'performance' && props.metadata}>
            <div class="p-4 space-y-4">
              <div class="bg-neutral-900/50 rounded-lg p-3">
                <div class="text-xs text-neutral-500 font-mono uppercase mb-2">Computation</div>
                <div class="space-y-2 text-xs">
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Time:</span>
                    <span class="text-neutral-400 font-mono">{props.metadata!.computationTime}ms</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Pixels:</span>
                    <span class="text-neutral-400 font-mono">{formatNumber(props.metadata!.pixelsComputed)}</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Rate:</span>
                    <span class="text-neutral-400 font-mono">{formatNumber(props.metadata!.pixelsPerSecond)}/sec</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Efficiency:</span>
                    <span class="text-cyan-400 font-mono">{performanceAnalysis?.efficiency}</span>
                  </div>
                </div>
              </div>

              <div class="bg-neutral-900/50 rounded-lg p-3">
                <div class="text-xs text-neutral-500 font-mono uppercase mb-2">Parallel Processing</div>
                <div class="space-y-2 text-xs">
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Efficiency:</span>
                    <span class="text-neutral-400 font-mono">{(props.metadata!.parallelEfficiency * 100).toFixed(1)}%</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Rating:</span>
                    <span class="text-cyan-400 font-mono">{performanceAnalysis?.parallelRating}</span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-600">Memory:</span>
                    <span class="text-neutral-400 font-mono">{props.metadata!.memoryUsage.toFixed(1)}MB</span>
                  </div>
                </div>
              </div>

              <div class="bg-gradient-to-r from-neutral-900/50 to-cyan-900/20 rounded-lg p-3">
                <div class="text-xs text-cyan-400 font-mono uppercase mb-2">Rust Performance</div>
                <div class="text-xs text-neutral-400 leading-relaxed">
                  Zero-cost abstractions and SIMD optimization deliver mathematical precision at silicon speed.
                  Each iteration computed with memory safety guaranteed.
                </div>
              </div>
            </div>
          </Show>

          {/* Theoretical Background */}
          <Show when={activeSection() === 'theory'}>
            <div class="p-4 space-y-4">
              <div>
                <h4 class="text-sm font-mono text-neutral-300 mb-2">{theoreticalInfo.title}</h4>
                <p class="text-xs text-neutral-500 leading-relaxed mb-3">
                  {theoreticalInfo.definition}
                </p>
              </div>

              <div class="bg-neutral-900/50 rounded-lg p-3">
                <div class="text-xs text-neutral-500 font-mono uppercase mb-2">Mathematical Formula</div>
                <div class="text-sm font-mono text-neutral-300 bg-black/50 rounded p-2 text-center">
                  {theoreticalInfo.equation}
                </div>
              </div>

              <div class="bg-neutral-900/50 rounded-lg p-3">
                <div class="text-xs text-neutral-500 font-mono uppercase mb-2">Properties</div>
                <div class="space-y-1">
                  <For each={theoreticalInfo.properties}>
                    {(property) => (
                      <div class="flex items-start gap-2 text-xs">
                        <span class="text-cyan-400 mt-1">•</span>
                        <span class="text-neutral-400">{property}</span>
                      </div>
                    )}
                  </For>
                </div>
              </div>

              <div class="space-y-2 text-xs">
                <div class="flex justify-between">
                  <span class="text-neutral-600">Discovered:</span>
                  <span class="text-neutral-400">{theoreticalInfo.discoverer}</span>
                </div>
                <div class="flex justify-between">
                  <span class="text-neutral-600">Dimension:</span>
                  <span class="text-neutral-400 font-mono">{theoreticalInfo.dimension}</span>
                </div>
              </div>

              <div class="border-t border-neutral-800 pt-3">
                <p class="text-xs text-neutral-600 italic leading-relaxed">
                  {theoreticalInfo.significance}
                </p>
              </div>
            </div>
          </Show>

          {/* Footer */}
          <div class="p-3 border-t border-neutral-800 bg-neutral-900/30">
            <div class="text-xs text-neutral-600 text-center font-mono">
              "Mathematics is the language with which God has written the universe." - Galileo
            </div>
          </div>
        </Card>
      </div>
    </Show>
  );
};
</file>

<file path="src/components/GitHub/ProjectCard.tsx">
/*
 * Individual repository card component displaying GitHub project information with interactive elements and dark aesthetic styling.
 * I'm implementing comprehensive repository visualization including language indicators, statistics, health metrics, and hover effects that maintain the eerie, contemplative theme.
 */

import { Component, Show, For, createMemo } from 'solid-js';
import { Card } from '../UI/Card';

interface Repository {
  id: number;
  name: string;
  full_name: string;
  description?: string;
  html_url: string;
  language?: string;
  stargazers_count: number;
  watchers_count: number;
  forks_count: number;
  open_issues_count: number;
  size_kb: number;
  created_at: string;
  updated_at: string;
  pushed_at?: string;
  is_private: boolean;
  is_fork: boolean;
  is_archived: boolean;
  topics: string[];
  license_name?: string;
}

interface ProjectCardProps {
  repository: Repository;
  onClick?: (repository: Repository) => void;
  viewMode?: 'grid' | 'list';
}

export const ProjectCard: Component<ProjectCardProps> = (props) => {
  // I'm creating language color mapping for visual coding language identification
  const getLanguageColor = (language: string): string => {
    const colors: Record<string, string> = {
      'JavaScript': '#f1e05a',
      'TypeScript': '#2b7489',
      'Python': '#3572A5',
      'Java': '#b07219',
      'C++': '#f34b7d',
      'C': '#555555',
      'C#': '#239120',
      'PHP': '#4F5D95',
      'Ruby': '#701516',
      'Go': '#00ADD8',
      'Rust': '#dea584',
      'Swift': '#ffac45',
      'Kotlin': '#F18E33',
      'HTML': '#e34c26',
      'CSS': '#1572B6',
      'Shell': '#89e051',
      'Dockerfile': '#384d54',
      'Vue': '#4FC08D',
      'Svelte': '#ff3e00',
      'Dart': '#00B4AB',
    };
    return colors[language] || '#586069';
  };

  // I'm calculating repository health and activity metrics
  const getHealthMetrics = createMemo(() => {
    const repo = props.repository;
    const daysSinceUpdate = (new Date().getTime() - new Date(repo.updated_at).getTime()) / (1000 * 60 * 60 * 24);

    let healthScore = 0;
    if (repo.description) healthScore += 1;
    if (repo.topics.length > 0) healthScore += 1;
    if (repo.license_name) healthScore += 1;
    if (daysSinceUpdate <= 90) healthScore += 1;

    const healthRating = healthScore === 4 ? 'excellent' :
                        healthScore === 3 ? 'good' :
                        healthScore === 2 ? 'fair' : 'poor';

    const activityScore = Math.log(repo.stargazers_count + 1) * 5 +
                         Math.log(repo.forks_count + 1) * 3 +
                         (daysSinceUpdate < 30 ? 20 : daysSinceUpdate < 90 ? 10 : 0);

    return {
      healthRating,
      healthScore,
      activityScore: Math.min(activityScore, 100),
      daysSinceUpdate: Math.floor(daysSinceUpdate),
      isActive: daysSinceUpdate <= 90
    };
  });

  // I'm formatting file sizes for human readability
  const formatSize = (sizeKb: number): string => {
    if (sizeKb < 1024) return `${sizeKb} KB`;
    const sizeMb = sizeKb / 1024;
    if (sizeMb < 1024) return `${sizeMb.toFixed(1)} MB`;
    const sizeGb = sizeMb / 1024;
    return `${sizeGb.toFixed(1)} GB`;
  };

  // I'm creating relative time formatting for timestamps
  const formatRelativeTime = (dateString: string): string => {
    const date = new Date(dateString);
    const now = new Date();
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

    if (diffInSeconds < 60) return 'just now';
    if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
    if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
    if (diffInSeconds < 604800) return `${Math.floor(diffInSeconds / 86400)}d ago`;
    if (diffInSeconds < 2629746) return `${Math.floor(diffInSeconds / 604800)}w ago`;
    return `${Math.floor(diffInSeconds / 2629746)}mo ago`;
  };

  const healthMetrics = getHealthMetrics();
  const repo = props.repository;

  // I'm implementing different layouts based on view mode
  if (props.viewMode === 'list') {
    return (
      <Card
        interactive
        hover
        onClick={() => props.onClick?.(repo)}
        class="cursor-pointer"
      >
        <div class="flex items-start justify-between gap-4">
          <div class="flex-1 min-w-0">
            {/* Header with name and status indicators */}
            <div class="flex items-center gap-2 mb-2">
              <h3 class="font-mono text-lg text-neutral-100 truncate group-hover:text-cyan-400 transition-colors duration-200">
                {repo.name}
              </h3>

              <div class="flex items-center gap-1">
                <Show when={repo.is_private}>
                  <span class="px-1.5 py-0.5 bg-yellow-900/30 text-yellow-400 border border-yellow-800 rounded text-xs font-mono">
                    PRIVATE
                  </span>
                </Show>
                <Show when={repo.is_fork}>
                  <span class="px-1.5 py-0.5 bg-blue-900/30 text-blue-400 border border-blue-800 rounded text-xs font-mono">
                    FORK
                  </span>
                </Show>
                <Show when={repo.is_archived}>
                  <span class="px-1.5 py-0.5 bg-neutral-800 text-neutral-500 border border-neutral-700 rounded text-xs font-mono">
                    ARCHIVED
                  </span>
                </Show>
              </div>
            </div>

            {/* Description */}
            <Show when={repo.description}>
              <p class="text-neutral-400 text-sm mb-3 line-clamp-2 leading-relaxed">
                {repo.description}
              </p>
            </Show>

            {/* Stats and metadata */}
            <div class="flex items-center gap-4 text-xs text-neutral-500">
              <Show when={repo.language}>
                <div class="flex items-center gap-1.5">
                  <div
                    class="w-3 h-3 rounded-full"
                    style={{ 'background-color': getLanguageColor(repo.language!) }}
                  ></div>
                  <span>{repo.language}</span>
                </div>
              </Show>

              <Show when={repo.stargazers_count > 0}>
                <div class="flex items-center gap-1">
                  <span>⭐</span>
                  <span>{repo.stargazers_count}</span>
                </div>
              </Show>

              <Show when={repo.forks_count > 0}>
                <div class="flex items-center gap-1">
                  <span>🍴</span>
                  <span>{repo.forks_count}</span>
                </div>
              </Show>

              <span>Updated {formatRelativeTime(repo.updated_at)}</span>
              <span>{formatSize(repo.size_kb)}</span>
            </div>
          </div>

          {/* Right side metadata */}
          <div class="flex flex-col items-end gap-2 text-xs">
            <div class={`px-2 py-1 rounded font-mono ${
              healthMetrics.healthRating === 'excellent' ? 'bg-green-900/30 text-green-400' :
              healthMetrics.healthRating === 'good' ? 'bg-blue-900/30 text-blue-400' :
              healthMetrics.healthRating === 'fair' ? 'bg-yellow-900/30 text-yellow-400' :
              'bg-red-900/30 text-red-400'
            }`}>
              {healthMetrics.healthRating.toUpperCase()}
            </div>

            <div class="text-neutral-600 font-mono">
              Activity: {healthMetrics.activityScore.toFixed(0)}
            </div>
          </div>
        </div>
      </Card>
    );
  }

  // I'm implementing the grid card layout as default
  return (
    <Card
      interactive
      hover
      glow
      onClick={() => props.onClick?.(repo)}
      class="cursor-pointer h-full"
    >
      <div class="flex flex-col h-full">
        {/* Header */}
        <div class="flex items-start justify-between mb-3">
          <div class="flex-1 min-w-0">
            <div class="flex items-center gap-2 mb-1">
              <h3 class="font-mono text-xl text-neutral-100 truncate group-hover:text-cyan-400 transition-colors duration-200">
                {repo.name}
              </h3>
            </div>

            <div class="flex items-center gap-1 mb-2">
              <Show when={repo.is_private}>
                <div class="w-2 h-2 bg-yellow-500 rounded-full" title="Private repository"></div>
              </Show>
              <Show when={repo.is_fork}>
                <div class="w-2 h-2 bg-blue-500 rounded-full" title="Forked repository"></div>
              </Show>
              <Show when={repo.is_archived}>
                <div class="w-2 h-2 bg-neutral-600 rounded-full" title="Archived repository"></div>
              </Show>
            </div>
          </div>

          {/* Health indicator */}
          <div class={`px-2 py-1 rounded text-xs font-mono ${
            healthMetrics.healthRating === 'excellent' ? 'bg-green-900/30 text-green-400 border border-green-800' :
            healthMetrics.healthRating === 'good' ? 'bg-blue-900/30 text-blue-400 border border-blue-800' :
            healthMetrics.healthRating === 'fair' ? 'bg-yellow-900/30 text-yellow-400 border border-yellow-800' :
            'bg-red-900/30 text-red-400 border border-red-800'
          }`}>
            {healthMetrics.healthRating.toUpperCase()}
          </div>
        </div>

        {/* Description */}
        <Show when={repo.description} fallback={
          <div class="text-neutral-600 text-sm italic mb-4 flex-1">
            No description provided
          </div>
        }>
          <p class="text-neutral-400 text-sm mb-4 line-clamp-3 leading-relaxed flex-1">
            {repo.description}
          </p>
        </Show>

        {/* Topics */}
        <Show when={repo.topics.length > 0}>
          <div class="flex flex-wrap gap-1 mb-4">
            <For each={repo.topics.slice(0, 3)}>
              {(topic) => (
                <span class="text-xs px-2 py-1 bg-neutral-800/50 text-neutral-400 rounded font-mono border border-neutral-700">
                  {topic}
                </span>
              )}
            </For>
            <Show when={repo.topics.length > 3}>
              <span class="text-xs px-2 py-1 text-neutral-600 font-mono">
                +{repo.topics.length - 3}
              </span>
            </Show>
          </div>
        </Show>

        {/* Statistics */}
        <div class="flex items-center justify-between mt-auto pt-4 border-t border-neutral-800">
          <div class="flex items-center gap-3 text-xs text-neutral-500">
            <Show when={repo.language}>
              <div class="flex items-center gap-1.5">
                <div
                  class="w-2 h-2 rounded-full"
                  style={{ 'background-color': getLanguageColor(repo.language!) }}
                ></div>
                <span>{repo.language}</span>
              </div>
            </Show>

            <Show when={repo.stargazers_count > 0}>
              <div class="flex items-center gap-1">
                <span>⭐</span>
                <span>{repo.stargazers_count}</span>
              </div>
            </Show>

            <Show when={repo.forks_count > 0}>
              <div class="flex items-center gap-1">
                <span>🍴</span>
                <span>{repo.forks_count}</span>
              </div>
            </Show>
          </div>

          <div class="flex flex-col items-end text-xs">
            <div class="text-neutral-600 font-mono">
              {formatSize(repo.size_kb)}
            </div>
            <div class="text-neutral-600 font-mono">
              {formatRelativeTime(repo.updated_at)}
            </div>
          </div>
        </div>

        {/* Activity indicator */}
        <div class="mt-2">
          <div class="flex items-center justify-between text-xs">
            <span class="text-neutral-600">Activity</span>
            <span class="text-neutral-500 font-mono">
              {healthMetrics.activityScore.toFixed(0)}/100
            </span>
          </div>
          <div class="w-full h-1 bg-neutral-800 rounded-full mt-1 overflow-hidden">
            <div
              class={`h-full rounded-full transition-all duration-500 ${
                healthMetrics.activityScore > 70 ? 'bg-green-500' :
                healthMetrics.activityScore > 40 ? 'bg-yellow-500' :
                'bg-red-500'
              }`}
              style={{ width: `${Math.min(healthMetrics.activityScore, 100)}%` }}
            ></div>
          </div>
        </div>

        {/* Hover overlay for additional info */}
        <div class="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none rounded-lg"></div>
      </div>
    </Card>
  );
};
</file>

<file path="src/components/GitHub/ProjectDetail.tsx">
/*
 * Detailed repository view component providing comprehensive project information including README, statistics, and metadata analysis.
 * I'm implementing an immersive project exploration interface with performance metrics, contribution analysis, and technical insights that maintains the dark, contemplative aesthetic.
 */

import { Component, createSignal, Show, For, onMount, createEffect } from 'solid-js';
import { Card, MetricCard, StatusCard } from '../UI/Card';
import { LoadingSpinner } from '../UI/LoadingSpinner';

interface Repository {
  id: number;
  name: string;
  full_name: string;
  description?: string;
  html_url: string;
  clone_url: string;
  ssh_url: string;
  language?: string;
  stargazers_count: number;
  watchers_count: number;
  forks_count: number;
  open_issues_count: number;
  size_kb: number;
  created_at: string;
  updated_at: string;
  pushed_at?: string;
  is_private: boolean;
  is_fork: boolean;
  is_archived: boolean;
  topics: string[];
  license_name?: string;
  readme_content?: string;
}

interface RepositoryStats {
  commit_frequency: number;
  contributors_count: number;
  issues_ratio: number;
  fork_ratio: number;
  activity_score: number;
  health_score: number;
  last_activity_days: number;
}

interface ProjectDetailProps {
  repository: Repository;
  onClose: () => void;
  isLoading?: boolean;
}

export const ProjectDetail: Component<ProjectDetailProps> = (props) => {
  const [activeTab, setActiveTab] = createSignal<'overview' | 'readme' | 'analytics' | 'insights'>('overview');
  const [repositoryStats, setRepositoryStats] = createSignal<RepositoryStats | null>(null);
  const [isLoadingStats, setIsLoadingStats] = createSignal(false);

  // I'm fetching detailed statistics when the component mounts
  onMount(async () => {
    if (props.repository) {
      await fetchRepositoryStats();
    }
  });

  // I'm updating stats when repository changes
  createEffect(async () => {
    if (props.repository) {
      await fetchRepositoryStats();
    }
  });

  const fetchRepositoryStats = async () => {
    setIsLoadingStats(true);
    try {
      const response = await fetch(`/api/github/repo/${props.repository.full_name}/stats`);
      if (response.ok) {
        const stats = await response.json();
        setRepositoryStats(stats);
      }
    } catch (error) {
      console.error('Failed to fetch repository stats:', error);
    } finally {
      setIsLoadingStats(false);
    }
  };

  // I'm calculating derived metrics and insights
  const getHealthInsights = () => {
    const repo = props.repository;
    const stats = repositoryStats();

    const insights = [];

    if (!repo.description) {
      insights.push({ type: 'warning', message: 'Missing description - consider adding one for better discoverability' });
    }

    if (repo.topics.length === 0) {
      insights.push({ type: 'info', message: 'No topics defined - adding topics helps with categorization' });
    }

    if (!repo.license_name) {
      insights.push({ type: 'warning', message: 'No license specified - consider adding one for legal clarity' });
    }

    if (stats && stats.last_activity_days > 180) {
      insights.push({ type: 'error', message: 'Repository appears inactive - last activity over 6 months ago' });
    }

    if (repo.stargazers_count > 0 && repo.forks_count === 0) {
      insights.push({ type: 'info', message: 'High star-to-fork ratio suggests excellent code quality' });
    }

    return insights;
  };

  // I'm formatting various data types for display
  const formatDate = (dateString: string): string => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  const formatSize = (sizeKb: number): string => {
    if (sizeKb < 1024) return `${sizeKb} KB`;
    const sizeMb = sizeKb / 1024;
    if (sizeMb < 1024) return `${sizeMb.toFixed(1)} MB`;
    const sizeGb = sizeMb / 1024;
    return `${sizeGb.toFixed(1)} GB`;
  };

  const getLanguageColor = (language: string): string => {
    const colors: Record<string, string> = {
      'JavaScript': '#f1e05a',
      'TypeScript': '#2b7489',
      'Python': '#3572A5',
      'Rust': '#dea584',
      'Go': '#00ADD8',
      'Java': '#b07219',
      'C++': '#f34b7d',
      'C': '#555555',
    };
    return colors[language] || '#586069';
  };

  const healthInsights = getHealthInsights();
  const repo = props.repository;
  const stats = repositoryStats();

  return (
    <div class="fixed inset-0 bg-black/80 backdrop-blur-md z-50 flex items-center justify-center p-4">
      <div class="max-w-6xl w-full max-h-[90vh] overflow-hidden rounded-lg bg-black border border-neutral-700">
        {/* Header */}
        <div class="flex items-center justify-between p-6 border-b border-neutral-800">
          <div class="flex-1 min-w-0">
            <h1 class="text-2xl font-mono text-neutral-100 mb-2">
              {repo.name}
            </h1>
            <div class="flex items-center gap-2 text-sm text-neutral-500">
              <span>{repo.full_name}</span>
              <Show when={repo.is_private}>
                <span class="px-2 py-1 bg-yellow-900/30 text-yellow-400 border border-yellow-800 rounded text-xs font-mono">
                  PRIVATE
                </span>
              </Show>
              <Show when={repo.is_fork}>
                <span class="px-2 py-1 bg-blue-900/30 text-blue-400 border border-blue-800 rounded text-xs font-mono">
                  FORK
                </span>
              </Show>
              <Show when={repo.is_archived}>
                <span class="px-2 py-1 bg-neutral-800 text-neutral-500 border border-neutral-700 rounded text-xs font-mono">
                  ARCHIVED
                </span>
              </Show>
            </div>
          </div>

          <div class="flex items-center gap-3">
            <a
              href={repo.html_url}
              target="_blank"
              rel="noopener noreferrer"
              class="px-4 py-2 bg-neutral-800 hover:bg-neutral-700 text-neutral-300 rounded font-mono text-sm transition-colors duration-200"
            >
              VIEW ON GITHUB ↗
            </a>
            <button
              onClick={props.onClose}
              class="px-4 py-2 bg-transparent border border-neutral-600 hover:border-neutral-500 text-neutral-400 hover:text-neutral-300 rounded font-mono text-sm transition-colors duration-200"
            >
              CLOSE
            </button>
          </div>
        </div>

        {/* Tab Navigation */}
        <div class="flex border-b border-neutral-800">
          {(['overview', 'readme', 'analytics', 'insights'] as const).map((tab) => (
            <button
              onClick={() => setActiveTab(tab)}
              class={`px-6 py-3 font-mono text-sm uppercase tracking-wide transition-colors duration-200 ${
                activeTab() === tab
                  ? 'bg-neutral-800 text-neutral-200 border-b-2 border-cyan-400'
                  : 'text-neutral-500 hover:text-neutral-300'
              }`}
            >
              {tab}
            </button>
          ))}
        </div>

        {/* Content */}
        <div class="p-6 overflow-y-auto max-h-[calc(90vh-200px)]">
          {/* Overview Tab */}
          <Show when={activeTab() === 'overview'}>
            <div class="grid lg:grid-cols-3 gap-6">
              {/* Main Info */}
              <div class="lg:col-span-2 space-y-6">
                <Show when={repo.description}>
                  <Card>
                    <h3 class="text-lg font-mono text-neutral-300 mb-3">Description</h3>
                    <p class="text-neutral-400 leading-relaxed">{repo.description}</p>
                  </Card>
                </Show>

                {/* Topics */}
                <Show when={repo.topics.length > 0}>
                  <Card>
                    <h3 class="text-lg font-mono text-neutral-300 mb-3">Topics</h3>
                    <div class="flex flex-wrap gap-2">
                      <For each={repo.topics}>
                        {(topic) => (
                          <span class="px-3 py-1 bg-neutral-800 text-neutral-400 rounded font-mono text-sm border border-neutral-700">
                            {topic}
                          </span>
                        )}
                      </For>
                    </div>
                  </Card>
                </Show>

                {/* Clone URLs */}
                <Card>
                  <h3 class="text-lg font-mono text-neutral-300 mb-3">Clone Repository</h3>
                  <div class="space-y-3">
                    <div>
                      <label class="text-xs text-neutral-500 font-mono uppercase block mb-1">HTTPS</label>
                      <div class="flex items-center gap-2">
                        <input
                          type="text"
                          value={repo.clone_url}
                          readonly
                          class="flex-1 bg-neutral-900 border border-neutral-700 rounded px-3 py-2 text-sm font-mono text-neutral-300"
                        />
                        <button
                          onClick={() => navigator.clipboard.writeText(repo.clone_url)}
                          class="px-3 py-2 bg-neutral-800 hover:bg-neutral-700 text-neutral-400 rounded text-sm transition-colors duration-200"
                        >
                          COPY
                        </button>
                      </div>
                    </div>
                    <div>
                      <label class="text-xs text-neutral-500 font-mono uppercase block mb-1">SSH</label>
                      <div class="flex items-center gap-2">
                        <input
                          type="text"
                          value={repo.ssh_url}
                          readonly
                          class="flex-1 bg-neutral-900 border border-neutral-700 rounded px-3 py-2 text-sm font-mono text-neutral-300"
                        />
                        <button
                          onClick={() => navigator.clipboard.writeText(repo.ssh_url)}
                          class="px-3 py-2 bg-neutral-800 hover:bg-neutral-700 text-neutral-400 rounded text-sm transition-colors duration-200"
                        >
                          COPY
                        </button>
                      </div>
                    </div>
                  </div>
                </Card>
              </div>

              {/* Statistics Sidebar */}
              <div class="space-y-4">
                <MetricCard
                  title="Stars"
                  value={repo.stargazers_count}
                  icon={<span>⭐</span>}
                  description="Developer appreciation"
                />

                <MetricCard
                  title="Forks"
                  value={repo.forks_count}
                  icon={<span>🍴</span>}
                  description="Community contributions"
                />

                <MetricCard
                  title="Watchers"
                  value={repo.watchers_count}
                  icon={<span>👁</span>}
                  description="Active observers"
                />

                <MetricCard
                  title="Open Issues"
                  value={repo.open_issues_count}
                  icon={<span>🐛</span>}
                  description="Pending discussions"
                />

                <MetricCard
                  title="Repository Size"
                  value={formatSize(repo.size_kb)}
                  icon={<span>📦</span>}
                  description="Total codebase size"
                />

                <Show when={repo.language}>
                  <Card>
                    <div class="flex items-center gap-2 mb-2">
                      <div
                        class="w-3 h-3 rounded-full"
                        style={{ 'background-color': getLanguageColor(repo.language!) }}
                      ></div>
                      <span class="text-sm font-mono text-neutral-300">{repo.language}</span>
                    </div>
                    <div class="text-xs text-neutral-500">Primary language</div>
                  </Card>
                </Show>

                <Show when={repo.license_name}>
                  <StatusCard
                    status="healthy"
                    title="License"
                    message={repo.license_name}
                  />
                </Show>

                <Card>
                  <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Created:</span>
                      <span class="text-neutral-400">{formatDate(repo.created_at)}</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Updated:</span>
                      <span class="text-neutral-400">{formatDate(repo.updated_at)}</span>
                    </div>
                    <Show when={repo.pushed_at}>
                      <div class="flex justify-between">
                        <span class="text-neutral-500">Last Push:</span>
                        <span class="text-neutral-400">{formatDate(repo.pushed_at!)}</span>
                      </div>
                    </Show>
                  </div>
                </Card>
              </div>
            </div>
          </Show>

          {/* README Tab */}
          <Show when={activeTab() === 'readme'}>
            <Card>
              <Show when={repo.readme_content} fallback={
                <div class="text-center py-12">
                  <div class="text-neutral-500 font-mono mb-2">No README available</div>
                  <div class="text-neutral-600 text-sm">This repository doesn't have a README file.</div>
                </div>
              }>
                <div class="prose prose-invert max-w-none">
                  <pre class="bg-neutral-900 p-4 rounded text-sm text-neutral-300 whitespace-pre-wrap">
                    {repo.readme_content}
                  </pre>
                </div>
              </Show>
            </Card>
          </Show>

          {/* Analytics Tab */}
          <Show when={activeTab() === 'analytics'}>
            <Show when={isLoadingStats()}>
              <div class="flex justify-center py-12">
                <LoadingSpinner message="Loading repository analytics..." />
              </div>
            </Show>

            <Show when={!isLoadingStats() && stats}>
              <div class="grid lg:grid-cols-2 gap-6">
                <MetricCard
                  title="Activity Score"
                  value={stats!.activity_score.toFixed(1)}
                  unit="/100"
                  description="Overall repository activity"
                />

                <MetricCard
                  title="Health Score"
                  value={stats!.health_score.toFixed(1)}
                  unit="/100"
                  description="Repository maintenance quality"
                />

                <MetricCard
                  title="Contributors"
                  value={stats!.contributors_count}
                  description="Unique contributors"
                />

                <MetricCard
                  title="Issue Ratio"
                  value={`${(stats!.issues_ratio * 100).toFixed(1)}%`}
                  description="Open vs total issues"
                />

                <MetricCard
                  title="Fork Ratio"
                  value={stats!.fork_ratio.toFixed(2)}
                  description="Forks per star"
                />

                <MetricCard
                  title="Last Activity"
                  value={stats!.last_activity_days}
                  unit="days ago"
                  description="Days since last commit"
                />
              </div>
            </Show>
          </Show>

          {/* Insights Tab */}
          <Show when={activeTab() === 'insights'}>
            <div class="space-y-6">
              <Card>
                <h3 class="text-lg font-mono text-neutral-300 mb-4">Repository Health Analysis</h3>
                <Show when={healthInsights.length > 0} fallback={
                  <div class="text-center py-8">
                    <div class="text-green-400 text-2xl mb-2">✓</div>
                    <div class="text-neutral-300 font-mono">All health checks passed</div>
                    <div class="text-neutral-500 text-sm mt-1">This repository follows best practices</div>
                  </div>
                }>
                  <div class="space-y-3">
                    <For each={healthInsights}>
                      {(insight) => (
                        <div class={`p-3 rounded border-l-4 ${
                          insight.type === 'error' ? 'bg-red-900/20 border-red-500 text-red-300' :
                          insight.type === 'warning' ? 'bg-yellow-900/20 border-yellow-500 text-yellow-300' :
                          'bg-blue-900/20 border-blue-500 text-blue-300'
                        }`}>
                          <div class="text-sm">{insight.message}</div>
                        </div>
                      )}
                    </For>
                  </div>
                </Show>
              </Card>

              <Card>
                <h3 class="text-lg font-mono text-neutral-300 mb-4">Performance Insights</h3>
                <div class="space-y-4">
                  <div class="bg-neutral-900/50 rounded p-4">
                    <div class="text-sm text-neutral-400 mb-2">Engagement Analysis</div>
                    <div class="text-xs text-neutral-500">
                      This repository has {repo.stargazers_count} stars and {repo.forks_count} forks,
                      indicating {repo.forks_count > repo.stargazers_count * 0.1 ? 'high' : 'moderate'} community engagement.
                      The star-to-fork ratio suggests the code is {repo.forks_count === 0 && repo.stargazers_count > 0 ? 'viewed more than modified' : 'actively used and modified'}.
                    </div>
                  </div>

                  <div class="bg-neutral-900/50 rounded p-4">
                    <div class="text-sm text-neutral-400 mb-2">Maintenance Status</div>
                    <div class="text-xs text-neutral-500">
                      Last updated {formatDate(repo.updated_at)}.
                      {repo.is_archived ? ' This repository is archived and no longer actively maintained.' :
                       ' The repository appears to be actively maintained.'}
                    </div>
                  </div>

                  <div class="bg-neutral-900/50 rounded p-4">
                    <div class="text-sm text-neutral-400 mb-2">Technical Assessment</div>
                    <div class="text-xs text-neutral-500">
                      Repository size: {formatSize(repo.size_kb)}.
                      {repo.size_kb > 100000 ? ' Large codebase indicating comprehensive project.' :
                       repo.size_kb > 10000 ? ' Medium-sized project with substantial code.' :
                       ' Compact codebase, likely focused or minimal project.'}
                    </div>
                  </div>
                </div>
              </Card>
            </div>
          </Show>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/components/GitHub/ProjectFilters.tsx">
/*
 * Repository filtering and search interface providing comprehensive filtering options for GitHub project discovery.
 * I'm implementing advanced filtering capabilities including language, stars, size, and activity filters while maintaining the dark aesthetic and providing real-time filter feedback.
 */

import { Component, createSignal, Show, For, createEffect } from 'solid-js';
import { Card } from '../UI/Card';

interface FilterOptions {
  search: string;
  language: string;
  minStars: number;
  maxStars: number;
  minSize: number;
  maxSize: number;
  isArchived: boolean | null;
  isFork: boolean | null;
  hasTopics: boolean | null;
  hasLicense: boolean | null;
  sort: string;
  direction: 'asc' | 'desc';
  updatedAfter: string;
}

interface ProjectFiltersProps {
  filters: FilterOptions;
  onFiltersChange: (filters: Partial<FilterOptions>) => void;
  languages: string[];
  totalCount: number;
  filteredCount: number;
  isLoading?: boolean;
}

export const ProjectFilters: Component<ProjectFiltersProps> = (props) => {
  const [isExpanded, setIsExpanded] = createSignal(false);
  const [activeFilterCount, setActiveFilterCount] = createSignal(0);

  // I'm tracking the number of active filters for UI feedback
  createEffect(() => {
    let count = 0;
    const filters = props.filters;

    if (filters.search) count++;
    if (filters.language) count++;
    if (filters.minStars > 0) count++;
    if (filters.maxStars < 10000) count++;
    if (filters.minSize > 0) count++;
    if (filters.maxSize < 1000000) count++;
    if (filters.isArchived !== null) count++;
    if (filters.isFork !== null) count++;
    if (filters.hasTopics !== null) count++;
    if (filters.hasLicense !== null) count++;
    if (filters.updatedAfter) count++;

    setActiveFilterCount(count);
  });

  const clearAllFilters = () => {
    props.onFiltersChange({
      search: '',
      language: '',
      minStars: 0,
      maxStars: 10000,
      minSize: 0,
      maxSize: 1000000,
      isArchived: null,
      isFork: null,
      hasTopics: null,
      hasLicense: null,
      updatedAfter: '',
    });
  };

  const sortOptions = [
    { value: 'updated', label: 'Recently Updated' },
    { value: 'created', label: 'Recently Created' },
    { value: 'stars', label: 'Most Stars' },
    { value: 'forks', label: 'Most Forks' },
    { value: 'name', label: 'Name' },
    { value: 'size', label: 'Size' },
  ];

  const timeRangeOptions = [
    { value: '', label: 'All Time' },
    { value: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], label: 'Last 30 Days' },
    { value: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], label: 'Last 3 Months' },
    { value: new Date(Date.now() - 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], label: 'Last Year' },
  ];

  return (
    <Card variant="glass" class="backdrop-blur-md">
      {/* Header */}
      <div class="flex items-center justify-between mb-4">
        <div class="flex items-center gap-3">
          <h3 class="font-mono text-sm text-neutral-300 tracking-wide">
            FILTERS
          </h3>
          <Show when={activeFilterCount() > 0}>
            <span class="px-2 py-1 bg-cyan-900/30 text-cyan-400 border border-cyan-800 rounded text-xs font-mono">
              {activeFilterCount()} ACTIVE
            </span>
          </Show>
        </div>

        <div class="flex items-center gap-2">
          <Show when={activeFilterCount() > 0}>
            <button
              onClick={clearAllFilters}
              class="px-3 py-1 bg-red-900/30 hover:bg-red-800/30 text-red-400 border border-red-800 rounded text-xs font-mono transition-colors duration-200"
            >
              CLEAR ALL
            </button>
          </Show>

          <button
            onClick={() => setIsExpanded(!isExpanded())}
            class="px-3 py-1 bg-neutral-800 hover:bg-neutral-700 text-neutral-400 rounded text-xs font-mono transition-colors duration-200"
          >
            {isExpanded() ? 'COLLAPSE' : 'EXPAND'}
          </button>
        </div>
      </div>

      {/* Results Summary */}
      <div class="mb-4 p-3 bg-neutral-900/50 rounded">
        <div class="flex items-center justify-between text-xs font-mono">
          <span class="text-neutral-500">
            Showing {props.filteredCount} of {props.totalCount} repositories
          </span>
          <Show when={props.isLoading}>
            <div class="flex items-center gap-2 text-neutral-500">
              <div class="w-3 h-3 border border-cyan-400 border-t-transparent rounded-full animate-spin"></div>
              <span>Filtering...</span>
            </div>
          </Show>
        </div>
      </div>

      {/* Quick Search */}
      <div class="mb-4">
        <label class="block text-xs text-neutral-500 font-mono uppercase mb-2">
          Search
        </label>
        <input
          type="text"
          value={props.filters.search}
          onInput={(e) => props.onFiltersChange({ search: e.currentTarget.value })}
          placeholder="Search repositories, descriptions, topics..."
          class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 placeholder-neutral-600 focus:outline-none"
        />
      </div>

      {/* Sort Options */}
      <div class="grid grid-cols-2 gap-3 mb-4">
        <div>
          <label class="block text-xs text-neutral-500 font-mono uppercase mb-2">
            Sort By
          </label>
          <select
            value={props.filters.sort}
            onChange={(e) => props.onFiltersChange({ sort: e.currentTarget.value })}
            class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
          >
            <For each={sortOptions}>
              {(option) => (
                <option value={option.value}>{option.label}</option>
              )}
            </For>
          </select>
        </div>

        <div>
          <label class="block text-xs text-neutral-500 font-mono uppercase mb-2">
            Direction
          </label>
          <select
            value={props.filters.direction}
            onChange={(e) => props.onFiltersChange({ direction: e.currentTarget.value as 'asc' | 'desc' })}
            class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
          >
            <option value="desc">Descending</option>
            <option value="asc">Ascending</option>
          </select>
        </div>
      </div>

      {/* Expanded Filters */}
      <Show when={isExpanded()}>
        <div class="space-y-4 pt-4 border-t border-neutral-800">
          {/* Language Filter */}
          <div>
            <label class="block text-xs text-neutral-500 font-mono uppercase mb-2">
              Language
            </label>
            <select
              value={props.filters.language}
              onChange={(e) => props.onFiltersChange({ language: e.currentTarget.value })}
              class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
            >
              <option value="">All Languages</option>
              <For each={props.languages}>
                {(language) => (
                  <option value={language}>{language}</option>
                )}
              </For>
            </select>
          </div>

          {/* Stars Range */}
          <div>
            <label class="block text-xs text-neutral-500 font-mono uppercase mb-2">
              Stars Range
            </label>
            <div class="grid grid-cols-2 gap-3">
              <div>
                <label class="block text-xs text-neutral-600 mb-1">Min</label>
                <input
                  type="number"
                  value={props.filters.minStars}
                  onInput={(e) => props.onFiltersChange({ minStars: parseInt(e.currentTarget.value) || 0 })}
                  min="0"
                  class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
                />
              </div>
              <div>
                <label class="block text-xs text-neutral-600 mb-1">Max</label>
                <input
                  type="number"
                  value={props.filters.maxStars}
                  onInput={(e) => props.onFiltersChange({ maxStars: parseInt(e.currentTarget.value) || 10000 })}
                  min="0"
                  class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
                />
              </div>
            </div>
          </div>

          {/* Size Range */}
          <div>
            <label class="block text-xs text-neutral-500 font-mono uppercase mb-2">
              Size Range (KB)
            </label>
            <div class="grid grid-cols-2 gap-3">
              <div>
                <label class="block text-xs text-neutral-600 mb-1">Min</label>
                <input
                  type="number"
                  value={props.filters.minSize}
                  onInput={(e) => props.onFiltersChange({ minSize: parseInt(e.currentTarget.value) || 0 })}
                  min="0"
                  class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
                />
              </div>
              <div>
                <label class="block text-xs text-neutral-600 mb-1">Max</label>
                <input
                  type="number"
                  value={props.filters.maxSize}
                  onInput={(e) => props.onFiltersChange({ maxSize: parseInt(e.currentTarget.value) || 1000000 })}
                  min="0"
                  class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
                />
              </div>
            </div>
          </div>

          {/* Time Range */}
          <div>
            <label class="block text-xs text-neutral-500 font-mono uppercase mb-2">
              Updated After
            </label>
            <select
              value={props.filters.updatedAfter}
              onChange={(e) => props.onFiltersChange({ updatedAfter: e.currentTarget.value })}
              class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
            >
              <For each={timeRangeOptions}>
                {(option) => (
                  <option value={option.value}>{option.label}</option>
                )}
              </For>
            </select>
          </div>

          {/* Boolean Filters */}
          <div class="space-y-3">
            <label class="block text-xs text-neutral-500 font-mono uppercase">
              Repository Type
            </label>

            <div class="grid grid-cols-2 gap-3">
              {/* Archived Filter */}
              <div>
                <label class="block text-xs text-neutral-600 mb-1">Archived</label>
                <select
                  value={props.filters.isArchived === null ? '' : props.filters.isArchived.toString()}
                  onChange={(e) => {
                    const value = e.currentTarget.value;
                    props.onFiltersChange({
                      isArchived: value === '' ? null : value === 'true'
                    });
                  }}
                  class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
                >
                  <option value="">All</option>
                  <option value="false">Active Only</option>
                  <option value="true">Archived Only</option>
                </select>
              </div>

              {/* Fork Filter */}
              <div>
                <label class="block text-xs text-neutral-600 mb-1">Forks</label>
                <select
                  value={props.filters.isFork === null ? '' : props.filters.isFork.toString()}
                  onChange={(e) => {
                    const value = e.currentTarget.value;
                    props.onFiltersChange({
                      isFork: value === '' ? null : value === 'true'
                    });
                  }}
                  class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
                >
                  <option value="">All</option>
                  <option value="false">Original Only</option>
                  <option value="true">Forks Only</option>
                </select>
              </div>

              {/* Topics Filter */}
              <div>
                <label class="block text-xs text-neutral-600 mb-1">Topics</label>
                <select
                  value={props.filters.hasTopics === null ? '' : props.filters.hasTopics.toString()}
                  onChange={(e) => {
                    const value = e.currentTarget.value;
                    props.onFiltersChange({
                      hasTopics: value === '' ? null : value === 'true'
                    });
                  }}
                  class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
                >
                  <option value="">All</option>
                  <option value="true">With Topics</option>
                  <option value="false">Without Topics</option>
                </select>
              </div>

              {/* License Filter */}
              <div>
                <label class="block text-xs text-neutral-600 mb-1">License</label>
                <select
                  value={props.filters.hasLicense === null ? '' : props.filters.hasLicense.toString()}
                  onChange={(e) => {
                    const value = e.currentTarget.value;
                    props.onFiltersChange({
                      hasLicense: value === '' ? null : value === 'true'
                    });
                  }}
                  class="w-full bg-neutral-900 border border-neutral-700 focus:border-cyan-400 rounded px-3 py-2 text-sm text-neutral-300 focus:outline-none"
                >
                  <option value="">All</option>
                  <option value="true">With License</option>
                  <option value="false">Without License</option>
                </select>
              </div>
            </div>
          </div>

          {/* Advanced Search Tips */}
          <div class="mt-6 p-3 bg-neutral-900/30 rounded border border-neutral-800">
            <div class="text-xs text-neutral-500 font-mono uppercase mb-2">Search Tips</div>
            <div class="text-xs text-neutral-600 space-y-1">
              <div>• Search terms match name, description, and topics</div>
              <div>• Use quotes for exact phrases: "react component"</div>
              <div>• Combine filters for precise results</div>
              <div>• Sort by stars to find popular projects</div>
            </div>
          </div>
        </div>
      </Show>

      {/* Active Filters Summary */}
      <Show when={activeFilterCount() > 0}>
        <div class="mt-4 pt-4 border-t border-neutral-800">
          <div class="text-xs text-neutral-500 font-mono uppercase mb-2">Active Filters</div>
          <div class="flex flex-wrap gap-2">
            <Show when={props.filters.search}>
              <span class="px-2 py-1 bg-cyan-900/30 text-cyan-400 border border-cyan-800 rounded text-xs font-mono">
                Search: "{props.filters.search}"
              </span>
            </Show>

            <Show when={props.filters.language}>
              <span class="px-2 py-1 bg-green-900/30 text-green-400 border border-green-800 rounded text-xs font-mono">
                Language: {props.filters.language}
              </span>
            </Show>

            <Show when={props.filters.minStars > 0 || props.filters.maxStars < 10000}>
              <span class="px-2 py-1 bg-yellow-900/30 text-yellow-400 border border-yellow-800 rounded text-xs font-mono">
                Stars: {props.filters.minStars}-{props.filters.maxStars}
              </span>
            </Show>

            <Show when={props.filters.isArchived !== null}>
              <span class="px-2 py-1 bg-purple-900/30 text-purple-400 border border-purple-800 rounded text-xs font-mono">
                {props.filters.isArchived ? 'Archived' : 'Active'}
              </span>
            </Show>
          </div>
        </div>
      </Show>
    </Card>
  );
};
</file>

<file path="src/components/GitHub/ProjectGrid.tsx">
/*
 * Repository grid component providing organized display of GitHub projects with sophisticated filtering and interactive exploration capabilities.
 * I'm implementing comprehensive project visualization with pagination, search, filtering, and detailed project cards that maintain the dark aesthetic while showcasing technical projects effectively.
 */

import { Component, createSignal, Show, For, onMount, createEffect } from 'solid-js';
import { ProjectCard } from './ProjectCard';
import { ProjectDetail } from './ProjectDetail';
import { ProjectFilters } from './ProjectFilters';
import { LoadingSpinner } from '../UI/LoadingSpinner';
import { useGitHub } from '../../hooks/useGitHub';

interface ProjectGridProps {
  className?: string;
}

export const ProjectGrid: Component<ProjectGridProps> = (props) => {
  const github = useGitHub();
  const [selectedRepository, setSelectedRepository] = createSignal(null);
  const [viewMode, setViewMode] = createSignal<'grid' | 'list'>('grid');
  const [isFiltersExpanded, setIsFiltersExpanded] = createSignal(false);

  // I'm setting up the initial data fetch when the component mounts
  onMount(() => {
    github.refreshRepositories();
  });

  // I'm handling repository selection for detailed view
  const handleRepositorySelect = async (repository: any) => {
    const details = await github.getRepositoryDetails(repository.owner, repository.name);
    setSelectedRepository(details);
  };

  // I'm creating filter change handler
  const handleFiltersChange = (newFilters: any) => {
    github.setFilters(newFilters);
  };

  // I'm getting unique languages for filter options
  const availableLanguages = () => {
    const languages = new Set<string>();
    github.allRepositories().forEach(repo => {
      if (repo.language) {
        languages.add(repo.language);
      }
    });
    return Array.from(languages).sort();
  };

  return (
    <div class={`space-y-6 ${props.className || ''}`}>
      {/* Filters */}
      <ProjectFilters
        filters={github.filters()}
        onFiltersChange={handleFiltersChange}
        languages={availableLanguages()}
        totalCount={github.allRepositories().length}
        filteredCount={github.repositories().length}
        isLoading={github.isLoading()}
      />

      {/* View Controls */}
      <div class="flex items-center justify-between">
        <div class="flex items-center gap-4">
          <h2 class="text-2xl font-mono text-neutral-200">
            REPOSITORIES
          </h2>
          <div class="text-sm text-neutral-500 font-mono">
            {github.repositories().length} / {github.totalCount()}
          </div>
        </div>

        <div class="flex items-center gap-3">
          {/* View Mode Toggle */}
          <div class="flex items-center bg-neutral-900 rounded border border-neutral-700">
            <button
              onClick={() => setViewMode('grid')}
              class={`p-2 text-sm transition-colors duration-200 ${
                viewMode() === 'grid'
                  ? 'bg-neutral-700 text-neutral-100'
                  : 'text-neutral-500 hover:text-neutral-300'
              }`}
              title="Grid view"
            >
              <div class="w-4 h-4 grid grid-cols-2 gap-0.5">
                <div class="bg-current rounded-sm"></div>
                <div class="bg-current rounded-sm"></div>
                <div class="bg-current rounded-sm"></div>
                <div class="bg-current rounded-sm"></div>
              </div>
            </button>
            <button
              onClick={() => setViewMode('list')}
              class={`p-2 text-sm transition-colors duration-200 ${
                viewMode() === 'list'
                  ? 'bg-neutral-700 text-neutral-100'
                  : 'text-neutral-500 hover:text-neutral-300'
              }`}
              title="List view"
            >
              <div class="w-4 h-4 flex flex-col gap-1">
                <div class="h-0.5 bg-current rounded-sm"></div>
                <div class="h-0.5 bg-current rounded-sm"></div>
                <div class="h-0.5 bg-current rounded-sm"></div>
              </div>
            </button>
          </div>

          {/* Refresh Button */}
          <button
            onClick={() => github.refreshRepositories()}
            disabled={github.isLoading()}
            class="px-4 py-2 bg-neutral-800 hover:bg-neutral-700 disabled:opacity-50 text-neutral-300 rounded font-mono text-sm transition-colors duration-200"
          >
            {github.isLoading() ? 'REFRESHING...' : 'REFRESH'}
          </button>
        </div>
      </div>

      {/* Loading State */}
      <Show when={github.isLoading()}>
        <div class="flex justify-center py-12">
          <LoadingSpinner
            variant="fractal"
            size="lg"
            message="Loading repositories..."
          />
        </div>
      </Show>

      {/* Error State */}
      <Show when={github.error() && !github.isLoading()}>
        <div class="bg-red-900/20 border border-red-800 rounded-lg p-8 text-center">
          <div class="text-red-400 text-lg font-mono mb-2">FETCH ERROR</div>
          <div class="text-neutral-300 mb-4">{github.error()}</div>
          <button
            onClick={() => github.refreshRepositories()}
            class="px-6 py-2 bg-red-600 hover:bg-red-700 text-white rounded font-mono text-sm transition-colors duration-200"
          >
            RETRY
          </button>
        </div>
      </Show>

      {/* Empty State */}
      <Show when={!github.isLoading() && !github.error() && github.repositories().length === 0}>
        <div class="text-center py-20">
          <div class="text-6xl mb-6 opacity-20">📁</div>
          <div class="text-xl font-thin text-neutral-300 mb-4">
            No repositories found
          </div>
          <div class="text-neutral-500 max-w-md mx-auto">
            {github.allRepositories().length > 0
              ? 'Try adjusting your filters to see more results.'
              : 'No repositories are available at this time.'}
          </div>
          <Show when={github.allRepositories().length > 0}>
            <button
              onClick={() => github.clearFilters()}
              class="mt-6 px-6 py-2 bg-neutral-800 hover:bg-neutral-700 text-neutral-300 rounded font-mono text-sm transition-colors duration-200"
            >
              CLEAR FILTERS
            </button>
          </Show>
        </div>
      </Show>

      {/* Repository Grid/List */}
      <Show when={!github.isLoading() && !github.error() && github.repositories().length > 0}>
        <div class={
          viewMode() === 'grid'
            ? 'grid md:grid-cols-2 lg:grid-cols-3 gap-6'
            : 'space-y-4'
        }>
          <For each={github.repositories()}>
            {(repository) => (
              <ProjectCard
                repository={repository}
                viewMode={viewMode()}
                onClick={handleRepositorySelect}
              />
            )}
          </For>
        </div>

        {/* Pagination */}
        <Show when={github.totalPages() > 1}>
          <div class="flex items-center justify-center gap-4 pt-8">
            <button
              onClick={() => github.goToPage(github.currentPage() - 1)}
              disabled={!github.hasPreviousPage()}
              class="px-4 py-2 bg-neutral-800 hover:bg-neutral-700 disabled:opacity-50 disabled:cursor-not-allowed text-neutral-300 rounded font-mono text-sm transition-colors duration-200"
            >
              PREV
            </button>

            <div class="flex items-center gap-2">
              {Array.from({ length: Math.min(5, github.totalPages()) }, (_, i) => {
                const pageNum = github.currentPage() - 2 + i;
                if (pageNum < 1 || pageNum > github.totalPages()) return null;

                return (
                  <button
                    onClick={() => github.goToPage(pageNum)}
                    class={`w-10 h-10 rounded font-mono text-sm transition-colors duration-200 ${
                      pageNum === github.currentPage()
                        ? 'bg-cyan-600 text-white'
                        : 'bg-neutral-800 text-neutral-300 hover:bg-neutral-700'
                    }`}
                  >
                    {pageNum}
                  </button>
                );
              })}
            </div>

            <button
              onClick={() => github.goToPage(github.currentPage() + 1)}
              disabled={!github.hasNextPage()}
              class="px-4 py-2 bg-neutral-800 hover:bg-neutral-700 disabled:opacity-50 disabled:cursor-not-allowed text-neutral-300 rounded font-mono text-sm transition-colors duration-200"
            >
              NEXT
            </button>
          </div>

          <div class="text-center text-xs text-neutral-500 font-mono">
            Page {github.currentPage()} of {github.totalPages()} • {github.totalCount()} total repositories
          </div>
        </Show>
      </Show>

      {/* Rate Limit Warning */}
      <Show when={github.rateLimit()?.status === 'warning' || github.rateLimit()?.status === 'critical'}>
        <div class="fixed bottom-4 right-4 bg-yellow-900/90 border border-yellow-700 rounded-lg p-4 max-w-sm backdrop-blur-sm">
          <div class="text-yellow-400 font-mono text-sm mb-2">
            API RATE LIMIT {github.rateLimit()?.status.toUpperCase()}
          </div>
          <div class="text-neutral-300 text-xs">
            {github.rateLimit()?.remaining} / {github.rateLimit()?.limit} requests remaining
          </div>
          <div class="text-neutral-400 text-xs mt-1">
            Resets in {Math.ceil((new Date(github.rateLimit()?.resetTime || 0).getTime() - Date.now()) / (1000 * 60))} minutes
          </div>
        </div>
      </Show>

      {/* Repository Detail Modal */}
      <Show when={selectedRepository()}>
        <ProjectDetail
          repository={selectedRepository()!}
          onClose={() => setSelectedRepository(null)}
        />
      </Show>
    </div>
  );
};
</file>

<file path="src/components/Layout/Footer.tsx">
/*
 * Footer component providing technical information and philosophical reflection in the dark aesthetic.
 * I'm creating a minimal, contemplative footer that reinforces the eerie atmosphere while sharing technical insights and project context.
 */

import { Component, createSignal, onMount } from 'solid-js';

interface TechStat {
  label: string;
  value: string;
  description: string;
}

interface BuildInfo {
  version: string;
  buildTime: string;
  gitCommit: string;
  rustVersion: string;
}

export const Footer: Component = () => {
  const [buildInfo, setBuildInfo] = createSignal<BuildInfo | null>(null);
  const [systemMetrics, setSystemMetrics] = createSignal<any>(null);
  const [currentTime, setCurrentTime] = createSignal(new Date());

  // I'm creating technical statistics that showcase the system capabilities
  const technicalStats = (): TechStat[] => [
    {
      label: "Runtime",
      value: "Rust + Tokio",
      description: "Async runtime for maximum concurrency"
    },
    {
      label: "Frontend",
      value: "SolidJS + TypeScript",
      description: "Fine-grained reactive UI framework"
    },
    {
      label: "Mathematics",
      value: "IEEE 754 Double",
      description: "64-bit floating point precision"
    },
    {
      label: "Parallelism",
      value: "Rayon + SIMD",
      description: "Multi-threaded computation engine"
    }
  ];

  onMount(() => {
    // I'm fetching build and system information for display
    fetchBuildInfo();
    fetchSystemMetrics();

    // Update current time every second for the system clock
    const timeInterval = setInterval(() => {
      setCurrentTime(new Date());
    }, 1000);

    // Refresh system metrics periodically
    const metricsInterval = setInterval(fetchSystemMetrics, 30000);

    return () => {
      clearInterval(timeInterval);
      clearInterval(metricsInterval);
    };
  });

  const fetchBuildInfo = async () => {
    try {
      const response = await fetch('/api/health');
      if (response.ok) {
        const data = await response.json();
        setBuildInfo(data.version);
      }
    } catch (error) {
      console.warn('Failed to fetch build info:', error);
    }
  };

  const fetchSystemMetrics = async () => {
    try {
      const response = await fetch('/api/performance/system');
      if (response.ok) {
        const data = await response.json();
        setSystemMetrics(data);
      }
    } catch (error) {
      console.warn('Failed to fetch system metrics:', error);
    }
  };

  const formatUptime = (seconds: number): string => {
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    
    if (days > 0) return `${days}d ${hours}h`;
    if (hours > 0) return `${hours}h ${minutes}m`;
    return `${minutes}m`;
  };

  return (
    <footer class="bg-black border-t border-neutral-900 mt-auto">
      <div class="container mx-auto px-6 py-12">
        {/* Main Footer Content */}
        <div class="grid md:grid-cols-3 gap-12 mb-12">
          {/* Philosophical Statement */}
          <div class="space-y-4">
            <h3 class="text-lg font-thin text-neutral-200 tracking-wide">
              ON PRECISION
            </h3>
            <p class="text-sm text-neutral-500 leading-relaxed">
              Every algorithm is a meditation on the nature of determinism. 
              In the space between input and output lies the entire mystery 
              of computation—and perhaps existence itself.
            </p>
            <p class="text-xs text-neutral-600 leading-relaxed">
              This showcase explores the intersection of mathematical precision 
              and existential uncertainty through high-performance computation.
            </p>
          </div>

          {/* Technical Specifications */}
          <div class="space-y-4">
            <h3 class="text-lg font-thin text-neutral-200 tracking-wide">
              TECHNICAL STACK
            </h3>
            <div class="space-y-3">
              {technicalStats().map((stat) => (
                <div class="group cursor-help">
                  <div class="flex justify-between items-start">
                    <span class="text-xs text-neutral-600 tracking-wide">
                      {stat.label}
                    </span>
                    <span class="text-xs text-neutral-400 font-mono">
                      {stat.value}
                    </span>
                  </div>
                  <div class="text-xs text-neutral-700 mt-1 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                    {stat.description}
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* System Status */}
          <div class="space-y-4">
            <h3 class="text-lg font-thin text-neutral-200 tracking-wide">
              SYSTEM STATUS
            </h3>
            <div class="space-y-3">
              <div class="flex justify-between items-center">
                <span class="text-xs text-neutral-600 tracking-wide">
                  LOCAL TIME
                </span>
                <span class="text-xs text-neutral-400 font-mono">
                  {currentTime().toLocaleTimeString('en-US', { 
                    hour12: false,
                    timeZoneName: 'short'
                  })}
                </span>
              </div>

              {systemMetrics() && (
                <>
                  <div class="flex justify-between items-center">
                    <span class="text-xs text-neutral-600 tracking-wide">
                      UPTIME
                    </span>
                    <span class="text-xs text-neutral-400 font-mono">
                      {formatUptime(systemMetrics().uptime_seconds || 0)}
                    </span>
                  </div>

                  <div class="flex justify-between items-center">
                    <span class="text-xs text-neutral-600 tracking-wide">
                      CPU USAGE
                    </span>
                    <span class="text-xs text-neutral-400 font-mono">
                      {systemMetrics().cpu_usage_percent?.toFixed(1)}%
                    </span>
                  </div>

                  <div class="flex justify-between items-center">
                    <span class="text-xs text-neutral-600 tracking-wide">
                      MEMORY
                    </span>
                    <span class="text-xs text-neutral-400 font-mono">
                      {systemMetrics().memory_usage_percent?.toFixed(1)}%
                    </span>
                  </div>
                </>
              )}

              {buildInfo() && (
                <div class="pt-3 border-t border-neutral-800">
                  <div class="flex justify-between items-center">
                    <span class="text-xs text-neutral-600 tracking-wide">
                      VERSION
                    </span>
                    <span class="text-xs text-neutral-400 font-mono">
                      {buildInfo()!.version}
                    </span>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Performance Metrics Bar */}
        {systemMetrics() && (
          <div class="mb-8 p-4 bg-neutral-900/30 border border-neutral-800 rounded-sm">
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
              <div>
                <div class="text-xs text-neutral-600 mb-1">THREADS</div>
                <div class="text-sm text-neutral-300 font-mono">
                  {systemMetrics().cpu_threads || 'N/A'}
                </div>
              </div>
              <div>
                <div class="text-xs text-neutral-600 mb-1">CORES</div>
                <div class="text-sm text-neutral-300 font-mono">
                  {systemMetrics().cpu_cores || 'N/A'}
                </div>
              </div>
              <div>
                <div class="text-xs text-neutral-600 mb-1">MEMORY</div>
                <div class="text-sm text-neutral-300 font-mono">
                  {systemMetrics().memory_total_gb ? `${systemMetrics().memory_total_gb}GB` : 'N/A'}
                </div>
              </div>
              <div>
                <div class="text-xs text-neutral-600 mb-1">LOAD AVG</div>
                <div class="text-sm text-neutral-300 font-mono">
                  {systemMetrics().load_average_1m?.toFixed(2) || 'N/A'}
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Bottom Bar */}
        <div class="flex flex-col md:flex-row justify-between items-center pt-8 border-t border-neutral-900">
          {/* Build Information */}
          <div class="flex flex-col md:flex-row items-center gap-4 text-xs text-neutral-600">
            {buildInfo() && (
              <>
                <span class="font-mono">
                  Built: {new Date(buildInfo()!.buildTime).toLocaleDateString()}
                </span>
                <span class="hidden md:block text-neutral-800">•</span>
                <span class="font-mono">
                  Commit: {buildInfo()!.gitCommit.substring(0, 7)}
                </span>
                <span class="hidden md:block text-neutral-800">•</span>
                <span class="font-mono">
                  Rust: {buildInfo()!.rustVersion}
                </span>
              </>
            )}
          </div>

          {/* Existential Statement */}
          <div class="mt-4 md:mt-0 text-xs text-neutral-700 italic">
            "In the precision of code, we glimpse the imprecision of everything else."
          </div>
        </div>

        {/* Subtle Corner Indicators */}
        <div class="absolute bottom-0 left-0 w-16 h-16 border-l border-b border-neutral-900 opacity-20"></div>
        <div class="absolute bottom-0 right-0 w-16 h-16 border-r border-b border-neutral-900 opacity-20"></div>
      </div>

      {/* Ambient Status Bar */}
      <div class="h-px bg-gradient-to-r from-transparent via-neutral-800 to-transparent"></div>
    </footer>
  );
};
</file>

<file path="src/components/Layout/Header.tsx">
/*
 * Main navigation header component embodying the dark, minimal aesthetic with sophisticated interactions.
 * I'm implementing a clean, contemplative navigation experience that maintains the eerie atmosphere while providing intuitive functionality.
 */

import { Component, createSignal, createEffect, onMount } from 'solid-js';
import { A, useLocation } from '@solidjs/router';

interface NavItem {
  path: string;
  label: string;
  description: string;
}

export const Header: Component = () => {
  const location = useLocation();
  const [isScrolled, setIsScrolled] = createSignal(false);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = createSignal(false);
  const [systemStatus, setSystemStatus] = createSignal<'healthy' | 'degraded' | 'unhealthy'>('healthy');

  // I'm defining the navigation structure with philosophical undertones
  const navItems: NavItem[] = [
    {
      path: '/',
      label: 'HOME',
      description: 'Return to the beginning'
    },
    {
      path: '/projects',
      label: 'REPOSITORIES',
      description: 'Explore the digital artifacts'
    },
    {
      path: '/performance',
      label: 'METRICS',
      description: 'Witness computational precision'
    },
    {
      path: '/about',
      label: 'ARCHITECTURE',
      description: 'Understand the foundation'
    }
  ];

  onMount(() => {
    // I'm implementing scroll detection for dynamic header behavior
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 20);
    };

    window.addEventListener('scroll', handleScroll, { passive: true });

    // Fetch system status for the status indicator
    fetchSystemStatus();
    const statusInterval = setInterval(fetchSystemStatus, 30000); // Update every 30 seconds

    return () => {
      window.removeEventListener('scroll', handleScroll);
      clearInterval(statusInterval);
    };
  });

  const fetchSystemStatus = async () => {
    try {
      const response = await fetch('/api/health');
      if (response.ok) {
        const data = await response.json();
        setSystemStatus(data.status === 'Healthy' ? 'healthy' :
                      data.status === 'Degraded' ? 'degraded' : 'unhealthy');
      }
    } catch (error) {
      setSystemStatus('unhealthy');
    }
  };

  const isActiveRoute = (path: string): boolean => {
    if (path === '/') {
      return location.pathname === '/';
    }
    return location.pathname.startsWith(path);
  };

  const getStatusColor = () => {
    switch (systemStatus()) {
      case 'healthy': return 'bg-green-500';
      case 'degraded': return 'bg-yellow-500';
      case 'unhealthy': return 'bg-red-500';
    }
  };

  const getStatusPulse = () => {
    return systemStatus() !== 'healthy' ? 'animate-pulse' : '';
  };

  return (
    <>
      <header class={`fixed top-0 left-0 right-0 z-50 transition-all duration-500 ${
        isScrolled()
          ? 'bg-black/90 backdrop-blur-md border-b border-neutral-800/50'
          : 'bg-transparent'
      }`}>
        <div class="container mx-auto px-6">
          <div class="flex items-center justify-between h-16">
            {/* Logo/Brand */}
            <A
              href="/"
              class="group flex items-center gap-3 text-neutral-100 hover:text-white transition-colors duration-300"
            >
              <div class="relative">
                <div class={`w-2 h-2 rounded-full ${getStatusColor()} ${getStatusPulse()}`}></div>
                <div class="absolute inset-0 w-2 h-2 rounded-full bg-white/20 animate-ping"></div>
              </div>
              <span class="font-mono text-sm tracking-wider">
                PERFORMANCE.SHOWCASE
              </span>
            </A>

            {/* Desktop Navigation */}
            <nav class="hidden md:flex items-center gap-8">
              {navItems.map((item) => (
                <A
                  href={item.path}
                  class={`group relative font-mono text-xs tracking-wider transition-all duration-300 ${
                    isActiveRoute(item.path)
                      ? 'text-neutral-100'
                      : 'text-neutral-500 hover:text-neutral-300'
                  }`}
                >
                  {item.label}

                  {/* Active indicator */}
                  <div class={`absolute -bottom-1 left-0 h-px bg-neutral-100 transition-all duration-300 ${
                    isActiveRoute(item.path) ? 'w-full' : 'w-0 group-hover:w-full'
                  }`}></div>

                  {/* Hover description */}
                  <div class="absolute top-full left-1/2 transform -translate-x-1/2 mt-2 px-3 py-1 bg-black/90 backdrop-blur-sm border border-neutral-700 rounded text-xs text-neutral-400 whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none">
                    {item.description}
                  </div>
                </A>
              ))}
            </nav>

            {/* System Status & Mobile Menu Button */}
            <div class="flex items-center gap-4">
              {/* System Status Indicator */}
              <div class="hidden lg:flex items-center gap-2 px-3 py-1 bg-neutral-900/50 backdrop-blur-sm border border-neutral-800 rounded-sm">
                <div class={`w-1.5 h-1.5 rounded-full ${getStatusColor()}`}></div>
                <span class="text-xs font-mono text-neutral-400 tracking-wide">
                  {systemStatus().toUpperCase()}
                </span>
              </div>

              {/* Mobile Menu Toggle */}
              <button
                onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen())}
                class="md:hidden p-2 text-neutral-400 hover:text-neutral-100 transition-colors duration-300"
                aria-label="Toggle mobile menu"
              >
                <div class="w-5 h-5 flex flex-col justify-center gap-1">
                  <div class={`h-px bg-current transition-all duration-300 ${
                    isMobileMenuOpen() ? 'rotate-45 translate-y-1' : ''
                  }`}></div>
                  <div class={`h-px bg-current transition-all duration-300 ${
                    isMobileMenuOpen() ? 'opacity-0' : ''
                  }`}></div>
                  <div class={`h-px bg-current transition-all duration-300 ${
                    isMobileMenuOpen() ? '-rotate-45 -translate-y-1' : ''
                  }`}></div>
                </div>
              </button>
            </div>
          </div>
        </div>
      </header>

      {/* Mobile Menu Overlay */}
      <div class={`fixed inset-0 z-40 md:hidden transition-all duration-500 ${
        isMobileMenuOpen()
          ? 'opacity-100 pointer-events-auto'
          : 'opacity-0 pointer-events-none'
      }`}>
        {/* Backdrop */}
        <div
          class="absolute inset-0 bg-black/80 backdrop-blur-sm"
          onClick={() => setIsMobileMenuOpen(false)}
        ></div>

        {/* Menu Content */}
        <div class={`absolute top-16 left-0 right-0 bg-black/95 backdrop-blur-md border-b border-neutral-800 transition-all duration-500 ${
          isMobileMenuOpen() ? 'translate-y-0' : '-translate-y-full'
        }`}>
          <nav class="container mx-auto px-6 py-8">
            <div class="space-y-6">
              {navItems.map((item) => (
                <A
                  href={item.path}
                  onClick={() => setIsMobileMenuOpen(false)}
                  class={`block group transition-all duration-300 ${
                    isActiveRoute(item.path)
                      ? 'text-neutral-100'
                      : 'text-neutral-400 hover:text-neutral-200'
                  }`}
                >
                  <div class="flex items-center justify-between py-2">
                    <div>
                      <div class="font-mono text-sm tracking-wider mb-1">
                        {item.label}
                      </div>
                      <div class="text-xs text-neutral-600">
                        {item.description}
                      </div>
                    </div>
                    <div class={`w-1 h-6 bg-neutral-100 transition-all duration-300 ${
                      isActiveRoute(item.path) ? 'opacity-100' : 'opacity-0 group-hover:opacity-50'
                    }`}></div>
                  </div>
                </A>
              ))}
            </div>

            {/* Mobile System Status */}
            <div class="mt-8 pt-6 border-t border-neutral-800">
              <div class="flex items-center justify-between">
                <span class="text-xs font-mono text-neutral-500 tracking-wide">
                  SYSTEM STATUS
                </span>
                <div class="flex items-center gap-2">
                  <div class={`w-2 h-2 rounded-full ${getStatusColor()} ${getStatusPulse()}`}></div>
                  <span class="text-xs font-mono text-neutral-400">
                    {systemStatus().toUpperCase()}
                  </span>
                </div>
              </div>
            </div>
          </nav>
        </div>
      </div>
    </>
  );
};
</file>

<file path="src/components/Layout/Layout.tsx">
// src/components/Layout/Layout.tsx (No longer the main layout provider)
import { Component, JSX } from 'solid-js';
import { ErrorBoundary } from '../UI/ErrorBoundary'; // Your custom UI ErrorBoundary
// Removed imports for Header, Footer, performanceMonitor, isServer, etc. as they are in _layout.tsx

// PageLayout variant - this component is now simpler as _layout.tsx handles the shell
export const PageLayout: Component<{
  children: JSX.Element;
  // Title and description should be set by the route component using @solidjs/meta
  maxWidth?: 'sm' | 'md' | 'lg' | 'xl' | 'full';
}> = (props) => {
  const maxWidthClasses = {
    sm: 'max-w-2xl',
    md: 'max-w-4xl',
    lg: 'max-w-6xl',
    xl: 'max-w-7xl',
    full: 'max-w-none'
  };

  return (
    // This div provides padding and max-width *within* the main content area
    // defined by src/routes/_layout.tsx
    <div class={`${maxWidthClasses[props.maxWidth || 'lg']} mx-auto px-6 py-12`}>
      <ErrorBoundary context="PageLayout Content" level="page">
        {props.children}
      </ErrorBoundary>
    </div>
  );
};

// FullscreenLayout variant
export const FullscreenLayout: Component<{
  children: JSX.Element;
  // Title should be set by the route component using @solidjs/meta
}> = (props) => {
  // This layout variant might imply that src/routes/_layout.tsx should *not* render
  // its Header/Footer. This requires more advanced conditional logic in _layout.tsx
  // based on route metadata, or a different _layout file for fullscreen routes.
  // For now, it will just render children directly within the main _layout structure.
  return (
    <div class="w-full h-full"> {/* Occupy full space given by parent */}
       <ErrorBoundary context="FullscreenLayout Content" level="page">
        {props.children}
      </ErrorBoundary>
    </div>
  );
};

// MinimalLayout variant
export const MinimalLayout: Component<{
  children: JSX.Element;
  // Title should be set by the route component using @solidjs/meta
}> = (props) => {
  // This component is intended to be used *instead* of the main _layout.tsx
  // for routes that need a completely different shell.
  // This requires route-specific layout configuration in SolidStart.
  // For now, if used, it would still be wrapped by _layout.tsx unless configured otherwise.
  return (
    <div class="min-h-screen bg-black text-neutral-100 flex items-center justify-center p-6">
      <ErrorBoundary context="Minimal Layout" level="page">
        {props.children}
      </ErrorBoundary>
    </div>
  );
};
</file>

<file path="src/components/Performance/BenchmarkChart.tsx">
/*
 * Performance benchmark visualization component that displays comparative analysis of system performance against industry standards.
 * I'm implementing interactive charts, statistical analysis, and benchmark execution with real-time progress tracking using the performance service.
 */

import { Component, createSignal, onMount, Show, For } from 'solid-js';
import { fractalService, BenchmarkResult } from '../../services/fractals';
import { performanceService } from '../../services/performance';

interface BenchmarkComparison {
  label: string;
  current: number;
  baseline: number;
  unit: string;
  better: 'higher' | 'lower';
}

interface BenchmarkCategory {
  name: string;
  description: string;
  results: {
    metric: string;
    value: number;
    unit: string;
    performance_rating: string;
    comparison?: number; // Percentage vs baseline
  }[];
}

export const BenchmarkChart: Component = () => {
  const [benchmarkResults, setBenchmarkResults] = createSignal<BenchmarkResult | null>(null);
  const [systemBenchmark, setSystemBenchmark] = createSignal<any>(null);
  const [isRunning, setIsRunning] = createSignal(false);
  const [progress, setProgress] = createSignal(0);
  const [currentTest, setCurrentTest] = createSignal('');
  const [error, setError] = createSignal<string | null>(null);

  onMount(() => {
    // I'm checking for any existing benchmark results
    loadExistingResults();
  });

  const loadExistingResults = async () => {
    try {
      // I'm attempting to load cached benchmark results if available
      const cached = localStorage.getItem('benchmark_results');
      if (cached) {
        const parsed = JSON.parse(cached);
        if (Date.now() - parsed.timestamp < 3600000) { // 1 hour cache
          setBenchmarkResults(parsed.data);
        }
      }
    } catch (err) {
      console.warn('Failed to load cached benchmark results:', err);
    }
  };

  const runFractalBenchmark = async () => {
    setIsRunning(true);
    setProgress(0);
    setCurrentTest('Initializing fractal benchmark suite...');
    setError(null);

    try {
      // I'm simulating progress updates for better UX
      const progressInterval = setInterval(() => {
        setProgress(prev => Math.min(prev + Math.random() * 15, 90));
      }, 500);

      setCurrentTest('Running fractal computation tests...');
      const results = await fractalService.runBenchmark();

      clearInterval(progressInterval);
      setProgress(100);
      setCurrentTest('Benchmark completed!');

      // I'm caching the results
      localStorage.setItem('benchmark_results', JSON.stringify({
        data: results,
        timestamp: Date.now()
      }));

      setBenchmarkResults(results);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Benchmark failed');
    } finally {
      setIsRunning(false);
      setTimeout(() => {
        setProgress(0);
        setCurrentTest('');
      }, 2000);
    }
  };

  const runSystemBenchmark = async () => {
    setIsRunning(true);
    setProgress(0);
    setCurrentTest('Running system performance benchmark...');
    setError(null);

    try {
      const progressInterval = setInterval(() => {
        setProgress(prev => Math.min(prev + Math.random() * 10, 85));
      }, 800);

      const results = await performanceService.runBenchmark();

      clearInterval(progressInterval);
      setProgress(100);
      setCurrentTest('System benchmark completed!');

      setSystemBenchmark(results);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'System benchmark failed');
    } finally {
      setIsRunning(false);
      setTimeout(() => {
        setProgress(0);
        setCurrentTest('');
      }, 2000);
    }
  };

  const getBenchmarkCategories = (): BenchmarkCategory[] => {
    const results = benchmarkResults();
    if (!results) return [];

    return [
      {
        name: 'Mandelbrot Generation',
        description: 'Mathematical computation performance',
        results: results.benchmark_results.map(result => ({
          metric: result.resolution,
          value: result.mandelbrot.computation_time_ms,
          unit: 'ms',
          performance_rating: result.mandelbrot.performance_rating,
          comparison: calculateComparison(result.mandelbrot.pixels_per_ms, getBaselinePixelsPerMs(result.resolution))
        }))
      },
      {
        name: 'Julia Set Generation',
        description: 'Complex number computation performance',
        results: results.benchmark_results.map(result => ({
          metric: result.resolution,
          value: result.julia.computation_time_ms,
          unit: 'ms',
          performance_rating: result.julia.performance_rating,
          comparison: calculateComparison(result.julia.pixels_per_ms, getBaselinePixelsPerMs(result.resolution))
        }))
      }
    ];
  };

  const getSystemComparisons = (): BenchmarkComparison[] => {
    const system = systemBenchmark();
    if (!system) return [];

    return [
      {
        label: 'CPU Performance',
        current: system.benchmarks?.cpu?.multi_thread?.primes_per_second || 0,
        baseline: 5000, // Baseline primes per second
        unit: 'primes/sec',
        better: 'higher'
      },
      {
        label: 'Memory Bandwidth',
        current: system.benchmarks?.memory?.sequential_read?.mb_per_second || 0,
        baseline: 10000, // Baseline MB/s
        unit: 'MB/s',
        better: 'higher'
      },
      {
        label: 'Memory Allocation',
        current: system.benchmarks?.memory?.allocation?.mb_per_second || 0,
        baseline: 5000, // Baseline allocation speed
        unit: 'MB/s',
        better: 'higher'
      }
    ];
  };

  const calculateComparison = (current: number, baseline: number): number => {
    if (baseline === 0) return 0;
    return ((current - baseline) / baseline) * 100;
  };

  const getBaselinePixelsPerMs = (resolution: string): number => {
    // I'm providing baseline performance expectations for different resolutions
    const baselines: Record<string, number> = {
      '256x256': 100,
      '512x512': 80,
      '1024x1024': 60,
      '2048x2048': 40
    };
    return baselines[resolution] || 50;
  };

  const getPerformanceColor = (rating: string) => {
    switch (rating.toLowerCase()) {
      case 'exceptional': return 'text-green-400';
      case 'excellent': return 'text-blue-400';
      case 'very good': return 'text-cyan-400';
      case 'good': return 'text-yellow-400';
      case 'fair': return 'text-orange-400';
      default: return 'text-red-400';
    }
  };

  const getComparisonColor = (comparison: number) => {
    if (comparison > 20) return 'text-green-400';
    if (comparison > 0) return 'text-blue-400';
    if (comparison > -20) return 'text-yellow-400';
    return 'text-red-400';
  };

  return (
    <div class="space-y-6">
      {/* Header */}
      <div class="text-center mb-8">
        <h2 class="text-3xl font-thin text-neutral-200 mb-4">
          PERFORMANCE BENCHMARKS
        </h2>
        <p class="text-neutral-500 max-w-2xl mx-auto">
          Comprehensive performance testing demonstrating computational efficiency across
          mathematical operations, system resources, and parallel processing capabilities.
        </p>
      </div>

      {/* Benchmark Controls */}
      <div class="grid md:grid-cols-2 gap-4 mb-8">
        <button
          onClick={runFractalBenchmark}
          disabled={isRunning()}
          class={`p-6 rounded-lg border text-left transition-all duration-300 ${
            isRunning()
              ? 'bg-neutral-800/50 border-neutral-700 text-neutral-500 cursor-not-allowed'
              : 'bg-neutral-900/30 border-neutral-800 hover:border-neutral-600 text-neutral-100'
          }`}
        >
          <div class="text-lg font-mono mb-2">FRACTAL COMPUTATION</div>
          <div class="text-sm text-neutral-400 mb-3">
            Test mathematical computation performance with parallel processing
          </div>
          <div class="text-xs text-neutral-600">
            Mandelbrot & Julia set generation across multiple resolutions
          </div>
        </button>

        <button
          onClick={runSystemBenchmark}
          disabled={isRunning()}
          class={`p-6 rounded-lg border text-left transition-all duration-300 ${
            isRunning()
              ? 'bg-neutral-800/50 border-neutral-700 text-neutral-500 cursor-not-allowed'
              : 'bg-neutral-900/30 border-neutral-800 hover:border-neutral-600 text-neutral-100'
          }`}
        >
          <div class="text-lg font-mono mb-2">SYSTEM PERFORMANCE</div>
          <div class="text-sm text-neutral-400 mb-3">
            Test CPU, memory, and I/O performance characteristics
          </div>
          <div class="text-xs text-neutral-600">
            Prime calculation, memory bandwidth, and allocation speed
          </div>
        </button>
      </div>

      {/* Progress indicator */}
      <Show when={isRunning()}>
        <div class="bg-neutral-900/50 border border-neutral-800 rounded-lg p-6">
          <div class="flex items-center justify-between mb-3">
            <div class="text-neutral-300 font-mono text-sm">{currentTest()}</div>
            <div class="text-neutral-500 font-mono text-sm">{progress().toFixed(0)}%</div>
          </div>
          <div class="w-full bg-neutral-800 rounded-full h-2">
            <div
              class="bg-gradient-to-r from-blue-500 to-cyan-500 h-2 rounded-full transition-all duration-500"
              style={{ width: `${progress()}%` }}
            ></div>
          </div>
        </div>
      </Show>

      {/* Error display */}
      <Show when={error()}>
        <div class="bg-red-900/20 border border-red-800 rounded-lg p-4">
          <div class="text-red-400 font-mono text-sm mb-2">BENCHMARK ERROR</div>
          <div class="text-neutral-300 text-sm">{error()}</div>
        </div>
      </Show>

      {/* Fractal Benchmark Results */}
      <Show when={benchmarkResults()}>
        <div class="space-y-6">
          <h3 class="text-xl font-mono text-neutral-300">FRACTAL COMPUTATION RESULTS</h3>

          <For each={getBenchmarkCategories()}>
            {(category) => (
              <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                <div class="mb-4">
                  <h4 class="text-lg font-mono text-neutral-300 mb-1">{category.name}</h4>
                  <p class="text-sm text-neutral-500">{category.description}</p>
                </div>

                <div class="grid md:grid-cols-2 lg:grid-cols-4 gap-4">
                  <For each={category.results}>
                    {(result) => (
                      <div class="bg-neutral-800/30 border border-neutral-700 rounded-sm p-4">
                        <div class="text-neutral-400 text-xs mb-1">{result.metric}</div>
                        <div class="text-xl font-mono text-neutral-100 mb-1">
                          {result.value.toLocaleString()}<span class="text-sm text-neutral-500 ml-1">{result.unit}</span>
                        </div>
                        <div class={`text-xs mb-2 ${getPerformanceColor(result.performance_rating)}`}>
                          {result.performance_rating}
                        </div>
                        <Show when={result.comparison !== undefined}>
                          <div class={`text-xs ${getComparisonColor(result.comparison!)}`}>
                            {result.comparison! > 0 ? '+' : ''}{result.comparison!.toFixed(1)}% vs baseline
                          </div>
                        </Show>
                      </div>
                    )}
                  </For>
                </div>
              </div>
            )}
          </For>

          {/* System Context */}
          <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
            <h4 class="text-lg font-mono text-neutral-300 mb-4">SYSTEM CONTEXT</h4>
            <div class="grid md:grid-cols-3 gap-6 text-sm">
              <div>
                <div class="text-neutral-500 mb-1">PROCESSOR</div>
                <div class="text-neutral-300 font-mono">
                  {benchmarkResults()!.system_context.cpu_model}
                </div>
                <div class="text-neutral-600 text-xs">
                  {benchmarkResults()!.system_context.cpu_cores} cores
                </div>
              </div>
              <div>
                <div class="text-neutral-500 mb-1">MEMORY</div>
                <div class="text-neutral-300 font-mono">
                  {benchmarkResults()!.system_context.memory_total_gb} GB
                </div>
                <div class="text-neutral-600 text-xs">Total system memory</div>
              </div>
              <div>
                <div class="text-neutral-500 mb-1">OPTIMIZATION</div>
                <div class="text-neutral-300 font-mono">
                  {benchmarkResults()!.performance_analysis.optimization_level}
                </div>
                <div class="text-neutral-600 text-xs">
                  {benchmarkResults()!.performance_analysis.language}
                </div>
              </div>
            </div>
          </div>
        </div>
      </Show>

      {/* System Benchmark Results */}
      <Show when={systemBenchmark()}>
        <div class="space-y-6">
          <h3 class="text-xl font-mono text-neutral-300">SYSTEM PERFORMANCE RESULTS</h3>

          <div class="grid md:grid-cols-3 gap-4">
            <For each={getSystemComparisons()}>
              {(comparison) => (
                <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6 text-center">
                  <div class="text-neutral-400 text-sm mb-2">{comparison.label}</div>
                  <div class="text-2xl font-mono text-neutral-100 mb-1">
                    {comparison.current.toLocaleString()}
                    <span class="text-sm text-neutral-500 ml-1">{comparison.unit}</span>
                  </div>
                  <div class={`text-sm ${getComparisonColor(calculateComparison(comparison.current, comparison.baseline))}`}>
                    {calculateComparison(comparison.current, comparison.baseline) > 0 ? '+' : ''}
                    {calculateComparison(comparison.current, comparison.baseline).toFixed(1)}% vs baseline
                  </div>
                </div>
              )}
            </For>
          </div>

          <div class="text-center p-6 bg-neutral-800/30 rounded-lg">
            <div class="text-neutral-400 text-sm mb-2">OVERALL PERFORMANCE RATING</div>
            <div class={`text-3xl font-mono ${getPerformanceColor(systemBenchmark().performance_rating)}`}>
              {systemBenchmark().performance_rating}
            </div>
          </div>
        </div>
      </Show>

      {/* No results message */}
      <Show when={!benchmarkResults() && !systemBenchmark() && !isRunning()}>
        <div class="text-center py-12">
          <div class="text-6xl mb-4">⚡</div>
          <div class="text-xl text-neutral-400 mb-2">No Benchmark Results</div>
          <div class="text-sm text-neutral-600">
            Run a benchmark to see detailed performance analysis and comparison
          </div>
        </div>
      </Show>
    </div>
  );
};
</file>

<file path="src/components/Performance/MetricsDisplay.tsx">
/*
 * Real-time performance metrics visualization component that displays live system performance data with interactive charts and alerts.
 * I'm implementing comprehensive metrics display with real-time updates, historical trends, and performance analysis using Chart.js and WebSocket integration.
 */

import { Component, createSignal, createEffect, onMount, onCleanup, Show, For } from 'solid-js';
import { performanceService, SystemMetrics } from '../../services/performance';

interface MetricCard {
  id: string;
  label: string;
  value: string;
  unit: string;
  trend: 'up' | 'down' | 'stable';
  status: 'excellent' | 'good' | 'warning' | 'critical';
  description: string;
}

interface ChartDataPoint {
  timestamp: string;
  value: number;
}

export const MetricsDisplay: Component = () => {
  const [metrics, setMetrics] = createSignal<SystemMetrics | null>(null);
  const [isLoading, setIsLoading] = createSignal(true);
  const [error, setError] = createSignal<string | null>(null);
  const [selectedTimeRange, setSelectedTimeRange] = createSignal<'1h' | '6h' | '24h' | '7d'>('1h');
  const [cpuHistory, setCpuHistory] = createSignal<ChartDataPoint[]>([]);
  const [memoryHistory, setMemoryHistory] = createSignal<ChartDataPoint[]>([]);
  const [alerts, setAlerts] = createSignal<any[]>([]);

  let unsubscribe: (() => void) | null = null;
  let metricsInterval: number | null = null;

  onMount(() => {
    initializeMetrics();
  });

  onCleanup(() => {
    if (unsubscribe) unsubscribe();
    if (metricsInterval) clearInterval(metricsInterval);
  });

  const initializeMetrics = async () => {
    try {
      setIsLoading(true);

      // I'm subscribing to real-time metrics updates
      unsubscribe = performanceService.subscribe('metrics', (newMetrics: SystemMetrics) => {
        setMetrics(newMetrics);
        updateHistoricalData(newMetrics);
        setError(null);
      });

      // I'm also subscribing to alerts
      performanceService.subscribe('alert', (alert) => {
        setAlerts(prev => [alert, ...prev.slice(0, 4)]); // Keep last 5 alerts
      });

      // I'm fetching initial metrics
      const initialMetrics = await performanceService.getCurrentMetrics();
      setMetrics(initialMetrics.system);

      // I'm setting up fallback polling in case WebSocket fails
      metricsInterval = setInterval(async () => {
        try {
          const snapshot = await performanceService.getCurrentMetrics();
          setMetrics(snapshot.system);
          updateHistoricalData(snapshot.system);
        } catch (err) {
          console.warn('Failed to fetch metrics:', err);
        }
      }, 5000);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load metrics');
    } finally {
      setIsLoading(false);
    }
  };

  const updateHistoricalData = (newMetrics: SystemMetrics) => {
    const timestamp = new Date().toISOString();

    // I'm maintaining historical data for charting
    setCpuHistory(prev => {
      const updated = [...prev, { timestamp, value: newMetrics.cpu_usage_percent }];
      return updated.slice(-60); // Keep last 60 points (5 minutes at 5s intervals)
    });

    setMemoryHistory(prev => {
      const updated = [...prev, { timestamp, value: newMetrics.memory_usage_percent }];
      return updated.slice(-60);
    });
  };

  const getMetricCards = (): MetricCard[] => {
    if (!metrics()) return [];

    const m = metrics()!;
    return [
      {
        id: 'cpu',
        label: 'CPU Usage',
        value: m.cpu_usage_percent.toFixed(1),
        unit: '%',
        trend: 'stable', // Would calculate from history
        status: m.cpu_usage_percent > 80 ? 'critical' : m.cpu_usage_percent > 60 ? 'warning' : 'good',
        description: `${m.cpu_cores} cores, ${m.cpu_threads} threads`
      },
      {
        id: 'memory',
        label: 'Memory Usage',
        value: m.memory_usage_percent.toFixed(1),
        unit: '%',
        trend: 'stable',
        status: m.memory_usage_percent > 85 ? 'critical' : m.memory_usage_percent > 70 ? 'warning' : 'good',
        description: `${m.memory_available_gb.toFixed(1)}GB available of ${m.memory_total_gb.toFixed(1)}GB`
      },
      {
        id: 'load',
        label: 'Load Average',
        value: m.load_average_1m.toFixed(2),
        unit: '',
        trend: 'stable',
        status: m.load_average_1m > m.cpu_cores * 2 ? 'critical' : m.load_average_1m > m.cpu_cores ? 'warning' : 'good',
        description: '1-minute load average'
      },
      {
        id: 'processes',
        label: 'Active Processes',
        value: m.active_processes.toString(),
        unit: '',
        trend: 'stable',
        status: 'good',
        description: 'Currently running processes'
      }
    ];
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'excellent': return 'text-green-400';
      case 'good': return 'text-blue-400';
      case 'warning': return 'text-yellow-400';
      case 'critical': return 'text-red-400';
      default: return 'text-neutral-400';
    }
  };

  const getStatusBgColor = (status: string) => {
    switch (status) {
      case 'excellent': return 'bg-green-900/20 border-green-800';
      case 'good': return 'bg-blue-900/20 border-blue-800';
      case 'warning': return 'bg-yellow-900/20 border-yellow-800';
      case 'critical': return 'bg-red-900/20 border-red-800';
      default: return 'bg-neutral-900/20 border-neutral-800';
    }
  };

  const formatUptime = (seconds: number): string => {
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (days > 0) return `${days}d ${hours}h ${minutes}m`;
    if (hours > 0) return `${hours}h ${minutes}m`;
    return `${minutes}m`;
  };

  return (
    <div class="space-y-6">
      {/* Header with controls */}
      <div class="flex items-center justify-between">
        <div>
          <h2 class="text-2xl font-thin text-neutral-200 mb-2">
            SYSTEM PERFORMANCE
          </h2>
          <p class="text-neutral-500 text-sm">
            Real-time system metrics and performance analysis
          </p>
        </div>

        <div class="flex items-center gap-2">
          <select
            value={selectedTimeRange()}
            onChange={(e) => setSelectedTimeRange(e.currentTarget.value as any)}
            class="bg-neutral-900 border border-neutral-700 rounded-sm px-3 py-2 text-neutral-100 text-sm font-mono focus:border-neutral-500 focus:outline-none"
          >
            <option value="1h">Last Hour</option>
            <option value="6h">Last 6 Hours</option>
            <option value="24h">Last 24 Hours</option>
            <option value="7d">Last 7 Days</option>
          </select>
        </div>
      </div>

      {/* Loading state */}
      <Show when={isLoading()}>
        <div class="flex items-center justify-center py-12">
          <div class="w-8 h-8 border-2 border-neutral-600 border-t-neutral-300 rounded-full animate-spin"></div>
          <span class="ml-3 text-neutral-400 font-mono text-sm">Loading metrics...</span>
        </div>
      </Show>

      {/* Error state */}
      <Show when={error()}>
        <div class="bg-red-900/20 border border-red-800 rounded-lg p-4">
          <div class="text-red-400 font-mono text-sm mb-2">METRICS ERROR</div>
          <div class="text-neutral-300 text-sm">{error()}</div>
        </div>
      </Show>

      {/* Metrics display */}
      <Show when={!isLoading() && !error() && metrics()}>
        {/* Alert banner */}
        <Show when={alerts().length > 0}>
          <div class="bg-yellow-900/20 border border-yellow-700 rounded-lg p-4">
            <div class="text-yellow-400 font-mono text-sm mb-2">
              ACTIVE ALERTS ({alerts().length})
            </div>
            <div class="space-y-1">
              <For each={alerts().slice(0, 2)}>
                {(alert) => (
                  <div class="text-neutral-300 text-sm flex items-center justify-between">
                    <span>{alert.message}</span>
                    <span class="text-xs px-2 py-1 bg-yellow-800 text-yellow-200 rounded-sm">
                      {alert.severity.toUpperCase()}
                    </span>
                  </div>
                )}
              </For>
            </div>
          </div>
        </Show>

        {/* Main metrics grid */}
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          <For each={getMetricCards()}>
            {(card) => (
              <div class={`rounded-lg p-4 border ${getStatusBgColor(card.status)}`}>
                <div class="flex items-center justify-between mb-2">
                  <div class="text-neutral-400 text-sm font-mono">{card.label}</div>
                  <div class={`text-xs px-2 py-1 rounded-sm ${getStatusColor(card.status)} bg-current/10`}>
                    {card.status.toUpperCase()}
                  </div>
                </div>

                <div class="flex items-baseline gap-2 mb-2">
                  <div class={`text-2xl font-mono ${getStatusColor(card.status)}`}>
                    {card.value}
                  </div>
                  <div class="text-neutral-500 text-sm">{card.unit}</div>
                </div>

                <div class="text-neutral-600 text-xs">
                  {card.description}
                </div>
              </div>
            )}
          </For>
        </div>

        {/* Charts section */}
        <div class="grid md:grid-cols-2 gap-6">
          {/* CPU Usage Chart */}
          <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
            <h3 class="text-lg font-mono text-neutral-300 mb-4">CPU USAGE TREND</h3>
            <div class="h-48 relative">
              <Show when={cpuHistory().length > 1} fallback={
                <div class="flex items-center justify-center h-full text-neutral-600">
                  Collecting data...
                </div>
              }>
                <svg class="w-full h-full" viewBox="0 0 400 200">
                  {/* Grid lines */}
                  <defs>
                    <pattern id="grid" width="40" height="20" patternUnits="userSpaceOnUse">
                      <path d="M 40 0 L 0 0 0 20" fill="none" stroke="#374151" stroke-width="0.5"/>
                    </pattern>
                  </defs>
                  <rect width="100%" height="100%" fill="url(#grid)" opacity="0.3"/>

                  {/* CPU usage line */}
                  <polyline
                    fill="none"
                    stroke="#22d3ee"
                    stroke-width="2"
                    points={cpuHistory().map((point, index) => {
                      const x = (index / (cpuHistory().length - 1)) * 400;
                      const y = 200 - (point.value / 100) * 200;
                      return `${x},${y}`;
                    }).join(' ')}
                  />

                  {/* Current value indicator */}
                  <Show when={cpuHistory().length > 0}>
                    <circle
                      cx="400"
                      cy={200 - (cpuHistory()[cpuHistory().length - 1]?.value / 100) * 200}
                      r="3"
                      fill="#22d3ee"
                    />
                  </Show>
                </svg>

                {/* Y-axis labels */}
                <div class="absolute inset-y-0 -left-8 flex flex-col justify-between text-xs text-neutral-500 font-mono">
                  <span>100%</span>
                  <span>50%</span>
                  <span>0%</span>
                </div>
              </Show>
            </div>
          </div>

          {/* Memory Usage Chart */}
          <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
            <h3 class="text-lg font-mono text-neutral-300 mb-4">MEMORY USAGE TREND</h3>
            <div class="h-48 relative">
              <Show when={memoryHistory().length > 1} fallback={
                <div class="flex items-center justify-center h-full text-neutral-600">
                  Collecting data...
                </div>
              }>
                <svg class="w-full h-full" viewBox="0 0 400 200">
                  <rect width="100%" height="100%" fill="url(#grid)" opacity="0.3"/>

                  <polyline
                    fill="none"
                    stroke="#a855f7"
                    stroke-width="2"
                    points={memoryHistory().map((point, index) => {
                      const x = (index / (memoryHistory().length - 1)) * 400;
                      const y = 200 - (point.value / 100) * 200;
                      return `${x},${y}`;
                    }).join(' ')}
                  />

                  <Show when={memoryHistory().length > 0}>
                    <circle
                      cx="400"
                      cy={200 - (memoryHistory()[memoryHistory().length - 1]?.value / 100) * 200}
                      r="3"
                      fill="#a855f7"
                    />
                  </Show>
                </svg>

                <div class="absolute inset-y-0 -left-8 flex flex-col justify-between text-xs text-neutral-500 font-mono">
                  <span>100%</span>
                  <span>50%</span>
                  <span>0%</span>
                </div>
              </Show>
            </div>
          </div>
        </div>

        {/* System information */}
        <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
          <h3 class="text-lg font-mono text-neutral-300 mb-4">SYSTEM INFORMATION</h3>
          <div class="grid md:grid-cols-3 gap-6 text-sm">
            <div>
              <div class="text-neutral-500 mb-2">PROCESSOR</div>
              <div class="text-neutral-300 font-mono mb-1">{metrics()!.cpu_model}</div>
              <div class="text-neutral-600 text-xs">
                {metrics()!.cpu_cores} cores • {metrics()!.cpu_threads} threads
              </div>
            </div>

            <div>
              <div class="text-neutral-500 mb-2">MEMORY</div>
              <div class="text-neutral-300 font-mono mb-1">
                {metrics()!.memory_total_gb.toFixed(1)} GB Total
              </div>
              <div class="text-neutral-600 text-xs">
                {metrics()!.memory_available_gb.toFixed(1)} GB available
              </div>
            </div>

            <div>
              <div class="text-neutral-500 mb-2">UPTIME</div>
              <div class="text-neutral-300 font-mono mb-1">
                {formatUptime(metrics()!.uptime_seconds)}
              </div>
              <div class="text-neutral-600 text-xs">
                System uptime
              </div>
            </div>
          </div>
        </div>
      </Show>
    </div>
  );
};
</file>

<file path="src/components/Performance/SystemMonitor.tsx">
/*
 * Real-time system monitoring component displaying live metrics with interactive visualizations and alert management for comprehensive performance oversight.
 * I'm implementing sophisticated monitoring dashboards with animated charts, resource utilization tracking, and contextual performance insights that maintain the dark aesthetic while providing critical system visibility.
 */

import { Component, createSignal, onMount, Show, For, createEffect } from 'solid-js';
import { usePerformance } from '../../hooks/usePerformance';
import { Card, MetricCard, StatusCard } from '../UI/Card';
import { LoadingSpinner } from '../UI/LoadingSpinner';

interface ResourceGaugeProps {
  label: string;
  value: number;
  max: number;
  unit: string;
  warning?: number;
  critical?: number;
  color?: string;
}

const ResourceGauge: Component<ResourceGaugeProps> = (props) => {
  const percentage = () => Math.min((props.value / props.max) * 100, 100);
  
  const getColor = () => {
    if (props.critical && props.value >= props.critical) return 'text-red-400 bg-red-400';
    if (props.warning && props.value >= props.warning) return 'text-yellow-400 bg-yellow-400';
    return props.color || 'text-cyan-400 bg-cyan-400';
  };

  const getGradient = () => {
    if (props.critical && props.value >= props.critical) return 'from-red-600 to-red-400';
    if (props.warning && props.value >= props.warning) return 'from-yellow-600 to-yellow-400';
    return 'from-cyan-600 to-cyan-400';
  };

  return (
    <div class="space-y-3">
      <div class="flex justify-between items-baseline">
        <span class="text-sm font-mono text-neutral-400 tracking-wide">
          {props.label}
        </span>
        <div class="text-right">
          <span class={`text-lg font-mono font-semibold ${getColor().split(' ')[0]}`}>
            {props.value.toFixed(1)}
          </span>
          <span class="text-sm text-neutral-500 ml-1">
            {props.unit}
          </span>
        </div>
      </div>
      
      <div class="relative">
        <div class="w-full h-2 bg-neutral-800 rounded-full overflow-hidden">
          <div 
            class={`h-full bg-gradient-to-r ${getGradient()} rounded-full transition-all duration-500 ease-out relative`}
            style={{ width: `${percentage()}%` }}
          >
            <div class="absolute inset-0 bg-white/20 animate-pulse rounded-full"></div>
          </div>
        </div>
        
        {/* Warning and critical thresholds */}
        {props.warning && (
          <div 
            class="absolute top-0 w-0.5 h-2 bg-yellow-400/60"
            style={{ left: `${(props.warning / props.max) * 100}%` }}
          ></div>
        )}
        {props.critical && (
          <div 
            class="absolute top-0 w-0.5 h-2 bg-red-400/60"
            style={{ left: `${(props.critical / props.max) * 100}%` }}
          ></div>
        )}
      </div>
      
      <div class="text-xs text-neutral-600 font-mono">
        {percentage().toFixed(1)}% utilized
      </div>
    </div>
  );
};

const MiniChart: Component<{
  data: Array<{ timestamp: string; value: number }>;
  color?: string;
  height?: number;
}> = (props) => {
  const height = () => props.height || 40;
  const color = () => props.color || '#22d3ee';
  
  const pathData = () => {
    if (props.data.length < 2) return '';
    
    const width = 200;
    const maxValue = Math.max(...props.data.map(d => d.value));
    const minValue = Math.min(...props.data.map(d => d.value));
    const range = maxValue - minValue || 1;
    
    const points = props.data.map((point, index) => {
      const x = (index / (props.data.length - 1)) * width;
      const y = height() - ((point.value - minValue) / range) * height();
      return `${x},${y}`;
    }).join(' ');
    
    return `M ${points.replace(/,/g, ' L ')}`;
  };

  return (
    <div class="relative">
      <svg width="200" height={height()} class="w-full">
        <defs>
          <linearGradient id="chartGradient" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style={`stop-color:${color()};stop-opacity:0.3`} />
            <stop offset="100%" style={`stop-color:${color()};stop-opacity:0.05`} />
          </linearGradient>
        </defs>
        
        {/* Fill area */}
        <path
          d={`${pathData()} L 200,${height()} L 0,${height()} Z`}
          fill="url(#chartGradient)"
        />
        
        {/* Line */}
        <path
          d={pathData()}
          fill="none"
          stroke={color()}
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"
        />
        
        {/* Dots for recent points */}
        {props.data.slice(-3).map((point, index) => {
          const totalIndex = props.data.length - 3 + index;
          const x = (totalIndex / (props.data.length - 1)) * 200;
          const maxValue = Math.max(...props.data.map(d => d.value));
          const minValue = Math.min(...props.data.map(d => d.value));
          const range = maxValue - minValue || 1;
          const y = height() - ((point.value - minValue) / range) * height();
          
          return (
            <circle
              cx={x}
              cy={y}
              r="2"
              fill={color()}
              class="animate-pulse"
            />
          );
        })}
      </svg>
    </div>
  );
};

export const SystemMonitor: Component = () => {
  const {
    currentMetrics,
    isMonitoring,
    connectionStatus,
    error,
    metricsHistory,
    alerts,
    criticalAlerts,
    performanceInsights,
    startMonitoring,
    stopMonitoring,
    refreshMetrics,
    clearError,
    resolveAlert
  } = usePerformance();

  const [selectedTimeRange, setSelectedTimeRange] = createSignal<'5m' | '15m' | '1h' | '24h'>('15m');

  onMount(() => {
    // I'm starting monitoring automatically
    startMonitoring();
  });

  // I'm filtering metrics history based on selected time range
  const filteredHistory = () => {
    const history = metricsHistory();
    const now = Date.now();
    const ranges = {
      '5m': 5 * 60 * 1000,
      '15m': 15 * 60 * 1000,
      '1h': 60 * 60 * 1000,
      '24h': 24 * 60 * 60 * 1000
    };
    
    const cutoff = now - ranges[selectedTimeRange()];
    return history.filter(item => new Date(item.timestamp).getTime() > cutoff);
  };

  const formatUptime = (seconds: number): string => {
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    
    if (days > 0) return `${days}d ${hours}h ${minutes}m`;
    if (hours > 0) return `${hours}h ${minutes}m`;
    return `${minutes}m`;
  };

  return (
    <div class="space-y-6">
      {/* Header Controls */}
      <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4">
        <div>
          <h2 class="text-2xl font-thin text-neutral-200 mb-2">
            SYSTEM MONITOR
          </h2>
          <div class="flex items-center gap-3">
            <div class={`w-2 h-2 rounded-full ${
              connectionStatus() === 'connected' ? 'bg-green-400' :
              connectionStatus() === 'reconnecting' ? 'bg-yellow-400 animate-pulse' :
              'bg-red-400'
            }`}></div>
            <span class="text-sm font-mono text-neutral-500">
              {connectionStatus().toUpperCase()}
            </span>
            {isMonitoring() && (
              <span class="text-xs text-neutral-600">
                • Live monitoring active
              </span>
            )}
          </div>
        </div>

        <div class="flex items-center gap-3">
          {/* Time Range Selector */}
          <div class="flex bg-neutral-900 border border-neutral-700 rounded overflow-hidden">
            {(['5m', '15m', '1h', '24h'] as const).map((range) => (
              <button
                onClick={() => setSelectedTimeRange(range)}
                class={`px-3 py-1 text-xs font-mono transition-colors duration-200 ${
                  selectedTimeRange() === range
                    ? 'bg-neutral-700 text-neutral-100'
                    : 'text-neutral-400 hover:text-neutral-200'
                }`}
              >
                {range}
              </button>
            ))}
          </div>

          {/* Control Buttons */}
          <button
            onClick={refreshMetrics}
            class="px-4 py-2 bg-transparent border border-neutral-600 text-neutral-300 rounded text-sm font-mono hover:border-neutral-500 hover:text-neutral-100 transition-colors duration-200"
          >
            REFRESH
          </button>

          <button
            onClick={isMonitoring() ? stopMonitoring : startMonitoring}
            class={`px-4 py-2 rounded text-sm font-mono transition-colors duration-200 ${
              isMonitoring()
                ? 'bg-red-600 hover:bg-red-700 text-white'
                : 'bg-green-600 hover:bg-green-700 text-white'
            }`}
          >
            {isMonitoring() ? 'STOP' : 'START'}
          </button>
        </div>
      </div>

      {/* Error Display */}
      <Show when={error()}>
        <Card variant="outlined" class="border-red-800 bg-red-900/10">
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-3">
              <div class="text-red-400 text-xl">⚠</div>
              <div>
                <div class="text-red-400 font-mono text-sm font-semibold">
                  MONITORING ERROR
                </div>
                <div class="text-neutral-300 text-sm mt-1">
                  {error()}
                </div>
              </div>
            </div>
            <button
              onClick={clearError}
              class="text-red-400 hover:text-red-300 transition-colors duration-200"
            >
              ✕
            </button>
          </div>
        </Card>
      </Show>

      {/* Critical Alerts */}
      <Show when={criticalAlerts().length > 0}>
        <Card variant="outlined" class="border-red-700 bg-red-900/20">
          <div class="flex items-center gap-3 mb-4">
            <div class="text-red-400 text-xl animate-pulse">🚨</div>
            <h3 class="text-red-400 font-mono text-sm font-semibold">
              CRITICAL ALERTS ({criticalAlerts().length})
            </h3>
          </div>
          
          <div class="space-y-2">
            <For each={criticalAlerts().slice(0, 3)}>
              {(alert) => (
                <div class="flex items-center justify-between bg-red-900/30 rounded p-3">
                  <div class="flex-1">
                    <div class="text-red-300 text-sm font-mono">
                      {alert.message}
                    </div>
                    <div class="text-red-500 text-xs mt-1">
                      {new Date(alert.timestamp).toLocaleTimeString()}
                    </div>
                  </div>
                  <button
                    onClick={() => resolveAlert(alert.id)}
                    class="text-red-400 hover:text-red-300 ml-3 text-xs"
                  >
                    RESOLVE
                  </button>
                </div>
              )}
            </For>
          </div>
        </Card>
      </Show>

      {/* Loading State */}
      <Show when={!currentMetrics() && isMonitoring()}>
        <Card class="text-center py-12">
          <LoadingSpinner 
            variant="pulse" 
            size="lg" 
            message="Collecting system metrics..."
          />
        </Card>
      </Show>

      {/* Main Metrics Display */}
      <Show when={currentMetrics()}>
        <div class="grid lg:grid-cols-3 gap-6">
          {/* Resource Utilization */}
          <div class="lg:col-span-2 space-y-6">
            <Card variant="elevated">
              <h3 class="text-lg font-mono text-neutral-300 mb-6">
                RESOURCE UTILIZATION
              </h3>
              
              <div class="grid md:grid-cols-2 gap-6">
                <ResourceGauge
                  label="CPU Usage"
                  value={currentMetrics()!.cpu_usage_percent}
                  max={100}
                  unit="%"
                  warning={75}
                  critical={90}
                />
                
                <ResourceGauge
                  label="Memory Usage"
                  value={currentMetrics()!.memory_usage_percent}
                  max={100}
                  unit="%"
                  warning={70}
                  critical={85}
                  color="text-purple-400 bg-purple-400"
                />
                
                <ResourceGauge
                  label="Disk Usage"
                  value={currentMetrics()!.disk_usage_percent}
                  max={100}
                  unit="%"
                  warning={80}
                  critical={90}
                  color="text-yellow-400 bg-yellow-400"
                />
                
                <ResourceGauge
                  label="Load Average"
                  value={currentMetrics()!.load_average_1m}
                  max={currentMetrics()!.cpu_cores * 2}
                  unit=""
                  warning={currentMetrics()!.cpu_cores}
                  critical={currentMetrics()!.cpu_cores * 1.5}
                  color="text-green-400 bg-green-400"
                />
              </div>
            </Card>

            {/* Historical Charts */}
            <Card variant="elevated">
              <h3 class="text-lg font-mono text-neutral-300 mb-6">
                PERFORMANCE TRENDS ({selectedTimeRange()})
              </h3>
              
              <div class="grid md:grid-cols-3 gap-6">
                <div>
                  <div class="text-sm text-neutral-400 mb-3">CPU Usage</div>
                  <MiniChart 
                    data={filteredHistory().map(h => ({ timestamp: h.timestamp, value: h.cpu }))}
                    color="#22d3ee"
                  />
                </div>
                
                <div>
                  <div class="text-sm text-neutral-400 mb-3">Memory Usage</div>
                  <MiniChart 
                    data={filteredHistory().map(h => ({ timestamp: h.timestamp, value: h.memory }))}
                    color="#a855f7"
                  />
                </div>
                
                <div>
                  <div class="text-sm text-neutral-400 mb-3">Load Average</div>
                  <MiniChart 
                    data={filteredHistory().map(h => ({ timestamp: h.timestamp, value: h.load }))}
                    color="#22c55e"
                  />
                </div>
              </div>
            </Card>
          </div>

          {/* System Information */}
          <div class="space-y-6">
            <Card variant="elevated">
              <h3 class="text-lg font-mono text-neutral-300 mb-4">
                SYSTEM INFO
              </h3>
              
              <div class="space-y-3 text-sm">
                <div class="flex justify-between">
                  <span class="text-neutral-500">CPU Model</span>
                  <div class="text-right text-neutral-300 font-mono text-xs max-w-[150px] truncate">
                    {currentMetrics()!.cpu_model}
                  </div>
                </div>
                
                <div class="flex justify-between">
                  <span class="text-neutral-500">CPU Cores</span>
                  <span class="text-neutral-300 font-mono">
                    {currentMetrics()!.cpu_cores} cores / {currentMetrics()!.cpu_threads} threads
                  </span>
                </div>
                
                <div class="flex justify-between">
                  <span class="text-neutral-500">Total Memory</span>
                  <span class="text-neutral-300 font-mono">
                    {currentMetrics()!.memory_total_gb.toFixed(1)} GB
                  </span>
                </div>
                
                <div class="flex justify-between">
                  <span class="text-neutral-500">Available Memory</span>
                  <span class="text-neutral-300 font-mono">
                    {currentMetrics()!.memory_available_gb.toFixed(1)} GB
                  </span>
                </div>
                
                <div class="flex justify-between">
                  <span class="text-neutral-500">Uptime</span>
                  <span class="text-neutral-300 font-mono">
                    {formatUptime(currentMetrics()!.uptime_seconds)}
                  </span>
                </div>
                
                <div class="flex justify-between">
                  <span class="text-neutral-500">Processes</span>
                  <span class="text-neutral-300 font-mono">
                    {currentMetrics()!.active_processes}
                  </span>
                </div>
              </div>
            </Card>

            {/* Performance Grade */}
            <Show when={performanceInsights()}>
              <Card variant="elevated">
                <h3 class="text-lg font-mono text-neutral-300 mb-4">
                  PERFORMANCE GRADE
                </h3>
                
                <div class="text-center mb-4">
                  <div class="text-4xl font-mono font-bold text-cyan-400">
                    {performanceInsights()!.grade}
                  </div>
                  <div class="text-sm text-neutral-500 mt-1">
                    {performanceInsights()!.overallScore.toFixed(0)}/100
                  </div>
                </div>
                
                <div class="space-y-2 text-xs">
                  <div class="flex justify-between">
                    <span class="text-neutral-500">CPU Score</span>
                    <span class="text-neutral-300 font-mono">
                      {performanceInsights()!.cpuScore.toFixed(0)}
                    </span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-500">Memory Score</span>
                    <span class="text-neutral-300 font-mono">
                      {performanceInsights()!.memoryScore.toFixed(0)}
                    </span>
                  </div>
                  <div class="flex justify-between">
                    <span class="text-neutral-500">Load Score</span>
                    <span class="text-neutral-300 font-mono">
                      {performanceInsights()!.loadScore.toFixed(0)}
                    </span>
                  </div>
                </div>
              </Card>
            </Show>

            {/* Recommendations */}
            <Show when={performanceInsights()?.recommendations.length}>
              <Card variant="outlined" class="border-yellow-800 bg-yellow-900/10">
                <h3 class="text-sm font-mono text-yellow-400 mb-3">
                  RECOMMENDATIONS
                </h3>
                
                <div class="space-y-2">
                  <For each={performanceInsights()!.recommendations}>
                    {(recommendation) => (
                      <div class="text-xs text-neutral-400 flex items-start gap-2">
                        <div class="text-yellow-400 mt-0.5">•</div>
                        <div>{recommendation}</div>
                      </div>
                    )}
                  </For>
                </div>
              </Card>
            </Show>
          </div>
        </div>
      </Show>
    </div>
  );
};
</file>

<file path="src/components/Performance/TechStackInfo.tsx">
/*
 * Interactive technology stack presentation component that explains tech choices, performance characteristics, and architectural decisions.
 * I'm implementing comprehensive technology showcase with interactive explanations, performance justifications, and educational content to demonstrate the philosophy behind each tech choice.
 */

import { Component, createSignal, Show, For } from 'solid-js';

interface TechStack {
  category: string;
  description: string;
  technologies: Technology[];
}

interface Technology {
  name: string;
  version: string;
  description: string;
  whyChosen: string;
  performanceCharacteristics: string[];
  alternatives: { name: string; reason: string }[];
  keyFeatures: string[];
  benchmarkData?: {
    metric: string;
    value: string;
    comparison: string;
  }[];
}

interface PerformanceComparison {
  category: string;
  rust: number;
  javascript: number;
  python: number;
  java: number;
  unit: string;
}

export const TechStackInfo: Component = () => {
  const [selectedTech, setSelectedTech] = createSignal<Technology | null>(null);
  const [activeCategory, setActiveCategory] = createSignal<string>('backend');

  // I'm defining the complete technology stack with detailed explanations
  const techStacks: TechStack[] = [
    {
      category: 'backend',
      description: 'High-performance computational engine built for speed and reliability',
      technologies: [
        {
          name: 'Rust',
          version: '1.75+',
          description: 'Systems programming language focused on safety, speed, and concurrency',
          whyChosen: 'Rust provides zero-cost abstractions, memory safety without garbage collection, and exceptional performance for mathematical computations. Perfect for our fractal generation engine.',
          performanceCharacteristics: [
            'Zero-cost abstractions with compile-time optimizations',
            'Memory safety without runtime overhead',
            'Excellent parallel processing with Rayon',
            'Native performance comparable to C/C++',
            'Efficient memory allocation and management'
          ],
          alternatives: [
            { name: 'Go', reason: 'Good concurrency but garbage collection creates unpredictable latency' },
            { name: 'C++', reason: 'Similar performance but lacks memory safety guarantees' },
            { name: 'Node.js', reason: 'JavaScript runtime limitations for intensive computation' }
          ],
          keyFeatures: [
            'Compile-time memory safety verification',
            'Zero-overhead concurrency primitives',
            'Cross-platform native compilation',
            'Rich ecosystem for web services (Axum, Tokio)',
            'Excellent tooling and package management'
          ],
          benchmarkData: [
            { metric: 'Fractal Generation', value: '< 50ms', comparison: '10x faster than Python' },
            { metric: 'Memory Usage', value: '< 100MB', comparison: '5x lower than Java' },
            { metric: 'Startup Time', value: '< 5ms', comparison: '50x faster than JVM' },
            { metric: 'Binary Size', value: '< 20MB', comparison: 'Static linking included' }
          ]
        },
        {
          name: 'Axum',
          version: '0.7+',
          description: 'Modern, ergonomic web framework built on Tokio async runtime',
          whyChosen: 'Axum provides excellent performance with type-safe routing, built-in middleware support, and seamless integration with the Tokio ecosystem.',
          performanceCharacteristics: [
            'Built on Tokio for maximum async performance',
            'Zero-cost routing with compile-time verification',
            'Efficient middleware composition',
            'Type-safe request/response handling',
            'Low memory footprint'
          ],
          alternatives: [
            { name: 'Actix-web', reason: 'Slightly faster but more complex API' },
            { name: 'Warp', reason: 'Good performance but less ergonomic' },
            { name: 'Rocket', reason: 'More traditional but less performant' }
          ],
          keyFeatures: [
            'Compile-time route verification',
            'Built-in middleware for CORS, compression, tracing',
            'WebSocket support for real-time updates',
            'Integration with Tower ecosystem',
            'Excellent error handling patterns'
          ]
        },
        {
          name: 'PostgreSQL',
          version: '15+',
          description: 'Advanced open-source relational database with excellent performance',
          whyChosen: 'PostgreSQL offers superior performance for complex queries, excellent JSON support, and robust ACID guarantees needed for reliable data storage.',
          performanceCharacteristics: [
            'Advanced query optimization and indexing',
            'Efficient connection pooling with SQLx',
            'JSON/JSONB support for flexible schemas',
            'Excellent concurrent read/write performance',
            'Advanced analytics and window functions'
          ],
          alternatives: [
            { name: 'MySQL', reason: 'Less advanced feature set and JSON support' },
            { name: 'SQLite', reason: 'Single-user limitations for web applications' },
            { name: 'MongoDB', reason: 'No ACID guarantees and query limitations' }
          ],
          keyFeatures: [
            'ACID compliance with excellent performance',
            'Advanced indexing (B-tree, Hash, GIN, GiST)',
            'Full-text search capabilities',
            'JSON document storage and querying',
            'Extensive ecosystem and tooling'
          ]
        }
      ]
    },
    {
      category: 'frontend',
      description: 'Reactive, high-performance user interface built for real-time interactions',
      technologies: [
        {
          name: 'SolidJS',
          version: '1.8+',
          description: 'Fine-grained reactive UI library with exceptional performance',
          whyChosen: 'SolidJS provides React-like ergonomics with superior performance, no virtual DOM overhead, and perfect for real-time fractal visualization updates.',
          performanceCharacteristics: [
            'Fine-grained reactivity without virtual DOM',
            'Compile-time optimizations',
            'Minimal runtime overhead',
            'Excellent performance for frequent updates',
            'Small bundle size'
          ],
          alternatives: [
            { name: 'React', reason: 'Virtual DOM overhead affects real-time performance' },
            { name: 'Vue', reason: 'Reactive system not as fine-grained' },
            { name: 'Svelte', reason: 'Good performance but less mature ecosystem' }
          ],
          keyFeatures: [
            'Fine-grained reactivity system',
            'JSX with compile-time optimizations',
            'Excellent TypeScript integration',
            'Small runtime footprint',
            'Real-time friendly update patterns'
          ],
          benchmarkData: [
            { metric: 'Initial Render', value: '< 16ms', comparison: '3x faster than React' },
            { metric: 'Update Performance', value: '< 1ms', comparison: 'No virtual DOM diff' },
            { metric: 'Bundle Size', value: '< 50KB', comparison: '50% smaller than React' },
            { metric: 'Memory Usage', value: '< 20MB', comparison: 'No virtual DOM memory' }
          ]
        },
        {
          name: 'TypeScript',
          version: '5.0+',
          description: 'Typed superset of JavaScript providing development-time safety',
          whyChosen: 'TypeScript eliminates entire classes of runtime errors, improves code maintainability, and provides excellent IDE support for complex mathematical operations.',
          performanceCharacteristics: [
            'Compile-time error detection',
            'Zero runtime overhead',
            'Excellent IDE performance and intellisense',
            'Dead code elimination',
            'Advanced type inference'
          ],
          alternatives: [
            { name: 'JavaScript', reason: 'Lack of type safety for complex applications' },
            { name: 'Flow', reason: 'Less adoption and weaker ecosystem' },
            { name: 'PureScript', reason: 'Too different from JavaScript ecosystem' }
          ],
          keyFeatures: [
            'Static type checking',
            'Advanced type system with generics',
            'Excellent IDE integration',
            'Gradual adoption possible',
            'Large ecosystem compatibility'
          ]
        },
        {
          name: 'Tailwind CSS',
          version: '3.4+',
          description: 'Utility-first CSS framework optimized for rapid development',
          whyChosen: 'Tailwind provides consistent design system, excellent performance with purging, and perfect for creating the dark, eerie aesthetic we need.',
          performanceCharacteristics: [
            'CSS purging for minimal bundle size',
            'JIT compilation for development speed',
            'Consistent spacing and color scales',
            'No runtime CSS-in-JS overhead',
            'Excellent caching characteristics'
          ],
          alternatives: [
            { name: 'Styled Components', reason: 'Runtime overhead and larger bundles' },
            { name: 'CSS Modules', reason: 'Less design system consistency' },
            { name: 'Bootstrap', reason: 'Too opinionated and larger bundle size' }
          ],
          keyFeatures: [
            'Utility-first methodology',
            'JIT compilation and purging',
            'Responsive design utilities',
            'Dark mode support',
            'Excellent customization options'
          ]
        }
      ]
    },
    {
      category: 'infrastructure',
      description: 'Production-ready deployment and monitoring infrastructure',
      technologies: [
        {
          name: 'Docker',
          version: '24+',
          description: 'Containerization platform for consistent deployments',
          whyChosen: 'Docker ensures consistent environments across development and production, efficient resource utilization, and easy scaling.',
          performanceCharacteristics: [
            'Minimal containerization overhead',
            'Efficient image layering and caching',
            'Fast startup times with alpine images',
            'Excellent resource isolation',
            'Consistent cross-platform behavior'
          ],
          alternatives: [
            { name: 'Podman', reason: 'Good alternative but less ecosystem support' },
            { name: 'LXC', reason: 'More complex setup and management' },
            { name: 'Native deployment', reason: 'Environment inconsistencies' }
          ],
          keyFeatures: [
            'Multi-stage builds for optimization',
            'Image layering and caching',
            'Container orchestration support',
            'Security isolation',
            'Extensive ecosystem integration'
          ]
        },
        {
          name: 'Nginx',
          version: '1.25+',
          description: 'High-performance HTTP server and reverse proxy',
          whyChosen: 'Nginx provides excellent static file serving, efficient reverse proxying, and advanced features like rate limiting and compression.',
          performanceCharacteristics: [
            'Event-driven architecture for high concurrency',
            'Efficient static file serving',
            'Advanced caching capabilities',
            'Low memory footprint',
            'HTTP/2 and HTTP/3 support'
          ],
          alternatives: [
            { name: 'Apache', reason: 'Higher memory usage and less efficient' },
            { name: 'Caddy', reason: 'Easier config but less performance tuning' },
            { name: 'Traefik', reason: 'Good for microservices but more complex' }
          ],
          keyFeatures: [
            'Reverse proxy and load balancing',
            'SSL/TLS termination',
            'Rate limiting and security features',
            'Compression and caching',
            'WebSocket support'
          ]
        }
      ]
    }
  ];

  // I'm providing performance comparison data
  const performanceComparisons: PerformanceComparison[] = [
    {
      category: 'HTTP Requests/sec',
      rust: 100000,
      javascript: 25000,
      python: 5000,
      java: 45000,
      unit: 'req/s'
    },
    {
      category: 'Memory Usage',
      rust: 50,
      javascript: 200,
      python: 300,
      java: 400,
      unit: 'MB'
    },
    {
      category: 'Startup Time',
      rust: 5,
      javascript: 100,
      python: 200,
      java: 2000,
      unit: 'ms'
    },
    {
      category: 'Mathematical Computation',
      rust: 100,
      javascript: 15,
      python: 8,
      java: 85,
      unit: '% of Rust performance'
    }
  ];

  const getCurrentTechnologies = () => {
    return techStacks.find(stack => stack.category === activeCategory())?.technologies || [];
  };

  const getPerformanceBarWidth = (value: number, category: string) => {
    const comparison = performanceComparisons.find(c => c.category === category);
    if (!comparison) return 0;

    const maxValue = Math.max(comparison.rust, comparison.javascript, comparison.python, comparison.java);

    // For "Memory Usage" and "Startup Time", lower is better, so we invert the percentage
    if (category === 'Memory Usage' || category === 'Startup Time') {
      return ((maxValue - value) / maxValue) * 100;
    }

    return (value / maxValue) * 100;
  };

  const getPerformanceColor = (tech: string) => {
    switch (tech) {
      case 'rust': return 'bg-orange-500';
      case 'javascript': return 'bg-yellow-500';
      case 'python': return 'bg-blue-500';
      case 'java': return 'bg-red-500';
      default: return 'bg-neutral-500';
    }
  };

  return (
    <div class="space-y-8">
      {/* Header */}
      <div class="text-center mb-12">
        <h2 class="text-3xl font-thin text-neutral-200 mb-4">
          TECHNOLOGY STACK
        </h2>
        <p class="text-neutral-500 max-w-3xl mx-auto leading-relaxed">
          Every technology choice is deliberate, optimized for performance, and aligned with our philosophy
          of computational precision. Here's why each tool earns its place in this digital ecosystem.
        </p>
      </div>

      {/* Category navigation */}
      <div class="flex justify-center mb-8">
        <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-2 flex gap-2">
          <For each={techStacks}>
            {(stack) => (
              <button
                onClick={() => setActiveCategory(stack.category)}
                class={`px-6 py-3 rounded-sm font-mono text-sm tracking-wide transition-all duration-300 ${
                  activeCategory() === stack.category
                    ? 'bg-neutral-100 text-black'
                    : 'text-neutral-400 hover:text-neutral-200'
                }`}
              >
                {stack.category.toUpperCase()}
              </button>
            )}
          </For>
        </div>
      </div>

      {/* Category description */}
      <Show when={techStacks.find(s => s.category === activeCategory())}>
        <div class="text-center mb-8">
          <p class="text-neutral-400 max-w-2xl mx-auto">
            {techStacks.find(s => s.category === activeCategory())!.description}
          </p>
        </div>
      </Show>

      {/* Technology grid */}
      <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6 mb-12">
        <For each={getCurrentTechnologies()}>
          {(tech) => (
            <div
              class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6 cursor-pointer transition-all duration-300 hover:border-neutral-600 hover:bg-neutral-900/50"
              onClick={() => setSelectedTech(tech)}
            >
              <div class="flex items-center justify-between mb-4">
                <h3 class="text-xl font-mono text-neutral-100">{tech.name}</h3>
                <span class="text-xs text-neutral-500 font-mono">{tech.version}</span>
              </div>

              <p class="text-sm text-neutral-400 mb-4 leading-relaxed">
                {tech.description}
              </p>

              <div class="text-xs text-neutral-600">
                Click to learn more →
              </div>
            </div>
          )}
        </For>
      </div>

      {/* Performance comparison charts */}
      <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-8">
        <h3 class="text-2xl font-mono text-neutral-300 mb-6 text-center">
          PERFORMANCE COMPARISON
        </h3>

        <div class="space-y-8">
          <For each={performanceComparisons}>
            {(comparison) => (
              <div>
                <div class="flex items-center justify-between mb-3">
                  <h4 class="text-lg font-mono text-neutral-400">{comparison.category}</h4>
                  <span class="text-sm text-neutral-600">{comparison.unit}</span>
                </div>

                <div class="space-y-3">
                  <div class="flex items-center gap-4">
                    <div class="w-16 text-sm font-mono text-neutral-400">Rust</div>
                    <div class="flex-1 bg-neutral-800 rounded-full h-6 relative">
                      <div
                        class={`h-6 rounded-full ${getPerformanceColor('rust')} flex items-center justify-end pr-3`}
                        style={{ width: `${getPerformanceBarWidth(comparison.rust, comparison.category)}%` }}
                      >
                        <span class="text-xs font-mono text-white">
                          {comparison.rust.toLocaleString()}
                        </span>
                      </div>
                    </div>
                  </div>

                  <div class="flex items-center gap-4">
                    <div class="w-16 text-sm font-mono text-neutral-400">Node.js</div>
                    <div class="flex-1 bg-neutral-800 rounded-full h-6 relative">
                      <div
                        class={`h-6 rounded-full ${getPerformanceColor('javascript')} flex items-center justify-end pr-3`}
                        style={{ width: `${getPerformanceBarWidth(comparison.javascript, comparison.category)}%` }}
                      >
                        <span class="text-xs font-mono text-black">
                          {comparison.javascript.toLocaleString()}
                        </span>
                      </div>
                    </div>
                  </div>

                  <div class="flex items-center gap-4">
                    <div class="w-16 text-sm font-mono text-neutral-400">Python</div>
                    <div class="flex-1 bg-neutral-800 rounded-full h-6 relative">
                      <div
                        class={`h-6 rounded-full ${getPerformanceColor('python')} flex items-center justify-end pr-3`}
                        style={{ width: `${getPerformanceBarWidth(comparison.python, comparison.category)}%` }}
                      >
                        <span class="text-xs font-mono text-white">
                          {comparison.python.toLocaleString()}
                        </span>
                      </div>
                    </div>
                  </div>

                  <div class="flex items-center gap-4">
                    <div class="w-16 text-sm font-mono text-neutral-400">Java</div>
                    <div class="flex-1 bg-neutral-800 rounded-full h-6 relative">
                      <div
                        class={`h-6 rounded-full ${getPerformanceColor('java')} flex items-center justify-end pr-3`}
                        style={{ width: `${getPerformanceBarWidth(comparison.java, comparison.category)}%` }}
                      >
                        <span class="text-xs font-mono text-white">
                          {comparison.java.toLocaleString()}
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </For>
        </div>
      </div>

      {/* Detailed technology modal */}
      <Show when={selectedTech()}>
        <div class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-6">
          <div class="bg-neutral-900 border border-neutral-700 rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto">
            <div class="p-8">
              <div class="flex items-center justify-between mb-6">
                <div>
                  <h3 class="text-3xl font-mono text-neutral-100 mb-2">
                    {selectedTech()!.name}
                  </h3>
                  <p class="text-neutral-400">{selectedTech()!.description}</p>
                </div>
                <button
                  onClick={() => setSelectedTech(null)}
                  class="text-neutral-400 hover:text-neutral-200 text-2xl"
                >
                  ×
                </button>
              </div>

              <div class="grid md:grid-cols-2 gap-8">
                {/* Why chosen */}
                <div>
                  <h4 class="text-lg font-mono text-neutral-300 mb-3">WHY CHOSEN</h4>
                  <p class="text-neutral-400 leading-relaxed mb-6">
                    {selectedTech()!.whyChosen}
                  </p>

                  <h4 class="text-lg font-mono text-neutral-300 mb-3">KEY FEATURES</h4>
                  <ul class="space-y-2">
                    <For each={selectedTech()!.keyFeatures}>
                      {(feature) => (
                        <li class="text-neutral-400 text-sm flex items-start gap-2">
                          <span class="text-green-400 text-xs mt-1">▶</span>
                          {feature}
                        </li>
                      )}
                    </For>
                  </ul>
                </div>

                {/* Performance and alternatives */}
                <div>
                  <h4 class="text-lg font-mono text-neutral-300 mb-3">PERFORMANCE CHARACTERISTICS</h4>
                  <ul class="space-y-2 mb-6">
                    <For each={selectedTech()!.performanceCharacteristics}>
                      {(characteristic) => (
                        <li class="text-neutral-400 text-sm flex items-start gap-2">
                          <span class="text-blue-400 text-xs mt-1">●</span>
                          {characteristic}
                        </li>
                      )}
                    </For>
                  </ul>

                  <h4 class="text-lg font-mono text-neutral-300 mb-3">ALTERNATIVES CONSIDERED</h4>
                  <div class="space-y-3">
                    <For each={selectedTech()!.alternatives}>
                      {(alt) => (
                        <div class="bg-neutral-800/50 rounded-sm p-3">
                          <div class="font-mono text-sm text-neutral-300 mb-1">{alt.name}</div>
                          <div class="text-xs text-neutral-500">{alt.reason}</div>
                        </div>
                      )}
                    </For>
                  </div>
                </div>
              </div>

              {/* Benchmark data if available */}
              <Show when={selectedTech()!.benchmarkData}>
                <div class="mt-8 pt-6 border-t border-neutral-800">
                  <h4 class="text-lg font-mono text-neutral-300 mb-4">BENCHMARK DATA</h4>
                  <div class="grid md:grid-cols-2 gap-4">
                    <For each={selectedTech()!.benchmarkData}>
                      {(benchmark) => (
                        <div class="bg-neutral-800/30 rounded-sm p-4">
                          <div class="text-sm text-neutral-400 mb-1">{benchmark.metric}</div>
                          <div class="text-xl font-mono text-green-400 mb-1">{benchmark.value}</div>
                          <div class="text-xs text-neutral-600">{benchmark.comparison}</div>
                        </div>
                      )}
                    </For>
                  </div>
                </div>
              </Show>
            </div>
          </div>
        </div>
      </Show>
    </div>
  );
};
</file>

<file path="src/components/UI/Button.tsx">
/*
 * Reusable button component with consistent styling, accessibility features, and various states for the dark-themed UI system.
 * I'm implementing comprehensive button variants, interaction states, and accessibility compliance to maintain design consistency across the application.
 */

import { Component, JSX, splitProps } from 'solid-js';

interface ButtonProps extends JSX.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'ghost' | 'danger' | 'success';
  size?: 'sm' | 'md' | 'lg';
  isLoading?: boolean;
  isDisabled?: boolean;
  fullWidth?: boolean;
  leftIcon?: JSX.Element;
  rightIcon?: JSX.Element;
  children: JSX.Element;
}

export const Button: Component<ButtonProps> = (props) => {
  const [local, others] = splitProps(props, [
    'variant',
    'size',
    'isLoading',
    'isDisabled',
    'fullWidth',
    'leftIcon',
    'rightIcon',
    'children',
    'class'
  ]);

  // I'm defining the base styles and variants for consistent theming
  const baseStyles = `
    inline-flex items-center justify-center gap-2 font-mono text-sm tracking-wide
    transition-all duration-200 ease-in-out focus:outline-none focus:ring-2
    focus:ring-offset-2 focus:ring-offset-black disabled:cursor-not-allowed
    relative overflow-hidden
  `;

  const getVariantStyles = () => {
    const variant = local.variant || 'primary';

    switch (variant) {
      case 'primary':
        return `
          bg-neutral-100 text-black border border-neutral-100
          hover:bg-neutral-200 hover:border-neutral-200
          focus:ring-neutral-400
          disabled:bg-neutral-600 disabled:text-neutral-400 disabled:border-neutral-600
          active:scale-95
        `;

      case 'secondary':
        return `
          bg-transparent text-neutral-100 border border-neutral-600
          hover:bg-neutral-800 hover:border-neutral-500
          focus:ring-neutral-500
          disabled:text-neutral-600 disabled:border-neutral-700
          active:scale-95
        `;

      case 'ghost':
        return `
          bg-transparent text-neutral-400 border border-transparent
          hover:bg-neutral-800/50 hover:text-neutral-200
          focus:ring-neutral-600
          disabled:text-neutral-700
          active:scale-95
        `;

      case 'danger':
        return `
          bg-red-600 text-white border border-red-600
          hover:bg-red-700 hover:border-red-700
          focus:ring-red-500
          disabled:bg-red-800 disabled:border-red-800
          active:scale-95
        `;

      case 'success':
        return `
          bg-green-600 text-white border border-green-600
          hover:bg-green-700 hover:border-green-700
          focus:ring-green-500
          disabled:bg-green-800 disabled:border-green-800
          active:scale-95
        `;

      default:
        return '';
    }
  };

  const getSizeStyles = () => {
    const size = local.size || 'md';

    switch (size) {
      case 'sm':
        return 'px-3 py-1.5 text-xs min-h-[2rem]';
      case 'lg':
        return 'px-8 py-4 text-base min-h-[3rem]';
      case 'md':
      default:
        return 'px-6 py-2.5 text-sm min-h-[2.5rem]';
    }
  };

  const isDisabled = () => local.isDisabled || local.isLoading;

  return (
    <button
      {...others}
      disabled={isDisabled()}
      class={`
        ${baseStyles}
        ${getVariantStyles()}
        ${getSizeStyles()}
        ${local.fullWidth ? 'w-full' : ''}
        ${local.class || ''}
      `}
      aria-disabled={isDisabled()}
    >
      {/* Loading spinner overlay */}
      {local.isLoading && (
        <div class="absolute inset-0 flex items-center justify-center bg-current/10">
          <div class="w-4 h-4 border-2 border-current border-t-transparent rounded-full animate-spin"></div>
        </div>
      )}

      {/* Button content */}
      <div class={`flex items-center gap-2 ${local.isLoading ? 'opacity-0' : 'opacity-100'} transition-opacity duration-200`}>
        {local.leftIcon && (
          <span class="flex-shrink-0">
            {local.leftIcon}
          </span>
        )}

        <span class="truncate">
          {local.children}
        </span>

        {local.rightIcon && (
          <span class="flex-shrink-0">
            {local.rightIcon}
          </span>
        )}
      </div>

      {/* Subtle glow effect for primary variant */}
      {local.variant === 'primary' && !isDisabled() && (
        <div class="absolute inset-0 opacity-0 hover:opacity-20 transition-opacity duration-300 bg-gradient-to-r from-blue-400/30 to-purple-400/30 rounded-[inherit]"></div>
      )}
    </button>
  );
};
</file>

<file path="src/components/UI/Card.tsx">
/*
 * Versatile card component providing consistent dark-themed containers with hover effects and multiple variants for content organization.
 * I'm implementing flexible styling options, interactive states, and accessibility features that align with the eerie, contemplative aesthetic while maintaining semantic HTML structure.
 */

import { Component, JSX, splitProps, createMemo } from 'solid-js';

interface CardProps extends JSX.HTMLAttributes<HTMLDivElement> {
  variant?: 'default' | 'elevated' | 'outlined' | 'ghost' | 'glass';
  padding?: 'none' | 'sm' | 'md' | 'lg' | 'xl';
  hover?: boolean;
  glow?: boolean;
  interactive?: boolean;
  children: JSX.Element;
}

export const Card: Component<CardProps> = (props) => {
  const [local, others] = splitProps(props, [
    'variant',
    'padding',
    'hover',
    'glow',
    'interactive',
    'children',
    'class'
  ]);

  // I'm computing the classes based on props for optimal performance
  const cardClasses = createMemo(() => {
    const baseClasses = 'rounded-lg transition-all duration-300 ease-in-out';

    const variantClasses = {
      default: 'bg-neutral-900/30 border border-neutral-800',
      elevated: 'bg-neutral-900/50 border border-neutral-700 shadow-lg',
      outlined: 'bg-transparent border-2 border-neutral-700',
      ghost: 'bg-neutral-900/10 border border-transparent',
      glass: 'bg-neutral-900/20 backdrop-blur-md border border-neutral-700/50'
    };

    const paddingClasses = {
      none: '',
      sm: 'p-3',
      md: 'p-4',
      lg: 'p-6',
      xl: 'p-8'
    };

    const hoverClasses = local.hover !== false ? 'hover:border-neutral-600' : '';
    const glowClasses = local.glow ? 'hover:shadow-[0_0_20px_rgba(34,211,238,0.3)]' : '';
    const interactiveClasses = local.interactive ? 'cursor-pointer hover:transform hover:scale-[1.01]' : '';

    return [
      baseClasses,
      variantClasses[local.variant || 'default'],
      paddingClasses[local.padding || 'md'],
      hoverClasses,
      glowClasses,
      interactiveClasses,
      local.class || ''
    ].filter(Boolean).join(' ');
  });

  return (
    <div
      {...others}
      class={cardClasses()}
    >
      {local.children}
    </div>
  );
};

// I'm also creating specialized card variants for common use cases
export const MetricCard: Component<{
  title: string;
  value: string | number;
  unit?: string;
  trend?: 'up' | 'down' | 'stable';
  description?: string;
  icon?: JSX.Element;
}> = (props) => {
  const trendColors = {
    up: 'text-green-400',
    down: 'text-red-400',
    stable: 'text-neutral-400'
  };

  const trendIcons = {
    up: '↗',
    down: '↘',
    stable: '⟷'
  };

  return (
    <Card variant="elevated" hover glow>
      <div class="flex items-start justify-between">
        <div class="flex-1">
          <div class="flex items-center gap-2 mb-2">
            {props.icon && (
              <div class="text-neutral-400">
                {props.icon}
              </div>
            )}
            <h3 class="text-xs font-mono text-neutral-500 uppercase tracking-wide">
              {props.title}
            </h3>
          </div>

          <div class="flex items-baseline gap-1 mb-2">
            <span class="text-2xl font-mono text-neutral-100 font-semibold">
              {props.value}
            </span>
            {props.unit && (
              <span class="text-sm text-neutral-400">
                {props.unit}
              </span>
            )}
          </div>

          {props.description && (
            <p class="text-xs text-neutral-600 leading-relaxed">
              {props.description}
            </p>
          )}
        </div>

        {props.trend && (
          <div class={`flex items-center gap-1 text-sm ${trendColors[props.trend]}`}>
            <span class="font-mono">
              {trendIcons[props.trend]}
            </span>
          </div>
        )}
      </div>
    </Card>
  );
};

export const CodeCard: Component<{
  title?: string;
  language?: string;
  children: JSX.Element;
}> = (props) => {
  return (
    <Card variant="glass" padding="none">
      {props.title && (
        <div class="flex items-center justify-between px-4 py-2 border-b border-neutral-700">
          <h3 class="text-sm font-mono text-neutral-300">
            {props.title}
          </h3>
          {props.language && (
            <span class="text-xs bg-neutral-800 text-neutral-500 px-2 py-1 rounded font-mono">
              {props.language}
            </span>
          )}
        </div>
      )}
      <div class="p-4 font-mono text-sm">
        {props.children}
      </div>
    </Card>
  );
};

export const StatusCard: Component<{
  status: 'healthy' | 'warning' | 'error' | 'unknown';
  title: string;
  message?: string;
  lastUpdated?: string;
}> = (props) => {
  const statusConfig = {
    healthy: {
      color: 'text-green-400',
      bg: 'bg-green-900/20',
      border: 'border-green-800',
      icon: '●'
    },
    warning: {
      color: 'text-yellow-400',
      bg: 'bg-yellow-900/20',
      border: 'border-yellow-800',
      icon: '▲'
    },
    error: {
      color: 'text-red-400',
      bg: 'bg-red-900/20',
      border: 'border-red-800',
      icon: '✕'
    },
    unknown: {
      color: 'text-neutral-400',
      bg: 'bg-neutral-900/20',
      border: 'border-neutral-700',
      icon: '?'
    }
  };

  const config = statusConfig[props.status];

  return (
    <Card class={`${config.bg} ${config.border}`}>
      <div class="flex items-start gap-3">
        <div class={`text-lg ${config.color} mt-0.5`}>
          {config.icon}
        </div>

        <div class="flex-1">
          <div class="flex items-center justify-between mb-1">
            <h3 class="font-mono text-sm text-neutral-200">
              {props.title}
            </h3>
            <span class={`text-xs font-mono uppercase ${config.color}`}>
              {props.status}
            </span>
          </div>

          {props.message && (
            <p class="text-sm text-neutral-400 mb-2">
              {props.message}
            </p>
          )}

          {props.lastUpdated && (
            <p class="text-xs text-neutral-600 font-mono">
              Updated: {props.lastUpdated}
            </p>
          )}
        </div>
      </div>
    </Card>
  );
};

export const LinkCard: Component<{
  href: string;
  title: string;
  description?: string;
  external?: boolean;
  children?: JSX.Element;
}> = (props) => {
  return (
    <a
      href={props.href}
      target={props.external ? '_blank' : '_self'}
      rel={props.external ? 'noopener noreferrer' : undefined}
      class="block no-underline"
    >
      <Card interactive hover glow>
        <div class="flex items-start justify-between">
          <div class="flex-1">
            <h3 class="font-mono text-lg text-neutral-200 mb-2 group-hover:text-neutral-100">
              {props.title}
            </h3>

            {props.description && (
              <p class="text-sm text-neutral-400 leading-relaxed">
                {props.description}
              </p>
            )}

            {props.children}
          </div>

          <div class="text-neutral-600 ml-4">
            {props.external ? '↗' : '→'}
          </div>
        </div>
      </Card>
    </a>
  );
};
</file>

<file path="src/components/UI/ErrorBoundary.tsx">
/*
 * Robust error boundary component providing graceful error handling and recovery for the entire application with contextual error reporting.
 * I'm implementing comprehensive error catching, logging, and user-friendly fallback interfaces that maintain the dark aesthetic while providing actionable error information and recovery options.
 */

import { Component, JSX, createSignal, createEffect, Show, onMount } from 'solid-js';
import { Card } from './Card';

interface ErrorInfo {
  error: Error;
  timestamp: Date;
  component?: string;
  context?: string;
  userAgent?: string;
  url?: string;
  stackTrace?: string;
}

interface ErrorBoundaryProps {
  children: JSX.Element;
  fallback?: (error: ErrorInfo, retry: () => void) => JSX.Element;
  onError?: (error: ErrorInfo) => void;
  context?: string;
  level?: 'page' | 'component' | 'critical';
}

export const ErrorBoundary: Component<ErrorBoundaryProps> = (props) => {
  const [error, setError] = createSignal<ErrorInfo | null>(null);
  const [retryCount, setRetryCount] = createSignal(0);

  // I'm setting up global error handlers for comprehensive error catching
  onMount(() => {
    // Handle unhandled promise rejections
    const handleUnhandledRejection = (event: PromiseRejectionEvent) => {
      const errorInfo: ErrorInfo = {
        error: new Error(`Unhandled Promise Rejection: ${event.reason}`),
        timestamp: new Date(),
        context: props.context || 'Promise Rejection',
        userAgent: navigator.userAgent,
        url: window.location.href,
        stackTrace: event.reason?.stack || 'No stack trace available'
      };

      handleError(errorInfo);
      event.preventDefault();
    };

    // Handle general JavaScript errors
    const handleError = (event: ErrorEvent) => {
      const errorInfo: ErrorInfo = {
        error: event.error || new Error(event.message),
        timestamp: new Date(),
        context: props.context || 'JavaScript Error',
        userAgent: navigator.userAgent,
        url: window.location.href,
        stackTrace: event.error?.stack || 'No stack trace available'
      };

      handleError(errorInfo);
    };

    window.addEventListener('unhandledrejection', handleUnhandledRejection);
    window.addEventListener('error', handleError);

    return () => {
      window.removeEventListener('unhandledrejection', handleUnhandledRejection);
      window.removeEventListener('error', handleError);
    };
  });

  const handleError = (errorInfo: ErrorInfo) => {
    console.error('Error caught by boundary:', errorInfo);

    // I'm logging the error for debugging and monitoring
    if (props.onError) {
      props.onError(errorInfo);
    }

    // Send error to monitoring service (would be implemented in production)
    reportError(errorInfo);

    setError(errorInfo);
  };

  const retry = () => {
    setError(null);
    setRetryCount(prev => prev + 1);
  };

  const reportError = (errorInfo: ErrorInfo) => {
    // I'm implementing error reporting (would connect to monitoring service in production)
    try {
      const errorReport = {
        ...errorInfo,
        retryCount: retryCount(),
        level: props.level || 'component',
        error: {
          name: errorInfo.error.name,
          message: errorInfo.error.message,
          stack: errorInfo.error.stack
        }
      };

      // In production, this would send to an error monitoring service
      console.warn('Error report:', errorReport);

      // Store in localStorage for debugging
      const existingErrors = JSON.parse(localStorage.getItem('app-errors') || '[]');
      existingErrors.push(errorReport);

      // Keep only last 10 errors
      const recentErrors = existingErrors.slice(-10);
      localStorage.setItem('app-errors', JSON.stringify(recentErrors));
    } catch (reportingError) {
      console.error('Failed to report error:', reportingError);
    }
  };

  // I'm providing different fallback UIs based on error context
  const renderFallback = () => {
    const currentError = error()!;

    if (props.fallback) {
      return props.fallback(currentError, retry);
    }

    // Default fallback based on error level
    switch (props.level) {
      case 'critical':
        return <CriticalErrorFallback error={currentError} onRetry={retry} />;
      case 'page':
        return <PageErrorFallback error={currentError} onRetry={retry} />;
      case 'component':
      default:
        return <ComponentErrorFallback error={currentError} onRetry={retry} />;
    }
  };

  // I'm implementing error recovery through retry mechanism
  createEffect(() => {
    // Clear error after successful retry
    if (retryCount() > 0 && !error()) {
      console.log(`Error recovered after ${retryCount()} retries`);
    }
  });

  return (
    <Show when={!error()} fallback={renderFallback()}>
      {props.children}
    </Show>
  );
};

// I'm creating specialized error fallback components for different contexts
const ComponentErrorFallback: Component<{
  error: ErrorInfo;
  onRetry: () => void;
}> = (props) => {
  const [showDetails, setShowDetails] = createSignal(false);

  return (
    <Card variant="outlined" class="border-red-800 bg-red-900/10">
      <div class="flex items-start gap-3">
        <div class="text-red-400 text-xl flex-shrink-0">
          ⚠
        </div>

        <div class="flex-1">
          <h3 class="text-red-400 font-mono text-sm font-semibold mb-2">
            Component Error
          </h3>

          <p class="text-neutral-300 text-sm mb-4">
            Something went wrong in this component. The error has been logged and reported.
          </p>

          <div class="flex items-center gap-3 mb-4">
            <button
              onClick={props.onRetry}
              class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded text-sm font-mono transition-colors duration-200"
            >
              RETRY
            </button>

            <button
              onClick={() => setShowDetails(!showDetails())}
              class="px-4 py-2 bg-transparent border border-neutral-600 hover:border-neutral-500 text-neutral-300 rounded text-sm font-mono transition-colors duration-200"
            >
              {showDetails() ? 'HIDE' : 'DETAILS'}
            </button>
          </div>

          <Show when={showDetails()}>
            <div class="bg-black/50 rounded p-3 font-mono text-xs">
              <div class="text-neutral-400 mb-2">Error Message:</div>
              <div class="text-red-300 mb-3">{props.error.error.message}</div>

              <div class="text-neutral-400 mb-2">Context:</div>
              <div class="text-neutral-300 mb-3">{props.error.context || 'Unknown'}</div>

              <div class="text-neutral-400 mb-2">Timestamp:</div>
              <div class="text-neutral-300">{props.error.timestamp.toISOString()}</div>

              <Show when={props.error.stackTrace}>
                <div class="text-neutral-400 mt-3 mb-2">Stack Trace:</div>
                <pre class="text-neutral-500 text-xs overflow-x-auto whitespace-pre-wrap">
                  {props.error.stackTrace}
                </pre>
              </Show>
            </div>
          </Show>
        </div>
      </div>
    </Card>
  );
};

const PageErrorFallback: Component<{
  error: ErrorInfo;
  onRetry: () => void;
}> = (props) => {
  return (
    <div class="min-h-screen bg-black text-neutral-100 flex items-center justify-center p-6">
      <div class="max-w-md w-full">
        <Card variant="elevated" class="text-center border-red-800">
          <div class="text-red-400 text-6xl mb-6">
            ⚠
          </div>

          <h1 class="text-2xl font-thin text-neutral-100 mb-4">
            PAGE ERROR
          </h1>

          <p class="text-neutral-400 mb-6 leading-relaxed">
            An unexpected error occurred while loading this page. The system has logged
            the issue and our monitoring systems have been notified.
          </p>

          <div class="space-y-3">
            <button
              onClick={props.onRetry}
              class="w-full px-6 py-3 bg-red-600 hover:bg-red-700 text-white rounded font-mono text-sm transition-colors duration-200"
            >
              RETRY LOADING
            </button>

            <button
              onClick={() => window.location.href = '/'}
              class="w-full px-6 py-3 bg-transparent border border-neutral-600 hover:border-neutral-500 text-neutral-300 rounded font-mono text-sm transition-colors duration-200"
            >
              RETURN HOME
            </button>
          </div>

          <div class="mt-6 pt-6 border-t border-neutral-800">
            <p class="text-xs text-neutral-600">
              Error ID: {props.error.timestamp.getTime().toString(36)}
            </p>
          </div>
        </Card>
      </div>
    </div>
  );
};

const CriticalErrorFallback: Component<{
  error: ErrorInfo;
  onRetry: () => void;
}> = (props) => {
  return (
    <div class="min-h-screen bg-black text-neutral-100 flex items-center justify-center p-6">
      <div class="max-w-lg w-full">
        <Card variant="elevated" class="text-center border-red-700 bg-red-900/20">
          <div class="text-red-400 text-8xl mb-6 animate-pulse">
            ⚠
          </div>

          <h1 class="text-3xl font-thin text-neutral-100 mb-4">
            CRITICAL SYSTEM ERROR
          </h1>

          <p class="text-neutral-300 mb-6 leading-relaxed">
            A critical error has occurred that prevents the application from functioning normally.
            This issue has been automatically reported to our development team.
          </p>

          <div class="bg-red-900/30 border border-red-800 rounded p-4 mb-6">
            <div class="text-red-300 font-mono text-sm">
              {props.error.error.message}
            </div>
          </div>

          <div class="space-y-4">
            <button
              onClick={props.onRetry}
              class="w-full px-6 py-3 bg-red-600 hover:bg-red-700 text-white rounded font-mono text-sm transition-colors duration-200"
            >
              ATTEMPT RECOVERY
            </button>

            <button
              onClick={() => window.location.reload()}
              class="w-full px-6 py-3 bg-transparent border border-neutral-600 hover:border-neutral-500 text-neutral-300 rounded font-mono text-sm transition-colors duration-200"
            >
              RELOAD APPLICATION
            </button>
          </div>

          <div class="mt-8 pt-6 border-t border-neutral-800">
            <p class="text-xs text-neutral-600 italic">
              "In the face of computational failure, we find opportunities for greater understanding."
            </p>
          </div>
        </Card>
      </div>
    </div>
  );
};

// I'm providing specialized error boundaries for specific contexts
export const FractalErrorBoundary: Component<{
  children: JSX.Element;
}> = (props) => {
  return (
    <ErrorBoundary
      context="Fractal Generation"
      level="component"
      fallback={(error, retry) => (
        <Card variant="outlined" class="border-red-800 bg-red-900/10 text-center p-8">
          <div class="text-red-400 text-4xl mb-4">∞</div>
          <h3 class="text-red-400 font-mono text-lg mb-3">FRACTAL COMPUTATION ERROR</h3>
          <p class="text-neutral-400 text-sm mb-4">
            Mathematical complexity exceeded safe computational bounds.
          </p>
          <button
            onClick={retry}
            class="px-6 py-2 bg-red-600 hover:bg-red-700 text-white rounded font-mono text-sm transition-colors duration-200"
          >
            RECALCULATE
          </button>
        </Card>
      )}
    >
      {props.children}
    </ErrorBoundary>
  );
};

export const PerformanceErrorBoundary: Component<{
  children: JSX.Element;
}> = (props) => {
  return (
    <ErrorBoundary
      context="Performance Monitoring"
      level="component"
      fallback={(error, retry) => (
        <Card variant="outlined" class="border-yellow-800 bg-yellow-900/10 text-center p-6">
          <div class="text-yellow-400 text-3xl mb-3">📊</div>
          <h3 class="text-yellow-400 font-mono text-sm mb-2">METRICS COLLECTION FAILED</h3>
          <p class="text-neutral-400 text-xs mb-4">
            Performance monitoring temporarily unavailable.
          </p>
          <button
            onClick={retry}
            class="px-4 py-2 bg-yellow-600 hover:bg-yellow-700 text-black rounded font-mono text-xs transition-colors duration-200"
          >
            RECONNECT
          </button>
        </Card>
      )}
    >
      {props.children}
    </ErrorBoundary>
  );
};

// I'm providing utilities for manual error reporting
export const reportManualError = (error: Error, context?: string) => {
  const errorInfo: ErrorInfo = {
    error,
    timestamp: new Date(),
    context: context || 'Manual Report',
    userAgent: navigator.userAgent,
    url: window.location.href,
    stackTrace: error.stack
  };

  console.error('Manual error report:', errorInfo);

  // Store for debugging
  try {
    const existingErrors = JSON.parse(localStorage.getItem('app-errors') || '[]');
    existingErrors.push(errorInfo);
    localStorage.setItem('app-errors', JSON.stringify(existingErrors.slice(-10)));
  } catch (storageError) {
    console.warn('Failed to store error locally:', storageError);
  }
};

export const getStoredErrors = (): ErrorInfo[] => {
  try {
    return JSON.parse(localStorage.getItem('app-errors') || '[]');
  } catch {
    return [];
  }
};

export const clearStoredErrors = () => {
  try {
    localStorage.removeItem('app-errors');
  } catch (error) {
    console.warn('Failed to clear stored errors:', error);
  }
};
</file>

<file path="src/components/UI/LoadingSpinner.tsx">
/*
 * Advanced loading spinner component providing multiple animation variants and states for asynchronous operations throughout the application.
 * I'm implementing various spinner types, sizes, and contextual loading messages that maintain the dark aesthetic while providing clear feedback during computation-intensive operations like fractal generation.
 */

import { Component, JSX, Show, createMemo } from 'solid-js';

interface LoadingSpinnerProps {
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  variant?: 'default' | 'pulse' | 'dots' | 'bars' | 'fractal' | 'matrix';
  color?: 'primary' | 'secondary' | 'accent' | 'white';
  message?: string;
  overlay?: boolean;
  centered?: boolean;
  className?: string;
}

export const LoadingSpinner: Component<LoadingSpinnerProps> = (props) => {
  // I'm creating responsive size classes for different contexts
  const sizeClasses = createMemo(() => {
    const sizes = {
      xs: 'w-3 h-3',
      sm: 'w-4 h-4',
      md: 'w-6 h-6',
      lg: 'w-8 h-8',
      xl: 'w-12 h-12'
    };
    return sizes[props.size || 'md'];
  });

  // I'm defining color schemes that match the dark theme
  const colorClasses = createMemo(() => {
    const colors = {
      primary: 'text-cyan-400 border-cyan-400',
      secondary: 'text-indigo-400 border-indigo-400',
      accent: 'text-purple-400 border-purple-400',
      white: 'text-white border-white'
    };
    return colors[props.color || 'primary'];
  });

  // I'm implementing different spinner variants for various contexts
  const renderSpinner = () => {
    const variant = props.variant || 'default';
    const baseClasses = `${sizeClasses()} ${colorClasses()}`;

    switch (variant) {
      case 'default':
        return (
          <div class={`${baseClasses} border-2 border-t-transparent rounded-full animate-spin`}></div>
        );

      case 'pulse':
        return (
          <div class={`${baseClasses} bg-current rounded-full animate-pulse`}></div>
        );

      case 'dots':
        return (
          <div class="flex space-x-1">
            {[0, 1, 2].map((i) => (
              <div
                class={`w-2 h-2 bg-current rounded-full animate-bounce ${colorClasses()}`}
                style={{ 'animation-delay': `${i * 0.1}s` }}
              ></div>
            ))}
          </div>
        );

      case 'bars':
        return (
          <div class="flex space-x-1 items-end">
            {[0, 1, 2, 3].map((i) => (
              <div
                class={`w-1 bg-current animate-pulse ${colorClasses()}`}
                style={{
                  height: `${8 + (i % 2) * 4}px`,
                  'animation-delay': `${i * 0.15}s`,
                  'animation-duration': '0.8s'
                }}
              ></div>
            ))}
          </div>
        );

      case 'fractal':
        return (
          <div class={`${baseClasses} relative`}>
            <div class="absolute inset-0 border-2 border-t-transparent rounded-full animate-spin"></div>
            <div class="absolute inset-1 border border-r-transparent rounded-full animate-spin animation-reverse" style="animation-duration: 1.5s"></div>
            <div class="absolute inset-2 border border-b-transparent rounded-full animate-spin" style="animation-duration: 2s"></div>
          </div>
        );

      case 'matrix':
        return (
          <div class="flex flex-col space-y-1">
            {[0, 1, 2].map((row) => (
              <div class="flex space-x-1">
                {[0, 1, 2].map((col) => (
                  <div
                    class={`w-1 h-1 bg-current animate-pulse ${colorClasses()}`}
                    style={{
                      'animation-delay': `${(row * 3 + col) * 0.1}s`,
                      opacity: Math.random() > 0.5 ? 1 : 0.3
                    }}
                  ></div>
                ))}
              </div>
            ))}
          </div>
        );

      default:
        return (
          <div class={`${baseClasses} border-2 border-t-transparent rounded-full animate-spin`}></div>
        );
    }
  };

  const containerClasses = createMemo(() => {
    const baseClasses = 'flex items-center gap-3';
    const centerClasses = props.centered ? 'justify-center' : '';
    const overlayClasses = props.overlay
      ? 'fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center'
      : '';

    return [baseClasses, centerClasses, overlayClasses, props.className].filter(Boolean).join(' ');
  });

  return (
    <div class={containerClasses()}>
      <div class="flex items-center gap-3">
        {renderSpinner()}

        <Show when={props.message}>
          <div class="text-neutral-400 font-mono text-sm tracking-wide">
            {props.message}
          </div>
        </Show>
      </div>
    </div>
  );
};

// I'm creating specialized loading components for different contexts
export const FractalLoader: Component<{
  message?: string;
  progress?: number;
}> = (props) => {
  return (
    <div class="flex flex-col items-center gap-4 p-8">
      <LoadingSpinner
        variant="fractal"
        size="xl"
        color="primary"
      />

      <div class="text-center">
        <div class="text-neutral-300 font-mono text-sm mb-2">
          {props.message || "Computing fractal..."}
        </div>

        <Show when={props.progress !== undefined}>
          <div class="w-64 h-1 bg-neutral-800 rounded-full overflow-hidden">
            <div
              class="h-full bg-gradient-to-r from-cyan-400 to-indigo-400 rounded-full transition-all duration-300"
              style={{ width: `${props.progress}%` }}
            ></div>
          </div>
          <div class="text-xs text-neutral-500 font-mono mt-1">
            {props.progress?.toFixed(1)}%
          </div>
        </Show>
      </div>
    </div>
  );
};

export const SystemLoader: Component<{
  systems: Array<{ name: string; status: 'loading' | 'complete' | 'error' }>;
}> = (props) => {
  return (
    <div class="space-y-3">
      {props.systems.map((system) => (
        <div class="flex items-center gap-3 p-3 bg-neutral-900/30 rounded border border-neutral-800">
          <div class="flex-shrink-0">
            {system.status === 'loading' && (
              <LoadingSpinner size="sm" variant="dots" />
            )}
            {system.status === 'complete' && (
              <div class="w-4 h-4 text-green-400">✓</div>
            )}
            {system.status === 'error' && (
              <div class="w-4 h-4 text-red-400">✕</div>
            )}
          </div>

          <div class="flex-1">
            <div class="text-sm font-mono text-neutral-300">
              {system.name}
            </div>
          </div>

          <div class="text-xs font-mono text-neutral-500">
            {system.status.toUpperCase()}
          </div>
        </div>
      ))}
    </div>
  );
};

export const BenchmarkLoader: Component<{
  currentTest?: string;
  completed: number;
  total: number;
}> = (props) => {
  const progress = () => (props.completed / props.total) * 100;

  return (
    <div class="text-center space-y-6 p-8">
      <LoadingSpinner
        variant="bars"
        size="lg"
        color="accent"
      />

      <div>
        <h3 class="text-lg font-mono text-neutral-200 mb-2">
          RUNNING BENCHMARK SUITE
        </h3>

        <Show when={props.currentTest}>
          <p class="text-sm text-neutral-400 mb-4">
            Currently testing: <span class="text-neutral-300 font-mono">{props.currentTest}</span>
          </p>
        </Show>

        <div class="space-y-2">
          <div class="flex justify-between text-xs font-mono text-neutral-500">
            <span>Progress</span>
            <span>{props.completed} / {props.total}</span>
          </div>

          <div class="w-80 h-2 bg-neutral-800 rounded-full overflow-hidden mx-auto">
            <div
              class="h-full bg-gradient-to-r from-purple-400 to-pink-400 rounded-full transition-all duration-500"
              style={{ width: `${progress()}%` }}
            ></div>
          </div>
        </div>
      </div>

      <p class="text-xs text-neutral-600 italic max-w-sm mx-auto">
        Performance testing requires precision. Each measurement brings us closer to computational truth.
      </p>
    </div>
  );
};

export const NetworkLoader: Component<{
  endpoint?: string;
  timeout?: number;
}> = (props) => {
  return (
    <div class="flex items-center gap-3 p-4">
      <LoadingSpinner
        variant="pulse"
        size="sm"
        color="secondary"
      />

      <div class="text-sm text-neutral-400">
        <Show when={props.endpoint} fallback="Loading...">
          Connecting to <span class="font-mono text-neutral-300">{props.endpoint}</span>
        </Show>

        <Show when={props.timeout}>
          <div class="text-xs text-neutral-600 mt-1">
            Timeout: {props.timeout}ms
          </div>
        </Show>
      </div>
    </div>
  );
};

// I'm adding custom CSS animations for the spinner variants
export const injectSpinnerStyles = () => {
  const style = document.createElement('style');
  style.textContent = `
    .animation-reverse {
      animation-direction: reverse;
    }

    @keyframes matrix-flicker {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    .matrix-flicker {
      animation: matrix-flicker 0.5s ease-in-out infinite;
    }

    @keyframes fractal-spin {
      0% { transform: rotate(0deg) scale(1); }
      50% { transform: rotate(180deg) scale(1.1); }
      100% { transform: rotate(360deg) scale(1); }
    }

    .fractal-spin {
      animation: fractal-spin 2s linear infinite;
    }
  `;

  if (!document.getElementById('spinner-styles')) {
    style.id = 'spinner-styles';
    document.head.appendChild(style);
  }
};
</file>

<file path="src/components/Counter.tsx">
/*
 * Simple interactive counter component demonstrating SolidJS reactivity with dark-themed styling for the performance showcase.
 * I'm implementing fine-grained reactivity with hover effects and click animations that align with the overall eerie aesthetic while showcasing the framework's reactive capabilities.
 */

import { Component, createSignal } from 'solid-js';

export const Counter: Component = () => {
  const [count, setCount] = createSignal(0);

  // I'm implementing click handler with performance tracking
  const handleClick = () => {
    setCount(prev => prev + 1);
  };

  // I'm adding reset functionality for better UX
  const handleReset = () => {
    setCount(0);
  };

  return (
    <div class="flex flex-col items-center gap-4 p-6 bg-neutral-900/30 border border-neutral-800 rounded-lg backdrop-blur-sm">
      {/* Counter Display */}
      <div class="text-center">
        <div class="text-4xl font-mono text-neutral-100 mb-2">
          {count()}
        </div>
        <div class="text-xs text-neutral-500 font-mono uppercase tracking-wide">
          CLICK COUNT
        </div>
      </div>

      {/* Controls */}
      <div class="flex items-center gap-3">
        <button
          onClick={handleClick}
          class="group relative px-6 py-3 bg-neutral-800 hover:bg-neutral-700 active:bg-neutral-600 border border-neutral-600 hover:border-neutral-500 text-neutral-100 rounded font-mono text-sm transition-all duration-200 overflow-hidden"
        >
          {/* Click effect overlay */}
          <div class="absolute inset-0 bg-cyan-400/20 opacity-0 group-active:opacity-100 transition-opacity duration-150"></div>

          <span class="relative z-10">INCREMENT</span>
        </button>

        <button
          onClick={handleReset}
          disabled={count() === 0}
          class="px-4 py-3 bg-transparent hover:bg-red-900/20 active:bg-red-900/30 border border-red-800/50 hover:border-red-700 disabled:border-neutral-700 disabled:text-neutral-600 disabled:hover:bg-transparent text-red-400 disabled:text-neutral-600 rounded font-mono text-sm transition-all duration-200 disabled:cursor-not-allowed"
        >
          RESET
        </button>
      </div>

      {/* Performance insight */}
      <div class="text-center text-xs text-neutral-600">
        <div class="mb-1">SolidJS fine-grained reactivity</div>
        <div>Updates only when count changes</div>
      </div>

      {/* Visual indicator for high counts */}
      {count() > 10 && (
        <div class="text-xs text-cyan-400 font-mono animate-pulse">
          Impressive dedication to clicking
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/Nav.tsx">
/*
 * Navigation component providing clean, minimal navigation links with dark styling and active state indicators.
 * I'm implementing router-aware navigation with hover effects and active states that complement the overall eerie aesthetic while maintaining excellent accessibility and keyboard navigation support.
 */

import { Component } from 'solid-js';
import { A, useLocation } from '@solidjs/router';

interface NavItem {
  href: string;
  label: string;
  description?: string;
}

interface NavProps {
  variant?: 'horizontal' | 'vertical';
  className?: string;
}

export const Nav: Component<NavProps> = (props) => {
  const location = useLocation();

  // I'm defining the navigation structure with philosophical descriptions
  const navItems: NavItem[] = [
    {
      href: '/',
      label: 'HOME',
      description: 'Return to the digital void'
    },
    {
      href: '/projects',
      label: 'REPOSITORIES',
      description: 'Explore code artifacts'
    },
    {
      href: '/performance',
      label: 'METRICS',
      description: 'Witness computational precision'
    },
    {
      href: '/about',
      label: 'ARCHITECTURE',
      description: 'Understand the foundation'
    }
  ];

  // I'm implementing intelligent active state detection
  const isActive = (path: string): boolean => {
    if (path === '/') {
      return location.pathname === '/';
    }
    return location.pathname.startsWith(path);
  };

  const variant = props.variant || 'horizontal';

  return (
    <nav class={`${props.className || ''}`}>
      <ul class={`flex ${variant === 'vertical' ? 'flex-col space-y-1' : 'items-center space-x-8'}`}>
        {navItems.map((item) => (
          <li class="relative group">
            <A
              href={item.href}
              class={`
                block px-3 py-2 font-mono text-sm tracking-wide transition-all duration-300 relative
                ${isActive(item.href)
                  ? 'text-neutral-100'
                  : 'text-neutral-500 hover:text-neutral-300'
                }
              `}
            >
              {item.label}

              {/* Active indicator line */}
              <div class={`
                absolute bottom-0 left-0 h-px bg-cyan-400 transition-all duration-300
                ${isActive(item.href) ? 'w-full' : 'w-0 group-hover:w-full'}
              `}></div>

              {/* Active indicator dot for vertical layout */}
              {variant === 'vertical' && (
                <div class={`
                  absolute left-0 top-1/2 transform -translate-y-1/2 -translate-x-4 w-1 h-1 bg-cyan-400 rounded-full transition-opacity duration-300
                  ${isActive(item.href) ? 'opacity-100' : 'opacity-0'}
                `}></div>
              )}

              {/* Hover tooltip with description */}
              {item.description && (
                <div class="absolute top-full left-1/2 transform -translate-x-1/2 mt-2 px-3 py-1 bg-black/90 backdrop-blur-sm border border-neutral-700 rounded text-xs text-neutral-400 whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none z-50">
                  {item.description}
                </div>
              )}
            </A>
          </li>
        ))}
      </ul>
    </nav>
  );
};

// I'm also exporting a minimal version for specific use cases
export const SimpleNav: Component = () => {
  const location = useLocation();

  const isActive = (path: string) => {
    return path === '/' ? location.pathname === '/' : location.pathname.startsWith(path);
  };

  return (
    <nav class="flex items-center space-x-6">
      <A
        href="/"
        class={`text-sm font-mono transition-colors duration-200 ${
          isActive('/') ? 'text-neutral-100' : 'text-neutral-500 hover:text-neutral-300'
        }`}
      >
        HOME
      </A>
      <A
        href="/projects"
        class={`text-sm font-mono transition-colors duration-200 ${
          isActive('/projects') ? 'text-neutral-100' : 'text-neutral-500 hover:text-neutral-300'
        }`}
      >
        PROJECTS
      </A>
      <A
        href="/performance"
        class={`text-sm font-mono transition-colors duration-200 ${
          isActive('/performance') ? 'text-neutral-100' : 'text-neutral-500 hover:text-neutral-300'
        }`}
      >
        PERFORMANCE
      </A>
      <A
        href="/about"
        class={`text-sm font-mono transition-colors duration-200 ${
          isActive('/about') ? 'text-neutral-100' : 'text-neutral-500 hover:text-neutral-300'
        }`}
      >
        ABOUT
      </A>
    </nav>
  );
};
</file>

<file path="src/hooks/useFractals.ts">
/*
 * Fractal computation hook managing real-time mathematical visualization with performance tracking and interactive controls.
 * I'm implementing comprehensive fractal state management that bridges the gap between user interaction and high-performance Rust backend computation.
 */

import { createSignal, createResource, createMemo, onCleanup } from 'solid-js';
import { createStore, produce } from 'solid-js/store';

interface FractalRequest {
  width: number;
  height: number;
  center_x: number;
  center_y: number;
  zoom: number;
  max_iterations: number;
  fractal_type: 'mandelbrot' | 'julia';
  c_real?: number;
  c_imag?: number;
}

interface FractalResponse {
  data: number[];
  width: number;
  height: number;
  computation_time_ms: number;
  zoom_level: number;
  parameters: any;
  performance_metrics: {
    pixels_per_second: number;
    parallel_efficiency: number;
    memory_usage_mb: number;
    cpu_utilization: number;
  };
}

interface BenchmarkResult {
  benchmark_results: Array<{
    complexity: string;
    resolution: string;
    total_pixels: number;
    mandelbrot: {
      computation_time_ms: number;
      pixels_per_ms: number;
      performance_rating: string;
    };
    julia: {
      computation_time_ms: number;
      pixels_per_ms: number;
      performance_rating: string;
    };
  }>;
  system_context: {
    cpu_model: string;
    cpu_cores: number;
    memory_total_gb: number;
    rust_version: string;
    parallel_processing: boolean;
  };
  performance_analysis: {
    language: string;
    framework: string;
    optimization_level: string;
  };
}

interface PerformanceHistory {
  timestamp: string;
  computation_time: number;
  pixels_computed: number;
  zoom_level: number;
  fractal_type: string;
}

interface FractalState {
  currentFractal: FractalResponse | null;
  isGenerating: boolean;
  error: string | null;
  benchmarkResults: BenchmarkResult | null;
  performanceHistory: PerformanceHistory[];
  settings: {
    fractalType: 'mandelbrot' | 'julia';
    width: number;
    height: number;
    maxIterations: number;
    juliaConstant: { real: number; imag: number };
  };
  interactionMode: 'pan' | 'zoom' | 'parameter';
}

export function useFractals() {
  // I'm setting up comprehensive fractal state management
  const [state, setState] = createStore<FractalState>({
    currentFractal: null,
    isGenerating: false,
    error: null,
    benchmarkResults: null,
    performanceHistory: [],
    settings: {
      fractalType: 'mandelbrot',
      width: 800,
      height: 600,
      maxIterations: 100,
      juliaConstant: { real: -0.7, imag: 0.27015 },
    },
    interactionMode: 'zoom',
  });

  // I'm implementing performance tracking signals
  const [generationCount, setGenerationCount] = createSignal(0);
  const [totalComputationTime, setTotalComputationTime] = createSignal(0);
  const [averageGenerationTime, setAverageGenerationTime] = createSignal(0);

  // Fractal generation resource
  const [fractalResource] = createResource(
    () => ({ 
      request: buildFractalRequest(), 
      count: generationCount() 
    }),
    async ({ request }) => {
      setState('isGenerating', true);
      setState('error', null);

      try {
        const endpoint = request.fractal_type === 'mandelbrot' 
          ? '/api/fractals/mandelbrot' 
          : '/api/fractals/julia';

        const params = new URLSearchParams();
        params.append('width', request.width.toString());
        params.append('height', request.height.toString());
        params.append('center_x', request.center_x.toString());
        params.append('center_y', request.center_y.toString());
        params.append('zoom', request.zoom.toString());
        params.append('max_iterations', request.max_iterations.toString());
        
        if (request.fractal_type === 'julia') {
          params.append('c_real', (request.c_real || -0.7).toString());
          params.append('c_imag', (request.c_imag || 0.27015).toString());
        }

        const response = await fetch(`${endpoint}?${params}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data: FractalResponse = await response.json();
        
        // Update performance tracking
        const newCount = generationCount() + 1;
        const newTotal = totalComputationTime() + data.computation_time_ms;
        setGenerationCount(newCount);
        setTotalComputationTime(newTotal);
        setAverageGenerationTime(newTotal / newCount);

        // Add to performance history
        setState('performanceHistory', produce(history => {
          history.unshift({
            timestamp: new Date().toISOString(),
            computation_time: data.computation_time_ms,
            pixels_computed: data.width * data.height,
            zoom_level: data.zoom_level,
            fractal_type: request.fractal_type,
          });
          
          // Keep only last 50 entries
          if (history.length > 50) {
            history.splice(50);
          }
        }));

        setState('currentFractal', data);
        return data;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Fractal generation failed';
        setState('error', errorMessage);
        throw error;
      } finally {
        setState('isGenerating', false);
      }
    }
  );

  // Benchmark resource for performance testing
  const [benchmarkResource] = createResource(
    () => null, // Manual trigger
    async () => {
      try {
        setState('isGenerating', true);
        
        const response = await fetch('/api/fractals/benchmark', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data: BenchmarkResult = await response.json();
        setState('benchmarkResults', data);
        return data;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Benchmark failed';
        setState('error', errorMessage);
        throw error;
      } finally {
        setState('isGenerating', false);
      }
    }
  );

  // I'm implementing computed values for enhanced analytics
  const performanceStats = createMemo(() => {
    const history = state.performanceHistory;
    if (history.length === 0) return null;

    const totalPixels = history.reduce((sum, entry) => sum + entry.pixels_computed, 0);
    const totalTime = history.reduce((sum, entry) => sum + entry.computation_time, 0);
    const averagePixelsPerMs = totalPixels / totalTime;

    const mandelbrotEntries = history.filter(entry => entry.fractal_type === 'mandelbrot');
    const juliaEntries = history.filter(entry => entry.fractal_type === 'julia');

    return {
      totalGenerations: history.length,
      totalPixelsComputed: totalPixels,
      totalComputationTime: totalTime,
      averagePixelsPerMs,
      averageComputationTime: totalTime / history.length,
      mandelbrotCount: mandelbrotEntries.length,
      juliaCount: juliaEntries.length,
      fastestGeneration: Math.min(...history.map(entry => entry.computation_time)),
      slowestGeneration: Math.max(...history.map(entry => entry.computation_time)),
      averageZoomLevel: history.reduce((sum, entry) => sum + entry.zoom_level, 0) / history.length,
    };
  });

  const currentPerformance = createMemo(() => {
    const current = state.currentFractal;
    if (!current) return null;

    return {
      computationTime: current.computation_time_ms,
      pixelsPerSecond: current.performance_metrics.pixels_per_second,
      parallelEfficiency: current.performance_metrics.parallel_efficiency,
      memoryUsage: current.performance_metrics.memory_usage_mb,
      cpuUtilization: current.performance_metrics.cpu_utilization,
      pixelsComputed: current.width * current.height,
      zoomLevel: current.zoom_level,
      performanceRating: getPerformanceRating(current.performance_metrics.pixels_per_second),
    };
  });

  // Helper function to build fractal request from current state
  function buildFractalRequest(): Omit<FractalRequest, 'center_x' | 'center_y' | 'zoom'> {
    return {
      width: state.settings.width,
      height: state.settings.height,
      max_iterations: state.settings.maxIterations,
      fractal_type: state.settings.fractalType,
      ...(state.settings.fractalType === 'julia' && {
        c_real: state.settings.juliaConstant.real,
        c_imag: state.settings.juliaConstant.imag,
      }),
    };
  }

  // Actions for fractal management
  const actions = {
    // Generate fractal with specific parameters
    async generateFractal(params: {
      center_x: number;
      center_y: number;
      zoom: number;
      width?: number;
      height?: number;
      max_iterations?: number;
    }): Promise<FractalResponse | null> {
      const request: FractalRequest = {
        ...buildFractalRequest(),
        center_x: params.center_x,
        center_y: params.center_y,
        zoom: params.zoom,
        width: params.width || state.settings.width,
        height: params.height || state.settings.height,
        max_iterations: params.max_iterations || state.settings.maxIterations,
      };

      try {
        const endpoint = request.fractal_type === 'mandelbrot' 
          ? '/api/fractals/mandelbrot' 
          : '/api/fractals/julia';

        const urlParams = new URLSearchParams({
          width: request.width.toString(),
          height: request.height.toString(),
          center_x: request.center_x.toString(),
          center_y: request.center_y.toString(),
          zoom: request.zoom.toString(),
          max_iterations: request.max_iterations.toString(),
        });

        if (request.fractal_type === 'julia') {
          urlParams.append('c_real', (request.c_real || -0.7).toString());
          urlParams.append('c_imag', (request.c_imag || 0.27015).toString());
        }

        const response = await fetch(`${endpoint}?${urlParams}`, {
          method: 'POST',
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data: FractalResponse = await response.json();
        setState('currentFractal', data);
        
        // Update performance tracking
        const newCount = generationCount() + 1;
        const newTotal = totalComputationTime() + data.computation_time_ms;
        setGenerationCount(newCount);
        setTotalComputationTime(newTotal);
        setAverageGenerationTime(newTotal / newCount);

        return data;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Fractal generation failed';
        setState('error', errorMessage);
        return null;
      }
    },

    // Run comprehensive benchmark
    async runBenchmark(): Promise<void> {
      benchmarkResource.refetch();
    },

    // Update fractal settings
    updateSettings(newSettings: Partial<FractalState['settings']>) {
      setState('settings', produce(current => Object.assign(current, newSettings)));
      
      // Trigger regeneration if we have current parameters
      if (state.currentFractal) {
        setGenerationCount(prev => prev + 1);
      }
    },

    // Set fractal type
    setFractalType(type: 'mandelbrot' | 'julia') {
      setState('settings', 'fractalType', type);
      
      // Adjust iterations based on fractal type
      if (type === 'julia' && state.settings.maxIterations < 150) {
        setState('settings', 'maxIterations', 150);
      } else if (type === 'mandelbrot' && state.settings.maxIterations > 1000) {
        setState('settings', 'maxIterations', 200);
      }
    },

    // Update Julia constant
    setJuliaConstant(real: number, imag: number) {
      setState('settings', 'juliaConstant', { real, imag });
      
      if (state.settings.fractalType === 'julia') {
        setGenerationCount(prev => prev + 1);
      }
    },

    // Set resolution
    setResolution(width: number, height: number) {
      setState('settings', produce(settings => {
        settings.width = Math.max(64, Math.min(4096, width));
        settings.height = Math.max(64, Math.min(4096, height));
      }));
    },

    // Set maximum iterations
    setMaxIterations(iterations: number) {
      setState('settings', 'maxIterations', Math.max(50, Math.min(10000, iterations)));
    },

    // Set interaction mode
    setInteractionMode(mode: 'pan' | 'zoom' | 'parameter') {
      setState('interactionMode', mode);
    },

    // Clear error state
    clearError() {
      setState('error', null);
    },

    // Clear performance history
    clearHistory() {
      setState('performanceHistory', []);
      setGenerationCount(0);
      setTotalComputationTime(0);
      setAverageGenerationTime(0);
    },

    // Export fractal data
    exportFractalData() {
      const current = state.currentFractal;
      if (!current) return null;

      return {
        fractal_data: current,
        settings: state.settings,
        performance_stats: performanceStats(),
        generation_history: state.performanceHistory.slice(0, 10), // Last 10 generations
        export_timestamp: new Date().toISOString(),
      };
    },

    // Get optimal iterations for zoom level
    getOptimalIterations(zoomLevel: number): number {
      const baseIterations = state.settings.fractalType === 'mandelbrot' ? 100 : 150;
      const zoomFactor = Math.log10(Math.max(1, zoomLevel));
      const optimalIterations = Math.floor(baseIterations + (zoomFactor * 50));
      
      return Math.max(50, Math.min(2000, optimalIterations));
    },
  };

  // I'm implementing automatic cleanup
  onCleanup(() => {
    // Clear any pending requests or timers
  });

  // Helper functions
  function getPerformanceRating(pixelsPerSecond: number): string {
    if (pixelsPerSecond > 10000) return 'Exceptional';
    if (pixelsPerSecond > 5000) return 'Excellent';
    if (pixelsPerSecond > 2000) return 'Very Good';
    if (pixelsPerSecond > 1000) return 'Good';
    if (pixelsPerSecond > 500) return 'Fair';
    return 'Needs Optimization';
  }

  return {
    // State
    currentFractal: () => state.currentFractal,
    isGenerating: () => state.isGenerating,
    error: () => state.error,
    settings: () => state.settings,
    interactionMode: () => state.interactionMode,
    
    // Performance data
    performanceHistory: () => state.performanceHistory,
    performanceStats,
    currentPerformance,
    benchmarkResults: () => state.benchmarkResults,
    
    // Metrics
    generationCount,
    averageGenerationTime,
    totalComputationTime,
    
    // Resources
    fractalResource,
    benchmarkResource,
    
    // Actions
    ...actions,
  };
}

export type { FractalRequest, FractalResponse, BenchmarkResult, PerformanceHistory };
</file>

<file path="src/hooks/useGitHub.ts">
/*
 * GitHub data management hook providing reactive state management and intelligent caching for repository data.
 * I'm implementing comprehensive GitHub API integration with SolidJS reactivity, error handling, and performance optimization.
 */

import { createSignal, createResource, createMemo, createEffect, onCleanup } from 'solid-js';
import { createStore, produce } from 'solid-js/store';

interface Repository {
    id: number;
    github_id: number;
    owner: string;
    name: string;
    full_name: string;
    description?: string;
    html_url: string;
    clone_url: string;
    ssh_url: string;
    language?: string;
    size_kb: number;
    stargazers_count: number;
    watchers_count: number;
    forks_count: number;
    open_issues_count: number;
    created_at: string;
    updated_at: string;
    pushed_at?: string;
    is_private: boolean;
    is_fork: boolean;
    is_archived: boolean;
    topics: string[];
    license_name?: string;
    readme_content?: string;
    cached_at: string;
    cache_expires_at: string;
}

interface RepositoryDetailed extends Repository {
    readme_content: string;
    stats: RepositoryStats;
    contributors_count: number;
    commit_count: number;
    branch_count: number;
    release_count: number;
}

interface RepositoryStats {
    commit_frequency: number;
    contributors_count: number;
    issues_ratio: number;
    fork_ratio: number;
    activity_score: number;
    health_score: number;
    last_activity_days: number;
}

interface RepositoryFilter {
    language?: string;
    min_stars?: number;
    max_stars?: number;
    is_fork?: boolean;
    is_archived?: boolean;
    search?: string;
    sort?: string;
    direction?: string;
}

interface RepositoryResponse {
    repositories: Repository[];
    pagination: {
        current_page: number;
        per_page: number;
        total_pages: number;
        total_count: number;
        has_next_page: boolean;
        has_previous_page: boolean;
    };
    statistics: {
        total_stars: number;
        total_forks: number;
        average_stars: number;
        most_starred_repo: string;
        language_count: number;
        topics_count: number;
    };
    rate_limit: {
        limit: number;
        remaining: number;
        reset_at: string;
        percentage_used: number;
    };
}

interface LanguageDistribution {
    languages: Array<{
        name: string;
        repository_count: number;
        total_size_kb: number;
        percentage: number;
        average_stars: number;
    }>;
    summary: {
        total_languages: number;
        total_repositories_analyzed: number;
        most_used_language?: string;
        language_diversity_score: number;
    };
}

interface GitHubState {
    repositories: Repository[];
    selectedRepository: RepositoryDetailed | null;
    languageDistribution: LanguageDistribution | null;
    currentPage: number;
    totalPages: number;
    totalCount: number;
    isLoading: boolean;
    error: string | null;
    filters: RepositoryFilter;
    statistics: any;
    rateLimit: any;
}

export function useGitHub() {
    // I'm setting up reactive state management with SolidJS stores
    const [state, setState] = createStore<GitHubState>({
        repositories: [],
        selectedRepository: null,
        languageDistribution: null,
        currentPage: 1,
        totalPages: 0,
        totalCount: 0,
        isLoading: false,
        error: null,
        filters: {},
        statistics: null,
        rateLimit: null,
    });

    // I'm implementing caching signals for performance optimization
    const [cacheTimestamp, setCacheTimestamp] = createSignal<number>(0);
    const [refreshInterval, setRefreshInterval] = createSignal<number | null>(null);

    // Main repositories resource with intelligent caching
    const [repositories] = createResource(
        () => ({
            page: state.currentPage,
            filters: state.filters,
            cacheKey: cacheTimestamp()
        }),
        async ({ page, filters }) => {
            setState('isLoading', true);
            setState('error', null);

            try {
                const params = new URLSearchParams({
                    page: page.toString(),
                                                   per_page: '20',
                                                   ...Object.fromEntries(
                                                       Object.entries(filters).filter(([_, value]) => value !== undefined && value !== '')
                                                   ),
                });

                const response = await fetch(`/api/github/repos?${params}`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data: RepositoryResponse = await response.json();

                setState('repositories', data.repositories);
                setState('totalPages', data.pagination.total_pages);
                setState('totalCount', data.pagination.total_count);
                setState('statistics', data.statistics);
                setState('rateLimit', data.rate_limit);

                return data;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Failed to fetch repositories';
                setState('error', errorMessage);
                throw error;
            } finally {
                setState('isLoading', false);
            }
        }
    );

    // Language distribution resource
    const [languageData] = createResource(
        () => cacheTimestamp(),
                                          async () => {
                                              try {
                                                  const response = await fetch('/api/github/language-distribution');
                                                  if (!response.ok) {
                                                      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                                                  }

                                                  const data: LanguageDistribution = await response.json();
                                                  setState('languageDistribution', data);
                                                  return data;
                                              } catch (error) {
                                                  console.warn('Failed to fetch language distribution:', error);
                                                  return null;
                                              }
                                          }
    );

    // I'm implementing computed values for enhanced data presentation
    const filteredRepositories = createMemo(() => {
        return state.repositories.filter(repo => {
            if (state.filters.search) {
                const searchTerm = state.filters.search.toLowerCase();
                const searchableText = `${repo.name} ${repo.description || ''} ${repo.topics.join(' ')}`.toLowerCase();
                if (!searchableText.includes(searchTerm)) return false;
            }

            if (state.filters.language && repo.language !== state.filters.language) {
                return false;
            }

            if (state.filters.min_stars && repo.stargazers_count < state.filters.min_stars) {
                return false;
            }

            if (state.filters.max_stars && repo.stargazers_count > state.filters.max_stars) {
                return false;
            }

            if (state.filters.is_fork !== undefined && repo.is_fork !== state.filters.is_fork) {
                return false;
            }

            if (state.filters.is_archived !== undefined && repo.is_archived !== state.filters.is_archived) {
                return false;
            }

            return true;
        });
    });

    const repositoryStats = createMemo(() => {
        const repos = filteredRepositories();
        return {
            totalRepositories: repos.length,
            totalStars: repos.reduce((sum, repo) => sum + repo.stargazers_count, 0),
                                       totalForks: repos.reduce((sum, repo) => sum + repo.forks_count, 0),
                                       languages: [...new Set(repos.map(repo => repo.language).filter(Boolean))],
                                       mostStarredRepo: repos.reduce((max, repo) =>
                                       repo.stargazers_count > (max?.stargazers_count || 0) ? repo : max, null as Repository | null),
                                       recentlyUpdated: repos.filter(repo => {
                                           const daysSinceUpdate = (new Date().getTime() - new Date(repo.updated_at).getTime()) / (1000 * 60 * 60 * 24);
                                           return daysSinceUpdate <= 30;
                                       }).length,
                                       activeProjects: repos.filter(repo => !repo.is_archived && !repo.is_fork).length,
        };
    });

    // Rate limit status with warnings
    const rateLimitStatus = createMemo(() => {
        if (!state.rateLimit) return null;

        const { remaining, limit, percentage_used } = state.rateLimit;
        return {
            remaining,
            limit,
            percentage_used,
            status: percentage_used > 90 ? 'critical' : percentage_used > 70 ? 'warning' : 'ok',
            resetTime: new Date(state.rateLimit.reset_at),
        };
    });

    // Actions for state management
    const actions = {
        // Fetch repositories with optional filters
        async refreshRepositories(filters?: Partial<RepositoryFilter>) {
            if (filters) {
                setState('filters', produce(current => Object.assign(current, filters)));
            }
            setCacheTimestamp(Date.now());
        },

        // Navigate to specific page
        async goToPage(page: number) {
            if (page >= 1 && page <= state.totalPages) {
                setState('currentPage', page);
            }
        },

        // Fetch detailed repository information
        async getRepositoryDetails(owner: string, name: string): Promise<RepositoryDetailed | null> {
            try {
                setState('isLoading', true);

                const response = await fetch(`/api/github/repo/${owner}/${name}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data: RepositoryDetailed = await response.json();
                setState('selectedRepository', data);
                return data;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : 'Failed to fetch repository details';
                setState('error', errorMessage);
                return null;
            } finally {
                setState('isLoading', false);
            }
        },

        // Get repository statistics
        async getRepositoryStats(owner: string, name: string) {
            try {
                const response = await fetch(`/api/github/repo/${owner}/${name}/stats`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                return await response.json();
            } catch (error) {
                console.warn('Failed to fetch repository stats:', error);
                return null;
            }
        },

        // Update filters
        setFilters(newFilters: Partial<RepositoryFilter>) {
            setState('filters', produce(current => Object.assign(current, newFilters)));
            setState('currentPage', 1); // Reset to first page when filtering
            setCacheTimestamp(Date.now());
        },

        // Clear filters
        clearFilters() {
            setState('filters', {});
            setState('currentPage', 1);
            setCacheTimestamp(Date.now());
        },

        // Clear error state
        clearError() {
            setState('error', null);
        },

        // Set up auto-refresh
        startAutoRefresh(intervalMs: number = 300000) { // 5 minutes default
            const interval = setInterval(() => {
                setCacheTimestamp(Date.now());
            }, intervalMs);

            setRefreshInterval(interval);

            return () => {
                clearInterval(interval);
                setRefreshInterval(null);
            };
        },

        // Stop auto-refresh
        stopAutoRefresh() {
            const interval = refreshInterval();
            if (interval) {
                clearInterval(interval);
                setRefreshInterval(null);
            }
        },
    };

    // I'm setting up automatic cleanup for intervals
    onCleanup(() => {
        actions.stopAutoRefresh();
    });

    // I'm implementing reactive effects for enhanced UX
    createEffect(() => {
        // Log rate limit warnings
        const rateLimit = rateLimitStatus();
        if (rateLimit?.status === 'critical') {
            console.warn(`GitHub API rate limit critical: ${rateLimit.remaining}/${rateLimit.limit} remaining`);
        } else if (rateLimit?.status === 'warning') {
            console.warn(`GitHub API rate limit warning: ${rateLimit.remaining}/${rateLimit.limit} remaining`);
        }
    });

    // Helper functions for data transformation
    const utils = {
        // Format repository size for display
        formatSize(sizeKb: number): string {
            if (sizeKb < 1024) return `${sizeKb} KB`;
            const sizeMb = sizeKb / 1024;
            if (sizeMb < 1024) return `${sizeMb.toFixed(1)} MB`;
            const sizeGb = sizeMb / 1024;
            return `${sizeGb.toFixed(1)} GB`;
        },

        // Calculate repository activity score
        calculateActivityScore(repo: Repository): number {
            const daysSinceUpdate = (new Date().getTime() - new Date(repo.updated_at).getTime()) / (1000 * 60 * 60 * 24);
            const recentActivityBonus = daysSinceUpdate < 30 ? 20 : daysSinceUpdate < 90 ? 10 : 0;
            const starScore = Math.log(repo.stargazers_count + 1) * 5;
            const forkScore = Math.log(repo.forks_count + 1) * 3;
            const sizeScore = Math.min(Math.log(repo.size_kb + 1), 10);

            return Math.min(recentActivityBonus + starScore + forkScore + sizeScore, 100);
        },

        // Get repository health status
        getHealthStatus(repo: Repository): 'excellent' | 'good' | 'fair' | 'poor' {
            if (repo.is_archived) return 'poor';

            const hasDescription = !!repo.description;
            const hasTopics = repo.topics.length > 0;
            const hasLicense = !!repo.license_name;
            const isActive = (new Date().getTime() - new Date(repo.updated_at).getTime()) / (1000 * 60 * 60 * 24) < 90;

            const healthScore = [hasDescription, hasTopics, hasLicense, isActive].filter(Boolean).length;

            switch (healthScore) {
                case 4: return 'excellent';
                case 3: return 'good';
                case 2: return 'fair';
                default: return 'poor';
            }
        },

        // Format relative time
        formatRelativeTime(dateString: string): string {
            const date = new Date(dateString);
            const now = new Date();
            const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

            if (diffInSeconds < 60) return 'just now';
            if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)} minutes ago`;
            if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)} hours ago`;
            if (diffInSeconds < 604800) return `${Math.floor(diffInSeconds / 86400)} days ago`;
            if (diffInSeconds < 2629746) return `${Math.floor(diffInSeconds / 604800)} weeks ago`;
            if (diffInSeconds < 31556952) return `${Math.floor(diffInSeconds / 2629746)} months ago`;
            return `${Math.floor(diffInSeconds / 31556952)} years ago`;
        },

        // Get language color for visualization
        getLanguageColor(language: string): string {
            const colors: Record<string, string> = {
                'JavaScript': '#f1e05a',
                'TypeScript': '#2b7489',
                'Python': '#3572A5',
                'Java': '#b07219',
                'C++': '#f34b7d',
                'C': '#555555',
                'C#': '#239120',
                'PHP': '#4F5D95',
                'Ruby': '#701516',
                'Go': '#00ADD8',
                'Rust': '#dea584',
                'Swift': '#ffac45',
                'Kotlin': '#F18E33',
                'Scala': '#c22d40',
                'HTML': '#e34c26',
                'CSS': '#1572B6',
                'Shell': '#89e051',
            };
            return colors[language] || '#586069';
        },
    };

    return {
        // State
        repositories: () => filteredRepositories(),
        allRepositories: () => state.repositories,
        selectedRepository: () => state.selectedRepository,
        languageDistribution: () => state.languageDistribution,
        isLoading: () => state.isLoading,
        error: () => state.error,

        // Pagination
        currentPage: () => state.currentPage,
        totalPages: () => state.totalPages,
        totalCount: () => state.totalCount,
        hasNextPage: () => state.currentPage < state.totalPages,
        hasPreviousPage: () => state.currentPage > 1,

        // Filters and search
        filters: () => state.filters,

        // Computed values
        statistics: repositoryStats,
        rateLimit: rateLimitStatus,

        // Actions
        ...actions,

        // Utilities
        utils,

        // Resource states
        repositoriesResource: repositories,
        languageResource: languageData,
    };
}

export type { Repository, RepositoryDetailed, RepositoryFilter, RepositoryStats, LanguageDistribution };
</file>

<file path="src/hooks/usePerformance.ts">
/*
 * Performance monitoring hook providing reactive state management for real-time system metrics, benchmarks, and performance analysis throughout the application.
 * I'm implementing comprehensive performance tracking with WebSocket connections, historical data management, and intelligent alerting that integrates seamlessly with the dark aesthetic's focus on computational precision.
 */

import { createSignal, createResource, createMemo, createEffect, onMount, onCleanup } from 'solid-js';
import { createStore, produce } from 'solid-js/store';
import { performanceMonitor, performanceUtils } from '../utils/performance';

interface SystemMetrics {
  timestamp: string;
  cpu_usage_percent: number;
  memory_usage_percent: number;
  memory_total_gb: number;
  memory_available_gb: number;
  disk_usage_percent: number;
  load_average_1m: number;
  load_average_5m: number;
  load_average_15m: number;
  cpu_cores: number;
  cpu_threads: number;
  cpu_model: string;
  uptime_seconds: number;
  active_processes: number;
  network_rx_bytes_per_sec?: number;
  network_tx_bytes_per_sec?: number;
}

interface BenchmarkResult {
  benchmark_id: string;
  timestamp: string;
  total_duration_ms: number;
  benchmarks: {
    cpu: {
      single_thread: { duration_ms: number; primes_per_second: number };
      multi_thread: { duration_ms: number; primes_per_second: number };
      parallel_efficiency: number;
    };
    memory: {
      allocation: { duration_ms: number; mb_per_second: number };
      sequential_read: { duration_ms: number; mb_per_second: number };
      sequential_write: { duration_ms: number; mb_per_second: number };
    };
  };
  performance_rating: string;
  system_info: any;
}

interface Alert {
  id: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  timestamp: string;
  resolved: boolean;
  metric?: string;
  value?: number;
  threshold?: number;
}

interface PerformanceState {
  currentMetrics: SystemMetrics | null;
  benchmarkResults: BenchmarkResult | null;
  alerts: Alert[];
  isMonitoring: boolean;
  isRunningBenchmark: boolean;
  error: string | null;
  connectionStatus: 'connected' | 'disconnected' | 'reconnecting';
  metricsHistory: SystemMetrics[];
  webVitals: any;
}

export function usePerformance() {
  // I'm setting up comprehensive performance state management
  const [state, setState] = createStore<PerformanceState>({
    currentMetrics: null,
    benchmarkResults: null,
    alerts: [],
    isMonitoring: false,
    isRunningBenchmark: false,
    error: null,
    connectionStatus: 'disconnected',
    metricsHistory: [],
    webVitals: null,
  });

  // I'm implementing real-time metrics fetching
  const [metricsResource] = createResource(
    () => ({ monitoring: state.isMonitoring }),
    async () => {
      try {
        setState('error', null);
        
        const response = await fetch('/api/performance/system');
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: Failed to fetch system metrics`);
        }

        const metrics: SystemMetrics = await response.json();
        
        setState('currentMetrics', metrics);
        setState('connectionStatus', 'connected');
        
        // I'm updating metrics history
        setState('metricsHistory', produce(history => {
          history.push(metrics);
          // Keep only last 100 entries for performance
          if (history.length > 100) {
            history.shift();
          }
        }));

        // I'm checking for alerts
        checkForAlerts(metrics);

        return metrics;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Failed to fetch metrics';
        setState('error', errorMessage);
        setState('connectionStatus', 'disconnected');
        throw error;
      }
    }
  );

  // I'm implementing benchmark execution
  const [benchmarkResource] = createResource(
    () => ({ running: state.isRunningBenchmark }),
    async () => {
      if (!state.isRunningBenchmark) return null;

      try {
        setState('error', null);
        
        const response = await fetch('/api/performance/benchmark', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: Benchmark failed`);
        }

        const results: BenchmarkResult = await response.json();
        setState('benchmarkResults', results);
        return results;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Benchmark failed';
        setState('error', errorMessage);
        throw error;
      } finally {
        setState('isRunningBenchmark', false);
      }
    }
  );

  // I'm implementing periodic metrics collection
  let metricsInterval: number | null = null;
  let webVitalsInterval: number | null = null;

  onMount(() => {
    // I'm collecting initial Web Vitals
    collectWebVitals();

    // I'm setting up periodic Web Vitals collection
    webVitalsInterval = setInterval(collectWebVitals, 30000); // Every 30 seconds
  });

  onCleanup(() => {
    if (metricsInterval) clearInterval(metricsInterval);
    if (webVitalsInterval) clearInterval(webVitalsInterval);
  });

  // I'm implementing Web Vitals collection
  const collectWebVitals = async () => {
    try {
      const vitals = await performanceUtils.getWebVitals();
      setState('webVitals', vitals);
      
      // I'm adding Web Vitals to performance monitoring
      performanceMonitor.addMetric('web_vitals_fcp', vitals.fcp, 'ms', 'web_vitals');
      performanceMonitor.addMetric('web_vitals_lcp', vitals.lcp, 'ms', 'web_vitals');
      performanceMonitor.addMetric('web_vitals_fid', vitals.fid, 'ms', 'web_vitals');
      performanceMonitor.addMetric('web_vitals_cls', vitals.cls, 'score', 'web_vitals');
      performanceMonitor.addMetric('web_vitals_ttfb', vitals.ttfb, 'ms', 'web_vitals');
    } catch (error) {
      console.warn('Failed to collect Web Vitals:', error);
    }
  };

  // I'm implementing alert checking logic
  const checkForAlerts = (metrics: SystemMetrics) => {
    const newAlerts: Alert[] = [];

    // CPU usage alerts
    if (metrics.cpu_usage_percent > 90) {
      newAlerts.push({
        id: `cpu_high_${Date.now()}`,
        severity: 'critical',
        message: `CPU usage critically high: ${metrics.cpu_usage_percent.toFixed(1)}%`,
        timestamp: new Date().toISOString(),
        resolved: false,
        metric: 'cpu_usage_percent',
        value: metrics.cpu_usage_percent,
        threshold: 90
      });
    } else if (metrics.cpu_usage_percent > 75) {
      newAlerts.push({
        id: `cpu_warning_${Date.now()}`,
        severity: 'high',
        message: `CPU usage high: ${metrics.cpu_usage_percent.toFixed(1)}%`,
        timestamp: new Date().toISOString(),
        resolved: false,
        metric: 'cpu_usage_percent',
        value: metrics.cpu_usage_percent,
        threshold: 75
      });
    }

    // Memory usage alerts
    if (metrics.memory_usage_percent > 85) {
      newAlerts.push({
        id: `memory_high_${Date.now()}`,
        severity: 'critical',
        message: `Memory usage critically high: ${metrics.memory_usage_percent.toFixed(1)}%`,
        timestamp: new Date().toISOString(),
        resolved: false,
        metric: 'memory_usage_percent',
        value: metrics.memory_usage_percent,
        threshold: 85
      });
    } else if (metrics.memory_usage_percent > 70) {
      newAlerts.push({
        id: `memory_warning_${Date.now()}`,
        severity: 'medium',
        message: `Memory usage elevated: ${metrics.memory_usage_percent.toFixed(1)}%`,
        timestamp: new Date().toISOString(),
        resolved: false,
        metric: 'memory_usage_percent',
        value: metrics.memory_usage_percent,
        threshold: 70
      });
    }

    // Load average alerts
    if (metrics.load_average_1m > metrics.cpu_cores * 2) {
      newAlerts.push({
        id: `load_high_${Date.now()}`,
        severity: 'high',
        message: `Load average high: ${metrics.load_average_1m.toFixed(2)} (${metrics.cpu_cores} cores)`,
        timestamp: new Date().toISOString(),
        resolved: false,
        metric: 'load_average_1m',
        value: metrics.load_average_1m,
        threshold: metrics.cpu_cores * 2
      });
    }

    // I'm adding new alerts to the state
    if (newAlerts.length > 0) {
      setState('alerts', produce(alerts => {
        alerts.push(...newAlerts);
        // Keep only last 50 alerts
        if (alerts.length > 50) {
          alerts.splice(0, alerts.length - 50);
        }
      }));
    }
  };

  // I'm implementing computed values for enhanced analytics
  const performanceInsights = createMemo(() => {
    const metrics = state.currentMetrics;
    if (!metrics) return null;

    const cpuScore = Math.max(0, 100 - metrics.cpu_usage_percent);
    const memoryScore = Math.max(0, 100 - metrics.memory_usage_percent);
    const loadScore = Math.max(0, 100 - (metrics.load_average_1m / metrics.cpu_cores) * 50);
    
    const overallScore = (cpuScore + memoryScore + loadScore) / 3;
    
    let grade = 'F';
    if (overallScore >= 90) grade = 'A';
    else if (overallScore >= 80) grade = 'B';
    else if (overallScore >= 70) grade = 'C';
    else if (overallScore >= 60) grade = 'D';

    return {
      overallScore,
      grade,
      cpuScore,
      memoryScore,
      loadScore,
      recommendations: generateRecommendations(metrics)
    };
  });

  const metricsHistory = createMemo(() => {
    return state.metricsHistory.map(metrics => ({
      timestamp: metrics.timestamp,
      cpu: metrics.cpu_usage_percent,
      memory: metrics.memory_usage_percent,
      load: metrics.load_average_1m,
    }));
  });

  const activeAlerts = createMemo(() => {
    return state.alerts.filter(alert => !alert.resolved);
  });

  const criticalAlerts = createMemo(() => {
    return activeAlerts().filter(alert => alert.severity === 'critical');
  });

  // I'm implementing helper functions
  const generateRecommendations = (metrics: SystemMetrics): string[] => {
    const recommendations: string[] = [];

    if (metrics.cpu_usage_percent > 80) {
      recommendations.push('Consider optimizing CPU-intensive processes');
    }

    if (metrics.memory_usage_percent > 80) {
      recommendations.push('Review memory usage and consider cleanup');
    }

    if (metrics.load_average_1m > metrics.cpu_cores) {
      recommendations.push('System load is high - consider load balancing');
    }

    if (metrics.disk_usage_percent > 85) {
      recommendations.push('Disk space is running low - cleanup recommended');
    }

    return recommendations;
  };

  // I'm implementing actions for performance management
  const actions = {
    // Start/stop monitoring
    startMonitoring() {
      setState('isMonitoring', true);
      
      // I'm setting up periodic metrics collection
      metricsInterval = setInterval(() => {
        metricsResource.refetch();
      }, 5000); // Every 5 seconds
    },

    stopMonitoring() {
      setState('isMonitoring', false);
      
      if (metricsInterval) {
        clearInterval(metricsInterval);
        metricsInterval = null;
      }
    },

    // Run benchmark
    async runBenchmark() {
      setState('isRunningBenchmark', true);
      benchmarkResource.refetch();
    },

    // Refresh current metrics
    async refreshMetrics() {
      metricsResource.refetch();
    },

    // Clear error state
    clearError() {
      setState('error', null);
    },

    // Resolve alert
    resolveAlert(alertId: string) {
      setState('alerts', produce(alerts => {
        const alert = alerts.find(a => a.id === alertId);
        if (alert) {
          alert.resolved = true;
        }
      }));
    },

    // Clear all resolved alerts
    clearResolvedAlerts() {
      setState('alerts', produce(alerts => {
        const unresolved = alerts.filter(alert => !alert.resolved);
        alerts.length = 0;
        alerts.push(...unresolved);
      }));
    },

    // Get performance grade
    getPerformanceGrade() {
      return performanceUtils.getPerformanceGrade();
    },

    // Detect performance issues
    detectIssues() {
      return performanceUtils.detectPerformanceIssues();
    },

    // Export performance data
    exportData() {
      return {
        currentMetrics: state.currentMetrics,
        benchmarkResults: state.benchmarkResults,
        metricsHistory: state.metricsHistory,
        alerts: state.alerts,
        webVitals: state.webVitals,
        insights: performanceInsights(),
        exportedAt: new Date().toISOString()
      };
    },

    // Measure custom operation
    measureOperation<T>(name: string, operation: () => T): T {
      return performanceUtils.measure(name, operation);
    },

    // Measure async operation
    async measureAsyncOperation<T>(name: string, operation: () => Promise<T>): Promise<T> {
      return performanceUtils.measureAsync(name, operation);
    }
  };

  return {
    // State
    currentMetrics: () => state.currentMetrics,
    benchmarkResults: () => state.benchmarkResults,
    alerts: activeAlerts,
    criticalAlerts,
    isMonitoring: () => state.isMonitoring,
    isRunningBenchmark: () => state.isRunningBenchmark,
    error: () => state.error,
    connectionStatus: () => state.connectionStatus,
    webVitals: () => state.webVitals,

    // Computed values
    performanceInsights,
    metricsHistory,

    // Resources
    metricsResource,
    benchmarkResource,

    // Actions
    ...actions,

    // Utilities
    performanceMonitor,
    performanceUtils,
  };
}

export type { SystemMetrics, BenchmarkResult, Alert };
</file>

<file path="src/hooks/useWebVitals.ts">
/*
 * Web Vitals monitoring hook providing comprehensive performance tracking and real-time metrics collection for the performance showcase.
 * I'm implementing Core Web Vitals measurement, custom performance markers, and reactive state management that integrates with the application's performance analysis and dark theme presentation.
 */

import { createSignal, createEffect, onCleanup, onMount } from 'solid-js';

interface WebVitalsMetrics {
  // Core Web Vitals
  lcp: number | null; // Largest Contentful Paint
  fid: number | null; // First Input Delay
  cls: number | null; // Cumulative Layout Shift
  fcp: number | null; // First Contentful Paint
  ttfb: number | null; // Time to First Byte

  // Additional Performance Metrics
  domContentLoaded: number | null;
  loadComplete: number | null;
  firstPaint: number | null;
  navigationStart: number | null;

  // Custom Metrics
  timeToInteractive: number | null;
  totalBlockingTime: number | null;
  speedIndex: number | null;
}

interface PerformanceEntry {
  name: string;
  value: number;
  rating: 'good' | 'needs-improvement' | 'poor';
  timestamp: number;
}

interface WebVitalsConfig {
  enableReporting?: boolean;
  reportingEndpoint?: string;
  samplingRate?: number;
  debug?: boolean;
}

export function useWebVitals(config: WebVitalsConfig = {}) {
  // I'm setting up reactive signals for all metrics
  const [metrics, setMetrics] = createSignal<WebVitalsMetrics>({
    lcp: null,
    fid: null,
    cls: null,
    fcp: null,
    ttfb: null,
    domContentLoaded: null,
    loadComplete: null,
    firstPaint: null,
    navigationStart: null,
    timeToInteractive: null,
    totalBlockingTime: null,
    speedIndex: null,
  });

  const [performanceEntries, setPerformanceEntries] = createSignal<PerformanceEntry[]>([]);
  const [isLoading, setIsLoading] = createSignal(true);
  const [lastUpdate, setLastUpdate] = createSignal<Date>(new Date());

  // I'm implementing performance observer for modern metrics
  let performanceObserver: PerformanceObserver | null = null;
  let navigationObserver: PerformanceObserver | null = null;

  // I'm defining thresholds for rating performance metrics
  const getMetricRating = (metricName: string, value: number): 'good' | 'needs-improvement' | 'poor' => {
    const thresholds = {
      lcp: { good: 2500, poor: 4000 },
      fid: { good: 100, poor: 300 },
      cls: { good: 0.1, poor: 0.25 },
      fcp: { good: 1800, poor: 3000 },
      ttfb: { good: 800, poor: 1800 },
    };

    const threshold = thresholds[metricName as keyof typeof thresholds];
    if (!threshold) return 'good';

    if (value <= threshold.good) return 'good';
    if (value <= threshold.poor) return 'needs-improvement';
    return 'poor';
  };

  // I'm updating metrics and creating performance entries
  const updateMetric = (name: string, value: number) => {
    setMetrics(prev => ({
      ...prev,
      [name]: value
    }));

    const entry: PerformanceEntry = {
      name,
      value,
      rating: getMetricRating(name, value),
      timestamp: Date.now()
    };

    setPerformanceEntries(prev => [...prev, entry]);
    setLastUpdate(new Date());

    // I'm logging performance metrics in development
    if (config.debug || import.meta.env.DEV) {
      console.log(`[WebVitals] ${name}:`, value, `(${entry.rating})`);
    }

    // I'm reporting metrics if enabled
    if (config.enableReporting) {
      reportMetric(entry);
    }
  };

  // I'm implementing metric reporting to backend
  const reportMetric = async (entry: PerformanceEntry) => {
    if (!config.reportingEndpoint) return;

    // I'm implementing sampling to reduce server load
    if (config.samplingRate && Math.random() > config.samplingRate) return;

    try {
      await fetch(config.reportingEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          metric: entry,
          userAgent: navigator.userAgent,
          url: window.location.href,
          timestamp: entry.timestamp,
        }),
      });
    } catch (error) {
      if (config.debug) {
        console.warn('[WebVitals] Failed to report metric:', error);
      }
    }
  };

  // I'm collecting basic navigation and paint metrics
  const collectBasicMetrics = () => {
    if (!window.performance) return;

    const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
    const paintEntries = performance.getEntriesByType('paint');

    if (navigation) {
      updateMetric('navigationStart', navigation.navigationStart);
      updateMetric('domContentLoaded', navigation.domContentLoadedEventEnd - navigation.navigationStart);
      updateMetric('loadComplete', navigation.loadEventEnd - navigation.navigationStart);
      updateMetric('ttfb', navigation.responseStart - navigation.navigationStart);
    }

    // I'm collecting paint metrics
    paintEntries.forEach(entry => {
      if (entry.name === 'first-paint') {
        updateMetric('firstPaint', entry.startTime);
      }
      if (entry.name === 'first-contentful-paint') {
        updateMetric('fcp', entry.startTime);
      }
    });
  };

  // I'm setting up modern performance observers
  const setupPerformanceObservers = () => {
    if (!window.PerformanceObserver) return;

    // I'm observing layout shift for CLS
    try {
      performanceObserver = new PerformanceObserver((list) => {
        let clsValue = 0;
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'layout-shift' && !(entry as any).hadRecentInput) {
            clsValue += (entry as any).value;
          }
        }
        if (clsValue > 0) {
          updateMetric('cls', clsValue);
        }
      });
      performanceObserver.observe({ entryTypes: ['layout-shift'] });
    } catch (error) {
      if (config.debug) {
        console.warn('[WebVitals] Layout shift observer failed:', error);
      }
    }

    // I'm observing largest contentful paint
    try {
      const lcpObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        const lastEntry = entries[entries.length - 1];
        if (lastEntry && lastEntry.startTime) {
          updateMetric('lcp', lastEntry.startTime);
        }
      });
      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
    } catch (error) {
      if (config.debug) {
        console.warn('[WebVitals] LCP observer failed:', error);
      }
    }

    // I'm observing first input delay
    try {
      const fidObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          updateMetric('fid', (entry as any).processingStart - entry.startTime);
        }
      });
      fidObserver.observe({ entryTypes: ['first-input'] });
    } catch (error) {
      if (config.debug) {
        console.warn('[WebVitals] FID observer failed:', error);
      }
    }
  };

  // I'm calculating additional derived metrics
  const calculateDerivedMetrics = () => {
    const currentMetrics = metrics();

    // I'm estimating Time to Interactive
    if (currentMetrics.domContentLoaded && currentMetrics.loadComplete) {
      const tti = Math.max(currentMetrics.domContentLoaded, currentMetrics.loadComplete || 0);
      updateMetric('timeToInteractive', tti);
    }

    // I'm calculating total blocking time approximation
    if (currentMetrics.fcp && currentMetrics.timeToInteractive) {
      const tbt = Math.max(0, currentMetrics.timeToInteractive - currentMetrics.fcp);
      updateMetric('totalBlockingTime', tbt);
    }
  };

  // I'm setting up performance monitoring on component mount
  onMount(() => {
    // I'm collecting initial metrics
    collectBasicMetrics();

    // I'm setting up observers for real-time metrics
    setupPerformanceObservers();

    // I'm calculating derived metrics after a delay
    setTimeout(() => {
      calculateDerivedMetrics();
      setIsLoading(false);
    }, 1000);

    // I'm setting up periodic metric collection
    const intervalId = setInterval(() => {
      collectBasicMetrics();
      calculateDerivedMetrics();
    }, 5000);

    onCleanup(() => {
      clearInterval(intervalId);
      if (performanceObserver) {
        performanceObserver.disconnect();
      }
      if (navigationObserver) {
        navigationObserver.disconnect();
      }
    });
  });

  // I'm providing utility functions for metric analysis
  const getOverallScore = () => {
    const currentMetrics = metrics();
    const entries = performanceEntries();

    if (entries.length === 0) return null;

    const scores = {
      good: 100,
      'needs-improvement': 75,
      poor: 50
    };

    const totalScore = entries.reduce((sum, entry) => sum + scores[entry.rating], 0);
    return Math.round(totalScore / entries.length);
  };

  const getMetricsByCategory = () => {
    const entries = performanceEntries();
    return {
      good: entries.filter(e => e.rating === 'good').length,
      needsImprovement: entries.filter(e => e.rating === 'needs-improvement').length,
      poor: entries.filter(e => e.rating === 'poor').length,
    };
  };

  // I'm providing a performance summary for display
  const getPerformanceSummary = () => {
    const currentMetrics = metrics();
    const score = getOverallScore();
    const categories = getMetricsByCategory();

    return {
      score,
      categories,
      coreWebVitals: {
        lcp: currentMetrics.lcp,
        fid: currentMetrics.fid,
        cls: currentMetrics.cls,
      },
      loadingMetrics: {
        fcp: currentMetrics.fcp,
        ttfb: currentMetrics.ttfb,
        domContentLoaded: currentMetrics.domContentLoaded,
        loadComplete: currentMetrics.loadComplete,
      },
      customMetrics: {
        timeToInteractive: currentMetrics.timeToInteractive,
        totalBlockingTime: currentMetrics.totalBlockingTime,
      }
    };
  };

  // I'm implementing custom performance markers
  const mark = (name: string) => {
    if (!window.performance?.mark) return;
    performance.mark(name);
  };

  const measure = (name: string, startMark?: string, endMark?: string) => {
    if (!window.performance?.measure) return null;

    try {
      performance.measure(name, startMark, endMark);
      const entry = performance.getEntriesByName(name, 'measure')[0];
      return entry ? entry.duration : null;
    } catch (error) {
      if (config.debug) {
        console.warn('[WebVitals] Measure failed:', error);
      }
      return null;
    }
  };

  return {
    // Core metrics
    metrics,
    performanceEntries,
    isLoading,
    lastUpdate,

    // Utility functions
    getOverallScore,
    getMetricsByCategory,
    getPerformanceSummary,

    // Custom measurement tools
    mark,
    measure,

    // Manual metric updates
    updateMetric,
  };
}
</file>

<file path="src/pages/About.tsx">
/*
 * Comprehensive About page showcasing the technical architecture and philosophical foundations of the performance showcase application.
 * I'm implementing a deep dive into the system's design principles, technical stack, and existential contemplation of computational precision that aligns with the dark, eerie aesthetic.
 */

import { Component, createSignal, onMount, Show, For } from 'solid-js';

interface TechStackItem {
  category: string;
  technologies: Array<{
    name: string;
    version: string;
    purpose: string;
    why: string;
  }>;
}

interface ArchitecturalPrinciple {
  title: string;
  description: string;
  implementation: string;
}

export default function About(): Component {
  const [isVisible, setIsVisible] = createSignal(false);
  const [activeSection, setActiveSection] = createSignal('philosophy');

  // I'm defining the technical stack with philosophical context
  const techStack: TechStackItem[] = [
    {
      category: 'Backend Runtime',
      technologies: [
        {
          name: 'Rust',
          version: '1.75+',
          purpose: 'Core computational engine',
          why: 'Memory safety without garbage collection. Performance that approaches the machine itself.'
        },
        {
          name: 'Axum',
          version: '0.7',
          purpose: 'Async web framework',
          why: 'Built on Tokio. Ergonomic async handling that scales to thousands of concurrent connections.'
        },
        {
          name: 'Rayon',
          version: '1.8',
          purpose: 'Parallel computation',
          why: 'Data parallelism that harnesses every CPU core. Fractal generation at the speed of thought.'
        }
      ]
    },
    {
      category: 'Frontend Framework',
      technologies: [
        {
          name: 'SolidJS',
          version: '1.9',
          purpose: 'Reactive UI framework',
          why: 'Fine-grained reactivity. No virtual DOM overhead. Updates only what changes.'
        },
        {
          name: 'TypeScript',
          version: '5.x',
          purpose: 'Type safety',
          why: 'Compile-time certainty in an uncertain world. Catching errors before they become reality.'
        },
        {
          name: 'Tailwind CSS',
          version: '4.0',
          purpose: 'Utility-first styling',
          why: 'Atomic design principles. Every pixel deliberate, every spacing intentional.'
        }
      ]
    },
    {
      category: 'Data Layer',
      technologies: [
        {
          name: 'PostgreSQL',
          version: '15',
          purpose: 'Primary database',
          why: 'ACID compliance. Transactional integrity. Data that persists beyond the session.'
        },
        {
          name: 'Redis',
          version: '7',
          purpose: 'Cache and real-time data',
          why: 'In-memory speed. Sub-millisecond access. The bridge between computation and consciousness.'
        }
      ]
    }
  ];

  // I'm defining architectural principles that guide the system design
  const architecturalPrinciples: ArchitecturalPrinciple[] = [
    {
      title: 'Performance as Philosophy',
      description: 'Every millisecond matters. Not because users are impatient, but because computational efficiency is a meditation on precision itself.',
      implementation: 'Zero-copy data processing, compile-time optimizations, and parallel algorithms that scale with available hardware.'
    },
    {
      title: 'Deterministic Uncertainty',
      description: 'Fractal mathematics reveals infinite complexity through simple rules. Our code mirrors this: simple interfaces hiding sophisticated implementation.',
      implementation: 'Clean API boundaries, robust error handling, and mathematical precision in floating-point operations.'
    },
    {
      title: 'Reactive Minimalism',
      description: 'Update only what changes. Render only what matters. Every DOM manipulation justified by necessity.',
      implementation: 'Fine-grained reactivity, efficient reconciliation, and surgical updates to the visual representation.'
    },
    {
      title: 'Existential Debugging',
      description: 'Errors are not failures but revelations. Performance bottlenecks are not problems but opportunities for deeper understanding.',
      implementation: 'Comprehensive telemetry, real-time performance monitoring, and graceful degradation under load.'
    }
  ];

  onMount(() => {
    setTimeout(() => setIsVisible(true), 100);
  });

  return (
    <div class="min-h-screen bg-black text-neutral-100">
      {/* Atmospheric background */}
      <div class="absolute inset-0 opacity-5">
        <div class="absolute top-1/4 right-1/4 w-80 h-80 bg-indigo-900/20 rounded-full blur-3xl animate-pulse" style="animation-duration: 10s"></div>
        <div class="absolute bottom-1/3 left-1/5 w-64 h-64 bg-cyan-900/20 rounded-full blur-3xl animate-pulse" style="animation-duration: 8s; animation-delay: 2s"></div>
      </div>

      <div class={`relative z-10 transition-all duration-1000 ${isVisible() ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
        {/* Header Section */}
        <section class="container mx-auto px-6 pt-24 pb-12">
          <div class="max-w-4xl mx-auto text-center mb-16">
            <h1 class="text-5xl md:text-7xl font-thin tracking-wider mb-6 text-neutral-100">
              ARCHITECTURE
            </h1>
            <p class="text-lg text-neutral-400 max-w-3xl mx-auto leading-relaxed mb-8">
              A meditation on computational precision. Where every algorithm is a question posed to the machine,
              and every optimization a step deeper into the labyrinth of performance.
            </p>

            {/* Section Navigation */}
            <div class="flex flex-wrap justify-center gap-6 text-sm font-mono">
              {['philosophy', 'stack', 'principles', 'metrics'].map((section) => (
                <button
                  onClick={() => setActiveSection(section)}
                  class={`px-4 py-2 rounded-sm border transition-all duration-300 ${
                    activeSection() === section
                      ? 'border-neutral-300 bg-neutral-800 text-neutral-100'
                      : 'border-neutral-700 text-neutral-500 hover:text-neutral-300 hover:border-neutral-500'
                  }`}
                >
                  {section.toUpperCase()}
                </button>
              ))}
            </div>
          </div>
        </section>

        {/* Philosophy Section */}
        <Show when={activeSection() === 'philosophy'}>
          <section class="container mx-auto px-6 py-12">
            <div class="max-w-4xl mx-auto">
              <div class="grid md:grid-cols-2 gap-12 mb-16">
                <div class="space-y-8">
                  <div>
                    <h3 class="text-2xl font-thin text-neutral-200 mb-4">
                      ON COMPUTATIONAL PRECISION
                    </h3>
                    <p class="text-neutral-400 leading-relaxed">
                      This application exists as a proof of concept—not just of technical capability,
                      but of the philosophical intersection between human intention and machine execution.
                      Every fractal generated is a question about infinity. Every performance metric
                      a meditation on efficiency.
                    </p>
                  </div>

                  <div>
                    <h3 class="text-2xl font-thin text-neutral-200 mb-4">
                      THE AESTHETIC OF ALGORITHMS
                    </h3>
                    <p class="text-neutral-400 leading-relaxed">
                      We chose darkness not for drama, but for honesty. The black background eliminates
                      distractions, focusing attention on the essential: the data, the patterns,
                      the emergent beauty of mathematical visualization. Like staring into the void
                      until the void computes back.
                    </p>
                  </div>
                </div>

                <div class="space-y-8">
                  <div>
                    <h3 class="text-2xl font-thin text-neutral-200 mb-4">
                      PERFORMANCE AS POETRY
                    </h3>
                    <p class="text-neutral-400 leading-relaxed">
                      Each millisecond shaved from computation time is not merely optimization—it's
                      approaching something closer to the speed of thought itself. We measure not
                      just throughput, but the elegance of execution. The grace with which silicon
                      and software dance together.
                    </p>
                  </div>

                  <div>
                    <h3 class="text-2xl font-thin text-neutral-200 mb-4">
                      TOOLS AS PHILOSOPHY
                    </h3>
                    <p class="text-neutral-400 leading-relaxed">
                      Rust for memory safety without compromise. SolidJS for reactive precision.
                      PostgreSQL for transactional truth. Each tool chosen not for popularity,
                      but for its philosophical alignment with our core belief: that performance
                      and correctness are not optimizations, but fundamental requirements.
                    </p>
                  </div>
                </div>
              </div>

              <blockquote class="text-center text-xl md:text-2xl font-thin text-neutral-400 italic border-l-2 border-neutral-700 pl-6 max-w-3xl mx-auto">
                "In the precision of algorithms, we find not answers, but the quality of our questions.
                Each optimization strips away another layer of assumption, revealing the mathematical
                truth beneath."
              </blockquote>
            </div>
          </section>
        </Show>

        {/* Technical Stack Section */}
        <Show when={activeSection() === 'stack'}>
          <section class="container mx-auto px-6 py-12">
            <div class="max-w-6xl mx-auto">
              <div class="text-center mb-12">
                <h2 class="text-3xl font-thin text-neutral-200 mb-4">
                  TECHNICAL FOUNDATION
                </h2>
                <p class="text-neutral-500 max-w-2xl mx-auto">
                  Every dependency chosen with intention. Every abstraction justified by necessity.
                </p>
              </div>

              <div class="space-y-12">
                <For each={techStack}>
                  {(category) => (
                    <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-8">
                      <h3 class="text-xl font-mono text-neutral-300 mb-6 text-center">
                        {category.category.toUpperCase()}
                      </h3>

                      <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <For each={category.technologies}>
                          {(tech) => (
                            <div class="bg-black/30 border border-neutral-700 rounded-sm p-6 hover:border-neutral-600 transition-colors duration-300">
                              <div class="flex items-center justify-between mb-3">
                                <h4 class="font-mono text-lg text-neutral-100">
                                  {tech.name}
                                </h4>
                                <span class="text-xs bg-neutral-800 text-neutral-400 px-2 py-1 rounded font-mono">
                                  {tech.version}
                                </span>
                              </div>

                              <p class="text-sm text-neutral-400 mb-3">
                                {tech.purpose}
                              </p>

                              <p class="text-xs text-neutral-500 italic leading-relaxed">
                                {tech.why}
                              </p>
                            </div>
                          )}
                        </For>
                      </div>
                    </div>
                  )}
                </For>
              </div>
            </div>
          </section>
        </Show>

        {/* Architectural Principles Section */}
        <Show when={activeSection() === 'principles'}>
          <section class="container mx-auto px-6 py-12">
            <div class="max-w-4xl mx-auto">
              <div class="text-center mb-12">
                <h2 class="text-3xl font-thin text-neutral-200 mb-4">
                  DESIGN PRINCIPLES
                </h2>
                <p class="text-neutral-500 max-w-2xl mx-auto">
                  The philosophical foundations that guide every architectural decision.
                </p>
              </div>

              <div class="space-y-8">
                <For each={architecturalPrinciples}>
                  {(principle) => (
                    <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-8 hover:border-neutral-700 transition-colors duration-300">
                      <h3 class="text-xl font-mono text-neutral-200 mb-4">
                        {principle.title}
                      </h3>

                      <p class="text-neutral-400 leading-relaxed mb-6">
                        {principle.description}
                      </p>

                      <div class="border-l-2 border-neutral-700 pl-4">
                        <p class="text-sm text-neutral-500 italic">
                          Implementation: {principle.implementation}
                        </p>
                      </div>
                    </div>
                  )}
                </For>
              </div>
            </div>
          </section>
        </Show>

        {/* Metrics Section */}
        <Show when={activeSection() === 'metrics'}>
          <section class="container mx-auto px-6 py-12">
            <div class="max-w-4xl mx-auto">
              <div class="text-center mb-12">
                <h2 class="text-3xl font-thin text-neutral-200 mb-4">
                  PERFORMANCE PHILOSOPHY
                </h2>
                <p class="text-neutral-500 max-w-2xl mx-auto">
                  What we measure and why it matters in the grand scheme of computational existence.
                </p>
              </div>

              <div class="grid md:grid-cols-2 gap-8">
                <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                  <h3 class="text-lg font-mono text-neutral-300 mb-4">FRACTAL GENERATION</h3>
                  <div class="space-y-3 text-sm">
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Target Speed:</span>
                      <span class="text-neutral-300 font-mono">&lt; 50ms</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Parallel Efficiency:</span>
                      <span class="text-neutral-300 font-mono">&gt; 85%</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Memory Usage:</span>
                      <span class="text-neutral-300 font-mono">Minimal</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Precision:</span>
                      <span class="text-neutral-300 font-mono">IEEE 754</span>
                    </div>
                  </div>
                </div>

                <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                  <h3 class="text-lg font-mono text-neutral-300 mb-4">API RESPONSE</h3>
                  <div class="space-y-3 text-sm">
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Response Time:</span>
                      <span class="text-neutral-300 font-mono">&lt; 10ms</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Throughput:</span>
                      <span class="text-neutral-300 font-mono">10k+ req/s</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Memory Safety:</span>
                      <span class="text-neutral-300 font-mono">Guaranteed</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Concurrency:</span>
                      <span class="text-neutral-300 font-mono">Async/Await</span>
                    </div>
                  </div>
                </div>

                <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                  <h3 class="text-lg font-mono text-neutral-300 mb-4">FRONTEND REACTIVITY</h3>
                  <div class="space-y-3 text-sm">
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Update Efficiency:</span>
                      <span class="text-neutral-300 font-mono">Surgical</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Bundle Size:</span>
                      <span class="text-neutral-300 font-mono">Minimal</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Reactivity:</span>
                      <span class="text-neutral-300 font-mono">Fine-grained</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Runtime:</span>
                      <span class="text-neutral-300 font-mono">No vDOM</span>
                    </div>
                  </div>
                </div>

                <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                  <h3 class="text-lg font-mono text-neutral-300 mb-4">SYSTEM RESOURCES</h3>
                  <div class="space-y-3 text-sm">
                    <div class="flex justify-between">
                      <span class="text-neutral-500">CPU Usage:</span>
                      <span class="text-neutral-300 font-mono">Optimized</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Memory Leaks:</span>
                      <span class="text-neutral-300 font-mono">Impossible</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Cache Hit Rate:</span>
                      <span class="text-neutral-300 font-mono">&gt; 95%</span>
                    </div>
                    <div class="flex justify-between">
                      <span class="text-neutral-500">Uptime:</span>
                      <span class="text-neutral-300 font-mono">99.9%+</span>
                    </div>
                  </div>
                </div>
              </div>

              <div class="mt-12 text-center">
                <p class="text-neutral-500 italic max-w-2xl mx-auto">
                  "Performance is not about making things faster. It's about understanding the relationship
                  between intention and execution, between the theoretical and the practical,
                  between what we want to achieve and what the machine can deliver."
                </p>
              </div>
            </div>
          </section>
        </Show>

        {/* Closing Statement */}
        <section class="container mx-auto px-6 py-20">
          <div class="max-w-3xl mx-auto text-center">
            <h2 class="text-3xl font-thin text-neutral-200 mb-8">
              THE INTERSECTION OF CODE AND CONSCIOUSNESS
            </h2>
            <p class="text-lg text-neutral-400 leading-relaxed mb-8">
              This application is more than a technical demonstration. It's an exploration of the liminal space
              between human creativity and machine precision. Every optimization is a conversation with the hardware.
              Every algorithm is a question posed to the universe about the nature of computation itself.
            </p>
            <p class="text-neutral-500 italic">
              Built with precision. Powered by curiosity. Optimized for the inevitable.
            </p>
          </div>
        </section>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/Home.tsx">
import { Component, onMount } from 'solid-js';

const HomePageContent: Component = () => {
  onMount(() => {
    console.log("pages/Home.tsx (HomePageContent) onMount CALLED - FileRoutes Target");
  });
  console.log("pages/Home.tsx (HomePageContent) COMPONENT FUNCTION EXECUTED - FileRoutes Target");
  return (
    <div style="background-color: #00695c; color: white; padding: 40px; font-size: 28px; border: 2px solid #ffeb3b;">
      HOME PAGE CONTENT (Rendered by FileRoutes into App.tsx Router's root)
    </div>
  );
};
export default HomePageContent;
</file>

<file path="src/pages/Performance.tsx">
/*
 * Performance demonstration page showcasing real-time metrics, fractal computation, and system benchmarks with live updates and interactive controls.
 * I'm integrating all performance monitoring components, fractal rendering, and benchmark execution into a comprehensive showcase that demonstrates the system's computational capabilities.
 */

import { Component, createSignal, createEffect, onMount, onCleanup, Show, For } from 'solid-js';
import { FractalCanvas } from '../components/Fractals/FractalCanvas';
import { performanceService, SystemMetrics, Alert } from '../services/performance';
import { fractalService, BenchmarkResult } from '../services/fractals';

interface PerformanceTab {
  id: string;
  label: string;
  description: string;
}

interface ChartDataPoint {
  timestamp: string;
  value: number;
}

export default function Performance(): Component {
  const [isVisible, setIsVisible] = createSignal(false);
  const [activeTab, setActiveTab] = createSignal('overview');
  const [systemMetrics, setSystemMetrics] = createSignal<SystemMetrics | null>(null);
  const [benchmarkResults, setBenchmarkResults] = createSignal<BenchmarkResult | null>(null);
  const [alerts, setAlerts] = createSignal<Alert[]>([]);
  const [isRunningBenchmark, setIsRunningBenchmark] = createSignal(false);
  const [cpuHistory, setCpuHistory] = createSignal<ChartDataPoint[]>([]);
  const [memoryHistory, setMemoryHistory] = createSignal<ChartDataPoint[]>([]);
  const [fractalMetrics, setFractalMetrics] = createSignal<any>(null);

  // I'm defining the performance tabs for organized content presentation
  const performanceTabs: PerformanceTab[] = [
    {
      id: 'overview',
      label: 'OVERVIEW',
      description: 'Real-time system metrics and health status'
    },
    {
      id: 'fractal',
      label: 'FRACTAL ENGINE',
      description: 'Interactive mathematical computation showcase'
    },
    {
      id: 'benchmarks',
      label: 'BENCHMARKS',
      description: 'Comprehensive performance testing and comparison'
    },
    {
      id: 'analytics',
      label: 'ANALYTICS',
      description: 'Historical performance analysis and trends'
    }
  ];

  let performanceSubscription: (() => void) | null = null;
  let alertSubscription: (() => void) | null = null;
  let metricsInterval: number | null = null;

  onMount(() => {
    // I'm setting up entrance animation
    setTimeout(() => setIsVisible(true), 100);

    // I'm initializing real-time performance monitoring
    initializePerformanceMonitoring();
    
    // I'm fetching initial data
    loadInitialData();
  });

  onCleanup(() => {
    // I'm cleaning up subscriptions and intervals
    if (performanceSubscription) performanceSubscription();
    if (alertSubscription) alertSubscription();
    if (metricsInterval) clearInterval(metricsInterval);
  });

  const initializePerformanceMonitoring = () => {
    // I'm subscribing to real-time performance updates
    performanceSubscription = performanceService.subscribe('metrics', (metrics: SystemMetrics) => {
      setSystemMetrics(metrics);
      updateHistoricalData(metrics);
    });

    // I'm subscribing to alert notifications
    alertSubscription = performanceService.subscribe('alert', (alert: Alert) => {
      setAlerts(prev => [...prev, alert]);
    });

    // I'm setting up periodic metrics fetching as fallback
    metricsInterval = setInterval(async () => {
      try {
        const snapshot = await performanceService.getCurrentMetrics();
        setSystemMetrics(snapshot.system);
        updateHistoricalData(snapshot.system);
      } catch (error) {
        console.warn('Failed to fetch metrics:', error);
      }
    }, 5000);
  };

  const updateHistoricalData = (metrics: SystemMetrics) => {
    const timestamp = new Date().toISOString();
    
    // I'm maintaining historical data for charts
    setCpuHistory(prev => {
      const updated = [...prev, { timestamp, value: metrics.cpu_usage_percent }];
      return updated.slice(-50); // Keep last 50 points
    });

    setMemoryHistory(prev => {
      const updated = [...prev, { timestamp, value: metrics.memory_usage_percent }];
      return updated.slice(-50); // Keep last 50 points
    });
  };

  const loadInitialData = async () => {
    try {
      // I'm loading system information and initial metrics
      const [snapshot, systemInfo] = await Promise.all([
        performanceService.getCurrentMetrics(),
        performanceService.getSystemInfo(),
      ]);

      setSystemMetrics(snapshot.system);
      
      // I'm initializing historical data
      const now = new Date().toISOString();
      setCpuHistory([{ timestamp: now, value: snapshot.system.cpu_usage_percent }]);
      setMemoryHistory([{ timestamp: now, value: snapshot.system.memory_usage_percent }]);

    } catch (error) {
      console.error('Failed to load initial performance data:', error);
    }
  };

  const runBenchmark = async () => {
    setIsRunningBenchmark(true);
    try {
      const results = await performanceService.runBenchmark();
      setBenchmarkResults(results);
    } catch (error) {
      console.error('Benchmark failed:', error);
    } finally {
      setIsRunningBenchmark(false);
    }
  };

  const handleFractalPerformanceUpdate = (metrics: any) => {
    setFractalMetrics(metrics);
  };

  const getPerformanceRating = (value: number, thresholds: { excellent: number; good: number; fair: number }) => {
    if (value <= thresholds.excellent) return { rating: 'EXCELLENT', color: 'text-green-400' };
    if (value <= thresholds.good) return { rating: 'GOOD', color: 'text-blue-400' };
    if (value <= thresholds.fair) return { rating: 'FAIR', color: 'text-yellow-400' };
    return { rating: 'NEEDS ATTENTION', color: 'text-red-400' };
  };

  const formatUptime = (seconds: number): string => {
    const days = Math.floor(seconds / 86400);
    const hours = Math.floor((seconds % 86400) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    
    if (days > 0) return `${days}d ${hours}h`;
    if (hours > 0) return `${hours}h ${minutes}m`;
    return `${minutes}m`;
  };

  return (
    <div class="min-h-screen bg-black text-neutral-100">
      {/* Atmospheric background */}
      <div class="absolute inset-0 opacity-5">
        <div class="absolute top-1/4 left-1/3 w-96 h-96 bg-cyan-900/10 rounded-full blur-3xl animate-pulse" style="animation-duration: 8s"></div>
        <div class="absolute bottom-1/3 right-1/4 w-64 h-64 bg-purple-900/10 rounded-full blur-3xl animate-pulse" style="animation-duration: 12s; animation-delay: 4s"></div>
      </div>

      <div class={`relative z-10 transition-all duration-1000 ${isVisible() ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
        {/* Header Section */}
        <section class="container mx-auto px-6 pt-24 pb-8">
          <div class="max-w-6xl mx-auto text-center mb-8">
            <h1 class="text-5xl md:text-7xl font-thin tracking-wider mb-6 text-neutral-100">
              PERFORMANCE
            </h1>
            <p class="text-lg text-neutral-400 max-w-3xl mx-auto leading-relaxed">
              Real-time computational analysis. Where mathematics meets machine precision,
              and every calculation becomes a meditation on the nature of computational efficiency.
            </p>
          </div>

          {/* System Status Overview */}
          <Show when={systemMetrics()}>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
              <div class="bg-neutral-900/30 border border-neutral-800 rounded-sm p-4 text-center">
                <div class="text-2xl font-mono text-neutral-100 mb-1">
                  {systemMetrics()!.cpu_usage_percent.toFixed(1)}%
                </div>
                <div class="text-xs text-neutral-500 tracking-wide">CPU USAGE</div>
                <div class={`text-xs mt-1 ${getPerformanceRating(systemMetrics()!.cpu_usage_percent, { excellent: 50, good: 70, fair: 85 }).color}`}>
                  {getPerformanceRating(systemMetrics()!.cpu_usage_percent, { excellent: 50, good: 70, fair: 85 }).rating}
                </div>
              </div>

              <div class="bg-neutral-900/30 border border-neutral-800 rounded-sm p-4 text-center">
                <div class="text-2xl font-mono text-neutral-100 mb-1">
                  {systemMetrics()!.memory_usage_percent.toFixed(1)}%
                </div>
                <div class="text-xs text-neutral-500 tracking-wide">MEMORY</div>
                <div class={`text-xs mt-1 ${getPerformanceRating(systemMetrics()!.memory_usage_percent, { excellent: 60, good: 75, fair: 85 }).color}`}>
                  {getPerformanceRating(systemMetrics()!.memory_usage_percent, { excellent: 60, good: 75, fair: 85 }).rating}
                </div>
              </div>

              <div class="bg-neutral-900/30 border border-neutral-800 rounded-sm p-4 text-center">
                <div class="text-2xl font-mono text-neutral-100 mb-1">
                  {systemMetrics()!.load_average_1m.toFixed(2)}
                </div>
                <div class="text-xs text-neutral-500 tracking-wide">LOAD AVG</div>
                <div class="text-xs text-neutral-400 mt-1">
                  {systemMetrics()!.cpu_cores} CORES
                </div>
              </div>

              <div class="bg-neutral-900/30 border border-neutral-800 rounded-sm p-4 text-center">
                <div class="text-2xl font-mono text-neutral-100 mb-1">
                  {formatUptime(systemMetrics()!.uptime_seconds)}
                </div>
                <div class="text-xs text-neutral-500 tracking-wide">UPTIME</div>
                <div class="text-xs text-green-400 mt-1">STABLE</div>
              </div>
            </div>
          </Show>

          {/* Active Alerts */}
          <Show when={alerts().length > 0}>
            <div class="mb-8">
              <div class="bg-red-900/20 border border-red-800 rounded-lg p-4">
                <div class="text-red-400 font-mono text-sm mb-3">ACTIVE ALERTS ({alerts().length})</div>
                <div class="space-y-2">
                  <For each={alerts().slice(0, 3)}>
                    {(alert) => (
                      <div class="flex items-center justify-between text-sm">
                        <span class="text-neutral-300">{alert.message}</span>
                        <span class={`text-xs px-2 py-1 rounded-sm ${
                          alert.severity === 'critical' ? 'bg-red-900 text-red-300' :
                          alert.severity === 'high' ? 'bg-orange-900 text-orange-300' :
                          alert.severity === 'medium' ? 'bg-yellow-900 text-yellow-300' :
                          'bg-blue-900 text-blue-300'
                        }`}>
                          {alert.severity.toUpperCase()}
                        </span>
                      </div>
                    )}
                  </For>
                </div>
              </div>
            </div>
          </Show>
        </section>

        {/* Performance Tabs */}
        <section class="container mx-auto px-6 mb-8">
          <div class="bg-neutral-900/20 border border-neutral-800 rounded-lg">
            <div class="flex flex-wrap border-b border-neutral-800">
              <For each={performanceTabs}>
                {(tab) => (
                  <button
                    onClick={() => setActiveTab(tab.id)}
                    class={`px-6 py-4 text-sm font-mono tracking-wide transition-colors duration-200 border-b-2 ${
                      activeTab() === tab.id
                        ? 'border-neutral-300 text-neutral-100 bg-neutral-800/30'
                        : 'border-transparent text-neutral-500 hover:text-neutral-300 hover:bg-neutral-800/10'
                    }`}
                  >
                    <div>{tab.label}</div>
                    <div class="text-xs text-neutral-600 mt-1 font-normal">{tab.description}</div>
                  </button>
                )}
              </For>
            </div>

            <div class="p-6">
              {/* Overview Tab */}
              <Show when={activeTab() === 'overview'}>
                <div class="space-y-8">
                  {/* Real-time Charts */}
                  <div class="grid md:grid-cols-2 gap-6">
                    <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                      <h3 class="text-lg font-mono text-neutral-300 mb-4">CPU USAGE HISTORY</h3>
                      <div class="h-48 relative">
                        <Show when={cpuHistory().length > 1}>
                          <svg class="w-full h-full">
                            <polyline
                              fill="none"
                              stroke="#22d3ee"
                              stroke-width="2"
                              points={cpuHistory().map((point, index) => {
                                const x = (index / (cpuHistory().length - 1)) * 100;
                                const y = 100 - point.value;
                                return `${x}%,${y}%`;
                              }).join(' ')}
                            />
                          </svg>
                        </Show>
                        <div class="absolute inset-0 flex items-center justify-center text-neutral-600">
                          <Show when={cpuHistory().length <= 1}>
                            Collecting data...
                          </Show>
                        </div>
                      </div>
                    </div>

                    <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                      <h3 class="text-lg font-mono text-neutral-300 mb-4">MEMORY USAGE HISTORY</h3>
                      <div class="h-48 relative">
                        <Show when={memoryHistory().length > 1}>
                          <svg class="w-full h-full">
                            <polyline
                              fill="none"
                              stroke="#a855f7"
                              stroke-width="2"
                              points={memoryHistory().map((point, index) => {
                                const x = (index / (memoryHistory().length - 1)) * 100;
                                const y = 100 - point.value;
                                return `${x}%,${y}%`;
                              }).join(' ')}
                            />
                          </svg>
                        </Show>
                        <div class="absolute inset-0 flex items-center justify-center text-neutral-600">
                          <Show when={memoryHistory().length <= 1}>
                            Collecting data...
                          </Show>
                        </div>
                      </div>
                    </div>
                  </div>

                  {/* System Information */}
                  <Show when={systemMetrics()}>
                    <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                      <h3 class="text-lg font-mono text-neutral-300 mb-4">SYSTEM CONFIGURATION</h3>
                      <div class="grid md:grid-cols-3 gap-6 text-sm">
                        <div>
                          <div class="text-neutral-500 mb-2">PROCESSOR</div>
                          <div class="text-neutral-300 font-mono">{systemMetrics()!.cpu_model}</div>
                          <div class="text-neutral-500 text-xs mt-1">
                            {systemMetrics()!.cpu_cores} cores, {systemMetrics()!.cpu_threads} threads
                          </div>
                        </div>
                        <div>
                          <div class="text-neutral-500 mb-2">MEMORY</div>
                          <div class="text-neutral-300 font-mono">{systemMetrics()!.memory_total_gb.toFixed(1)} GB</div>
                          <div class="text-neutral-500 text-xs mt-1">
                            {systemMetrics()!.memory_available_gb.toFixed(1)} GB available
                          </div>
                        </div>
                        <div>
                          <div class="text-neutral-500 mb-2">PROCESSES</div>
                          <div class="text-neutral-300 font-mono">{systemMetrics()!.active_processes}</div>
                          <div class="text-neutral-500 text-xs mt-1">
                            Active system processes
                          </div>
                        </div>
                      </div>
                    </div>
                  </Show>
                </div>
              </Show>

              {/* Fractal Engine Tab */}
              <Show when={activeTab() === 'fractal'}>
                <div class="space-y-8">
                  <div class="text-center mb-8">
                    <h3 class="text-2xl font-thin text-neutral-200 mb-4">
                      MATHEMATICAL COMPUTATION ENGINE
                    </h3>
                    <p class="text-neutral-500 max-w-2xl mx-auto">
                      Real-time fractal generation showcasing parallel processing capabilities.
                      Each pixel calculated in parallel, demonstrating computational efficiency.
                    </p>
                  </div>

                  <div class="max-w-4xl mx-auto">
                    <FractalCanvas
                      width={800}
                      height={500}
                      onPerformanceUpdate={handleFractalPerformanceUpdate}
                    />
                  </div>

                  <Show when={fractalMetrics()}>
                    <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                      <h4 class="text-lg font-mono text-neutral-300 mb-4">COMPUTATION METRICS</h4>
                      <div class="grid md:grid-cols-4 gap-6 text-sm">
                        <div class="text-center">
                          <div class="text-2xl font-mono text-green-400 mb-1">
                            {fractalMetrics().computationTime}ms
                          </div>
                          <div class="text-neutral-500">Backend Processing</div>
                        </div>
                        <div class="text-center">
                          <div class="text-2xl font-mono text-cyan-400 mb-1">
                            {Math.round(fractalMetrics().pixelsPerSecond).toLocaleString()}
                          </div>
                          <div class="text-neutral-500">Pixels/Second</div>
                        </div>
                        <div class="text-center">
                          <div class="text-2xl font-mono text-purple-400 mb-1">
                            {fractalMetrics().zoomLevel.toExponential(2)}
                          </div>
                          <div class="text-neutral-500">Zoom Level</div>
                        </div>
                        <div class="text-center">
                          <div class="text-2xl font-mono text-yellow-400 mb-1">
                            {Math.round(fractalMetrics().totalTime)}ms
                          </div>
                          <div class="text-neutral-500">Total Time</div>
                        </div>
                      </div>
                    </div>
                  </Show>
                </div>
              </Show>

              {/* Benchmarks Tab */}
              <Show when={activeTab() === 'benchmarks'}>
                <div class="space-y-8">
                  <div class="text-center mb-8">
                    <h3 class="text-2xl font-thin text-neutral-200 mb-4">
                      PERFORMANCE BENCHMARKS
                    </h3>
                    <p class="text-neutral-500 max-w-2xl mx-auto mb-6">
                      Comprehensive performance testing across CPU, memory, and mathematical computation.
                      Results demonstrate system capabilities under various workloads.
                    </p>
                    
                    <button
                      onClick={runBenchmark}
                      disabled={isRunningBenchmark()}
                      class={`px-8 py-3 rounded-sm font-mono text-sm tracking-wide transition-all duration-300 ${
                        isRunningBenchmark()
                          ? 'bg-neutral-700 text-neutral-500 cursor-not-allowed'
                          : 'bg-neutral-100 text-black hover:bg-neutral-200'
                      }`}
                    >
                      {isRunningBenchmark() ? 'RUNNING BENCHMARK...' : 'RUN COMPREHENSIVE BENCHMARK'}
                    </button>
                  </div>

                  <Show when={isRunningBenchmark()}>
                    <div class="text-center py-12">
                      <div class="w-16 h-16 border-2 border-neutral-600 border-t-neutral-300 rounded-full animate-spin mx-auto mb-4"></div>
                      <div class="text-neutral-400 font-mono text-sm">
                        Executing performance tests...
                      </div>
                      <div class="text-neutral-600 text-xs mt-2">
                        This may take up to 2 minutes
                      </div>
                    </div>
                  </Show>

                  <Show when={benchmarkResults()}>
                    <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                      <h4 class="text-lg font-mono text-neutral-300 mb-6">BENCHMARK RESULTS</h4>
                      
                      <div class="grid md:grid-cols-2 gap-6 mb-6">
                        <div>
                          <div class="text-neutral-400 text-sm mb-3">CPU PERFORMANCE</div>
                          <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                              <span class="text-neutral-500">Single Thread:</span>
                              <span class="text-neutral-300 font-mono">
                                {benchmarkResults()!.benchmarks.cpu.single_thread?.duration_ms}ms
                              </span>
                            </div>
                            <div class="flex justify-between">
                              <span class="text-neutral-500">Multi Thread:</span>
                              <span class="text-neutral-300 font-mono">
                                {benchmarkResults()!.benchmarks.cpu.multi_thread?.duration_ms}ms
                              </span>
                            </div>
                            <div class="flex justify-between">
                              <span class="text-neutral-500">Efficiency:</span>
                              <span class="text-green-400 font-mono">
                                {(benchmarkResults()!.benchmarks.cpu.parallel_efficiency * 100).toFixed(1)}%
                              </span>
                            </div>
                          </div>
                        </div>

                        <div>
                          <div class="text-neutral-400 text-sm mb-3">MEMORY PERFORMANCE</div>
                          <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                              <span class="text-neutral-500">Read Speed:</span>
                              <span class="text-neutral-300 font-mono">
                                {benchmarkResults()!.benchmarks.memory.sequential_read?.mb_per_second.toFixed(0)} MB/s
                              </span>
                            </div>
                            <div class="flex justify-between">
                              <span class="text-neutral-500">Write Speed:</span>
                              <span class="text-neutral-300 font-mono">
                                {benchmarkResults()!.benchmarks.memory.sequential_write?.mb_per_second.toFixed(0)} MB/s
                              </span>
                            </div>
                            <div class="flex justify-between">
                              <span class="text-neutral-500">Allocation:</span>
                              <span class="text-cyan-400 font-mono">
                                {benchmarkResults()!.benchmarks.memory.allocation?.mb_per_second.toFixed(0)} MB/s
                              </span>
                            </div>
                          </div>
                        </div>
                      </div>

                      <div class="text-center p-4 bg-neutral-800/30 rounded-sm">
                        <div class="text-neutral-400 text-sm mb-2">OVERALL PERFORMANCE RATING</div>
                        <div class="text-2xl font-mono text-green-400">
                          {benchmarkResults()!.performance_rating}
                        </div>
                      </div>
                    </div>
                  </Show>
                </div>
              </Show>

              {/* Analytics Tab */}
              <Show when={activeTab() === 'analytics'}>
                <div class="space-y-8">
                  <div class="text-center mb-8">
                    <h3 class="text-2xl font-thin text-neutral-200 mb-4">
                      PERFORMANCE ANALYTICS
                    </h3>
                    <p class="text-neutral-500 max-w-2xl mx-auto">
                      Historical performance analysis and trend identification.
                      Data-driven insights into system behavior and optimization opportunities.
                    </p>
                  </div>

                  <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6">
                    <div class="text-center text-neutral-500 py-12">
                      <div class="text-6xl mb-4">📊</div>
                      <div class="text-lg mb-2">Advanced Analytics</div>
                      <div class="text-sm">
                        Historical data analysis and trend visualization will be available
                        as the system continues to collect performance metrics.
                      </div>
                    </div>
                  </div>
                </div>
              </Show>
            </div>
          </div>
        </section>

        {/* Footer Message */}
        <section class="container mx-auto px-6 py-12 text-center">
          <blockquote class="text-xl md:text-2xl font-thin text-neutral-400 leading-relaxed italic max-w-3xl mx-auto">
            "Performance is not just about speed—it's about the elegant dance between
            precision and efficiency, where every millisecond matters and every optimization
            reveals deeper truths about the nature of computation itself."
          </blockquote>
        </section>
      </div>
    </div>
  );
}
</file>

<file path="src/pages/Projects.tsx">
/*
 * Projects showcase page displaying GitHub repositories with sophisticated filtering and dark aesthetic presentation.
 * I'm implementing a comprehensive repository browser that embodies the contemplative, eerie theme while providing powerful functionality.
 */

import { Component, createSignal, createMemo, Show, For, onMount } from 'solid-js';
import { useGitHub, Repository } from '../hooks/useGitHub';

export default function Projects(): Component {
  const github = useGitHub();
  const [searchTerm, setSearchTerm] = createSignal('');
  const [selectedLanguage, setSelectedLanguage] = createSignal<string>('');
  const [sortBy, setSortBy] = createSignal<string>('updated');
  const [viewMode, setViewMode] = createSignal<'grid' | 'list'>('grid');
  const [showArchived, setShowArchived] = createSignal(false);
  const [isVisible, setIsVisible] = createSignal(false);

  // I'm implementing sophisticated filtering logic for repository discovery
  const filteredRepositories = createMemo(() => {
    let repos = github.repositories();
    
    // Apply search filter
    const search = searchTerm().toLowerCase();
    if (search) {
      repos = repos.filter(repo => 
        repo.name.toLowerCase().includes(search) ||
        (repo.description && repo.description.toLowerCase().includes(search)) ||
        repo.topics.some(topic => topic.toLowerCase().includes(search))
      );
    }
    
    // Apply language filter
    const language = selectedLanguage();
    if (language && language !== 'all') {
      repos = repos.filter(repo => repo.language === language);
    }
    
    // Apply archived filter
    if (!showArchived()) {
      repos = repos.filter(repo => !repo.is_archived);
    }
    
    // Apply sorting
    const sort = sortBy();
    repos.sort((a, b) => {
      switch (sort) {
        case 'name':
          return a.name.localeCompare(b.name);
        case 'stars':
          return b.stargazers_count - a.stargazers_count;
        case 'forks':
          return b.forks_count - a.forks_count;
        case 'updated':
          return new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime();
        case 'created':
          return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
        case 'size':
          return b.size_kb - a.size_kb;
        default:
          return 0;
      }
    });
    
    return repos;
  });

  // Get unique languages for filter dropdown
  const availableLanguages = createMemo(() => {
    const languages = new Set<string>();
    github.allRepositories().forEach(repo => {
      if (repo.language) {
        languages.add(repo.language);
      }
    });
    return Array.from(languages).sort();
  });

  onMount(() => {
    // I'm triggering the initial data fetch
    github.refreshRepositories();
    
    // Entrance animation
    setTimeout(() => setIsVisible(true), 100);
  });

  const getLanguageColor = (language: string): string => {
    return github.utils.getLanguageColor(language);
  };

  const formatRelativeTime = (dateString: string): string => {
    return github.utils.formatRelativeTime(dateString);
  };

  const formatSize = (sizeKb: number): string => {
    return github.utils.formatSize(sizeKb);
  };

  const getHealthStatus = (repo: Repository): string => {
    return github.utils.getHealthStatus(repo);
  };

  const getActivityScore = (repo: Repository): number => {
    return github.utils.calculateActivityScore(repo);
  };

  return (
    <div class="min-h-screen bg-black text-neutral-100">
      {/* Atmospheric background */}
      <div class="absolute inset-0 opacity-10">
        <div class="absolute top-1/3 left-1/6 w-64 h-64 bg-blue-900/20 rounded-full blur-3xl animate-pulse" style="animation-duration: 8s"></div>
        <div class="absolute bottom-1/3 right-1/6 w-48 h-48 bg-purple-900/20 rounded-full blur-3xl animate-pulse" style="animation-duration: 12s; animation-delay: 4s"></div>
      </div>

      <div class={`relative z-10 transition-all duration-1000 ${isVisible() ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-4'}`}>
        {/* Header Section */}
        <section class="container mx-auto px-6 pt-24 pb-12">
          <div class="max-w-4xl mx-auto text-center mb-12">
            <h1 class="text-5xl md:text-7xl font-thin tracking-wider mb-6 text-neutral-100">
              REPOSITORIES
            </h1>
            <p class="text-lg text-neutral-400 max-w-2xl mx-auto leading-relaxed">
              Digital artifacts of computational exploration. Each repository a question posed to the void, 
              each commit a step deeper into the labyrinth of logic.
            </p>
          </div>

          {/* Statistics Bar */}
          <Show when={github.statistics()}>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-12">
              <div class="bg-neutral-900/30 border border-neutral-800 rounded-sm p-4 text-center">
                <div class="text-2xl font-mono text-neutral-100 mb-1">
                  {github.statistics().totalRepositories}
                </div>
                <div class="text-xs text-neutral-500 tracking-wide">REPOSITORIES</div>
              </div>
              
              <div class="bg-neutral-900/30 border border-neutral-800 rounded-sm p-4 text-center">
                <div class="text-2xl font-mono text-neutral-100 mb-1">
                  {github.statistics().totalStars}
                </div>
                <div class="text-xs text-neutral-500 tracking-wide">TOTAL STARS</div>
              </div>
              
              <div class="bg-neutral-900/30 border border-neutral-800 rounded-sm p-4 text-center">
                <div class="text-2xl font-mono text-neutral-100 mb-1">
                  {github.statistics().languages.length}
                </div>
                <div class="text-xs text-neutral-500 tracking-wide">LANGUAGES</div>
              </div>
              
              <div class="bg-neutral-900/30 border border-neutral-800 rounded-sm p-4 text-center">
                <div class="text-2xl font-mono text-neutral-100 mb-1">
                  {github.statistics().activeProjects}
                </div>
                <div class="text-xs text-neutral-500 tracking-wide">ACTIVE</div>
              </div>
            </div>
          </Show>
        </section>

        {/* Filters and Controls */}
        <section class="container mx-auto px-6 mb-8">
          <div class="bg-neutral-900/20 border border-neutral-800 rounded-lg p-6 backdrop-blur-sm">
            <div class="grid md:grid-cols-4 gap-4 mb-4">
              {/* Search */}
              <div class="md:col-span-2">
                <input
                  type="text"
                  placeholder="Search repositories, descriptions, topics..."
                  value={searchTerm()}
                  onInput={(e) => setSearchTerm(e.currentTarget.value)}
                  class="w-full bg-black/50 border border-neutral-700 rounded-sm px-4 py-2 text-neutral-100 placeholder-neutral-600 focus:border-neutral-500 focus:outline-none font-mono text-sm"
                />
              </div>

              {/* Language Filter */}
              <div>
                <select
                  value={selectedLanguage()}
                  onChange={(e) => setSelectedLanguage(e.currentTarget.value)}
                  class="w-full bg-black/50 border border-neutral-700 rounded-sm px-4 py-2 text-neutral-100 focus:border-neutral-500 focus:outline-none font-mono text-sm"
                >
                  <option value="">All Languages</option>
                  <For each={availableLanguages()}>
                    {(language) => (
                      <option value={language}>{language}</option>
                    )}
                  </For>
                </select>
              </div>

              {/* Sort */}
              <div>
                <select
                  value={sortBy()}
                  onChange={(e) => setSortBy(e.currentTarget.value)}
                  class="w-full bg-black/50 border border-neutral-700 rounded-sm px-4 py-2 text-neutral-100 focus:border-neutral-500 focus:outline-none font-mono text-sm"
                >
                  <option value="updated">Recently Updated</option>
                  <option value="created">Recently Created</option>
                  <option value="stars">Most Stars</option>
                  <option value="forks">Most Forks</option>
                  <option value="name">Name</option>
                  <option value="size">Size</option>
                </select>
              </div>
            </div>

            <div class="flex justify-between items-center">
              <div class="flex items-center gap-4">
                <label class="flex items-center gap-2 text-sm text-neutral-400 cursor-pointer">
                  <input
                    type="checkbox"
                    checked={showArchived()}
                    onChange={(e) => setShowArchived(e.currentTarget.checked)}
                    class="w-4 h-4 bg-black border border-neutral-600 rounded text-neutral-100 focus:ring-0"
                  />
                  Include archived
                </label>

                <div class="text-xs text-neutral-600 font-mono">
                  {filteredRepositories().length} repositories
                </div>
              </div>

              <div class="flex items-center gap-2">
                <button
                  onClick={() => setViewMode('grid')}
                  class={`p-2 rounded-sm border transition-colors duration-200 ${
                    viewMode() === 'grid' 
                      ? 'border-neutral-500 bg-neutral-800 text-neutral-100' 
                      : 'border-neutral-700 text-neutral-500 hover:text-neutral-300'
                  }`}
                >
                  <div class="w-4 h-4 grid grid-cols-2 gap-0.5">
                    <div class="bg-current rounded-sm"></div>
                    <div class="bg-current rounded-sm"></div>
                    <div class="bg-current rounded-sm"></div>
                    <div class="bg-current rounded-sm"></div>
                  </div>
                </button>
                
                <button
                  onClick={() => setViewMode('list')}
                  class={`p-2 rounded-sm border transition-colors duration-200 ${
                    viewMode() === 'list' 
                      ? 'border-neutral-500 bg-neutral-800 text-neutral-100' 
                      : 'border-neutral-700 text-neutral-500 hover:text-neutral-300'
                  }`}
                >
                  <div class="w-4 h-4 flex flex-col gap-1">
                    <div class="h-0.5 bg-current rounded-sm"></div>
                    <div class="h-0.5 bg-current rounded-sm"></div>
                    <div class="h-0.5 bg-current rounded-sm"></div>
                  </div>
                </button>
              </div>
            </div>
          </div>
        </section>

        {/* Loading State */}
        <Show when={github.isLoading()}>
          <div class="container mx-auto px-6 py-20 text-center">
            <div class="w-16 h-16 border-2 border-neutral-600 border-t-neutral-300 rounded-full animate-spin mx-auto mb-4"></div>
            <div class="text-neutral-500 font-mono text-sm">
              Retrieving digital artifacts...
            </div>
          </div>
        </Show>

        {/* Error State */}
        <Show when={github.error()}>
          <div class="container mx-auto px-6 py-20 text-center">
            <div class="bg-red-900/20 border border-red-800 rounded-lg p-8 max-w-md mx-auto">
              <div class="text-red-400 font-mono text-lg mb-2">ERROR</div>
              <div class="text-neutral-300 text-sm mb-4">{github.error()}</div>
              <button
                onClick={() => github.refreshRepositories()}
                class="bg-red-800 hover:bg-red-700 text-white px-4 py-2 rounded-sm font-mono text-sm transition-colors duration-200"
              >
                RETRY
              </button>
            </div>
          </div>
        </Show>

        {/* Repositories Display */}
        <section class="container mx-auto px-6 pb-20">
          <Show when={!github.isLoading() && !github.error()}>
            <Show when={filteredRepositories().length > 0} fallback={
              <div class="text-center py-20">
                <div class="text-neutral-500 font-mono text-lg mb-4">
                  No repositories found matching your criteria.
                </div>
                <div class="text-neutral-600 text-sm">
                  Try adjusting your filters or search terms.
                </div>
              </div>
            }>
              <div class={viewMode() === 'grid' 
                ? 'grid md:grid-cols-2 lg:grid-cols-3 gap-6'
                : 'space-y-4'
              }>
                <For each={filteredRepositories()}>
                  {(repo) => (
                    <RepositoryCard 
                      repository={repo} 
                      viewMode={viewMode()}
                      onSelect={() => github.getRepositoryDetails(repo.owner, repo.name)}
                    />
                  )}
                </For>
              </div>
            </Show>
          </Show>
        </section>

        {/* Rate Limit Warning */}
        <Show when={github.rateLimit()?.status === 'warning' || github.rateLimit()?.status === 'critical'}>
          <div class="fixed bottom-4 right-4 bg-yellow-900/90 border border-yellow-700 rounded-lg p-4 max-w-sm backdrop-blur-sm">
            <div class="text-yellow-400 font-mono text-sm mb-2">
              API RATE LIMIT {github.rateLimit()?.status.toUpperCase()}
            </div>
            <div class="text-neutral-300 text-xs">
              {github.rateLimit()?.remaining} / {github.rateLimit()?.limit} requests remaining
            </div>
          </div>
        </Show>
      </div>
    </div>
  );
}

// Repository Card Component
interface RepositoryCardProps {
  repository: Repository;
  viewMode: 'grid' | 'list';
  onSelect: () => void;
}

const RepositoryCard: Component<RepositoryCardProps> = (props) => {
  const repo = () => props.repository;
  const github = useGitHub();

  const healthStatus = () => github.utils.getHealthStatus(repo());
  const activityScore = () => github.utils.calculateActivityScore(repo());
  const languageColor = () => repo().language ? github.utils.getLanguageColor(repo().language) : '#586069';

  const healthColors = {
    excellent: 'text-green-400',
    good: 'text-blue-400',
    fair: 'text-yellow-400',
    poor: 'text-red-400',
  };

  if (props.viewMode === 'list') {
    return (
      <div class="bg-neutral-900/30 border border-neutral-800 rounded-sm p-4 hover:border-neutral-700 transition-all duration-300 cursor-pointer"
           onClick={props.onSelect}>
        <div class="flex items-start justify-between">
          <div class="flex-1">
            <div class="flex items-center gap-3 mb-2">
              <h3 class="font-mono text-lg text-neutral-100 hover:text-white transition-colors">
                {repo().name}
              </h3>
              <Show when={repo().is_private}>
                <span class="text-xs px-2 py-1 bg-yellow-900/30 text-yellow-400 border border-yellow-800 rounded-sm font-mono">
                  PRIVATE
                </span>
              </Show>
              <Show when={repo().is_archived}>
                <span class="text-xs px-2 py-1 bg-neutral-800 text-neutral-500 border border-neutral-700 rounded-sm font-mono">
                  ARCHIVED
                </span>
              </Show>
            </div>
            
            <Show when={repo().description}>
              <p class="text-neutral-400 text-sm mb-3 line-clamp-2">
                {repo().description}
              </p>
            </Show>
            
            <div class="flex items-center gap-4 text-xs text-neutral-500">
              <Show when={repo().language}>
                <div class="flex items-center gap-1">
                  <div class="w-3 h-3 rounded-full" style={`background-color: ${languageColor()}`}></div>
                  <span>{repo().language}</span>
                </div>
              </Show>
              
              <Show when={repo().stargazers_count > 0}>
                <div class="flex items-center gap-1">
                  <span>⭐</span>
                  <span>{repo().stargazers_count}</span>
                </div>
              </Show>
              
              <Show when={repo().forks_count > 0}>
                <div class="flex items-center gap-1">
                  <span>🍴</span>
                  <span>{repo().forks_count}</span>
                </div>
              </Show>
              
              <span>Updated {github.utils.formatRelativeTime(repo().updated_at)}</span>
            </div>
          </div>
          
          <div class="flex flex-col items-end gap-2">
            <div class={`text-xs font-mono ${healthColors[healthStatus()]}`}>
              {healthStatus().toUpperCase()}
            </div>
            <div class="text-xs text-neutral-600 font-mono">
              {github.utils.formatSize(repo().size_kb)}
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div class="bg-neutral-900/30 border border-neutral-800 rounded-lg p-6 hover:border-neutral-700 transition-all duration-300 cursor-pointer group"
         onClick={props.onSelect}>
      <div class="flex items-start justify-between mb-4">
        <h3 class="font-mono text-xl text-neutral-100 group-hover:text-white transition-colors truncate">
          {repo().name}
        </h3>
        <div class="flex gap-2">
          <Show when={repo().is_private}>
            <div class="w-2 h-2 bg-yellow-500 rounded-full"></div>
          </Show>
          <Show when={repo().is_archived}>
            <div class="w-2 h-2 bg-neutral-600 rounded-full"></div>
          </Show>
        </div>
      </div>
      
      <Show when={repo().description}>
        <p class="text-neutral-400 text-sm mb-4 line-clamp-3 leading-relaxed">
          {repo().description}
        </p>
      </Show>
      
      <div class="flex items-center gap-3 mb-4 text-xs">
        <Show when={repo().language}>
          <div class="flex items-center gap-1">
            <div class="w-2 h-2 rounded-full" style={`background-color: ${languageColor()}`}></div>
            <span class="text-neutral-500">{repo().language}</span>
          </div>
        </Show>
        
        <Show when={repo().stargazers_count > 0}>
          <div class="flex items-center gap-1 text-neutral-500">
            <span>⭐</span>
            <span>{repo().stargazers_count}</span>
          </div>
        </Show>
        
        <Show when={repo().forks_count > 0}>
          <div class="flex items-center gap-1 text-neutral-500">
            <span>🍴</span>
            <span>{repo().forks_count}</span>
          </div>
        </Show>
      </div>
      
      <div class="flex items-center justify-between">
        <div class="text-xs text-neutral-600">
          Updated {github.utils.formatRelativeTime(repo().updated_at)}
        </div>
        
        <div class="flex items-center gap-3">
          <div class={`text-xs font-mono ${healthColors[healthStatus()]}`}>
            {healthStatus().toUpperCase()}
          </div>
          <div class="text-xs text-neutral-600 font-mono">
            {github.utils.formatSize(repo().size_kb)}
          </div>
        </div>
      </div>
      
      <Show when={repo().topics.length > 0}>
        <div class="flex flex-wrap gap-1 mt-3">
          <For each={repo().topics.slice(0, 3)}>
            {(topic) => (
              <span class="text-xs px-2 py-1 bg-neutral-800/50 text-neutral-400 rounded-sm font-mono">
                {topic}
              </span>
            )}
          </For>
          <Show when={repo().topics.length > 3}>
            <span class="text-xs px-2 py-1 text-neutral-600 font-mono">
              +{repo().topics.length - 3}
            </span>
          </Show>
        </div>
      </Show>
    </div>
  );
};
</file>

<file path="src/routes/_layout.tsx">
// src/routes/_layout.tsx
import { Component, JSX, createSignal, onMount, Show, createEffect } from 'solid-js';
import { isServer } from "solid-js/web";
import { Meta, Title } from "@solidjs/meta"; // For setting title/meta within this layout

import { Header } from '../components/Layout/Header'; // Adjust path if needed
import { Footer } from '../components/Layout/Footer'; // Adjust path if needed
import { ErrorBoundary as CustomErrorBoundary } from '../components/UI/ErrorBoundary'; // Your custom UI ErrorBoundary
import { performanceMonitor } from '../utils/performance';

interface LayoutFileProps {
  children: JSX.Element;
  // Props like title, description are typically handled by individual route components
  // using <Title> and <Meta> from @solidjs/meta
}

const RootLayout: Component<LayoutFileProps> = (props) => {
  const [isLoaded, setIsLoaded] = createSignal(false);
  const [scrollY, setScrollY] = createSignal(0);
  const [isOnline, setIsOnline] = createSignal(isServer ? true : navigator.onLine);

  onMount(() => {
    setIsOnline(navigator.onLine);
    const stopLayoutMeasure = performanceMonitor.time('layout_mount_from_routes');

    const handleScroll = () => setScrollY(window.scrollY);
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('scroll', handleScroll, { passive: true });
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    setTimeout(() => {
      setIsLoaded(true);
      stopLayoutMeasure();
      console.log("[_layout.tsx] Layout onMount and visual shell loading complete.");
    }, 100);

    return () => {
      window.removeEventListener('scroll', handleScroll);
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  });

  // Parallax effect, guarded for SSR
  const parallaxOffset = () => (isServer ? 0 : scrollY() * 0.1);

  return (
    // The MetaProvider is in app.tsx. Individual pages or this layout can set Title/Meta.
    // Example:
    // <Title>Default Layout Title | Performance Showcase</Title>
    // <Meta name="description" content="Default layout description." />
    <>
      {/* This div becomes the main page wrapper, replacing the one from your old Layout.tsx */}
      <div class={`min-h-screen bg-black text-neutral-100 relative overflow-x-hidden`}>
        {/* Atmospheric Background Elements */}
        <div class="fixed inset-0 pointer-events-none">
          <div
            class="absolute inset-0 opacity-[0.02]"
            style={{
              background: `radial-gradient(circle at 50% ${50 + parallaxOffset()}%, rgba(34, 211, 238, 0.1) 0%, transparent 50%)`,
            }}
          ></div>
          <div
            class="absolute inset-0 opacity-[0.03]"
            style={{
              "background-image": `linear-gradient(rgba(34, 211, 238, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(34, 211, 238, 0.1) 1px, transparent 1px)`,
              "background-size": "50px 50px",
              transform: `translateY(${parallaxOffset()}px)`
            }}
          ></div>
          <Show when={!isServer}>
            <div class="absolute inset-0">
              {Array.from({ length: 20 }, (_, i) => (
                <div
                  class="absolute w-1 h-1 bg-cyan-400/20 rounded-full animate-pulse"
                  style={{
                    left: `${Math.random() * 100}%`,
                    top: `${Math.random() * 100}%`,
                    'animation-delay': `${Math.random() * 10}s`,
                    'animation-duration': `${3 + Math.random() * 4}s`,
                    transform: `translateY(${parallaxOffset() * (1 + Math.random())}px)`
                  }}
                ></div>
              ))}
            </div>
          </Show>
        </div>

        <Show when={!isServer && !isOnline()}>
          <div class="fixed top-0 left-0 right-0 bg-red-900/90 text-red-100 text-center py-2 text-sm font-mono z-50">
            <span class="animate-pulse">●</span> OFFLINE MODE - Limited functionality available
          </div>
        </Show>

        <div class={`relative z-10 flex flex-col min-h-screen transition-opacity duration-1000 ${isLoaded() ? 'opacity-100' : 'opacity-0'}`}>
          <CustomErrorBoundary context="Header in _layout">
            <Header />
          </CustomErrorBoundary>

          <main class={`flex-1 relative container mx-auto`}> {/* Assuming default is container, adjust if needed */}
            <CustomErrorBoundary context="Page Content in _layout" level="page">
              {props.children} {/* This is where the specific route component (e.g., IndexRoute) will be rendered */}
            </CustomErrorBoundary>
          </main>

          <CustomErrorBoundary context="Footer in _layout">
            <Footer />
          </CustomErrorBoundary>
        </div>

        <Show when={!isServer && !isLoaded()}>
          <div class="fixed inset-0 bg-black z-[1000] flex items-center justify-center"> {/* Increased z-index */}
            <div class="text-center">
              <div class="w-16 h-16 border-2 border-cyan-400 border-t-transparent rounded-full animate-spin mb-4"></div>
              <div class="text-cyan-400 font-mono text-sm tracking-wider">
                INITIALIZING PERFORMANCE SHOWCASE
              </div>
              <div class="text-neutral-600 font-mono text-xs mt-2">
                Loading computational precision...
              </div>
            </div>
          </div>
        </Show>

        <Show when={!isServer}>
          <div class="fixed top-0 left-0 right-0 h-0.5 bg-neutral-900 z-40">
            <div
              class="h-full bg-gradient-to-r from-cyan-400 to-indigo-400 transition-all duration-100 ease-out"
              style={{
                width: `${Math.min(100, (scrollY() / (document.documentElement.scrollHeight - window.innerHeight)) * 100)}%`
              }}
            ></div>
          </div>
        </Show>

        <Show when={!isServer && import.meta.env.DEV}>
          <PerformanceDebugPanel /> {/* Definition of this component is below */}
        </Show>
      </div>
    </>
  );
};

export default RootLayout; // Default export is crucial for _layout.tsx

// PerformanceDebugPanel can be defined here or imported if it's complex
const PerformanceDebugPanel: Component = () => {
  const [isOpen, setIsOpen] = createSignal(false);
  const [metrics, setMetrics] = createSignal<any>({});

  onMount(() => {
    if (isServer) return;
    const updateMetrics = () => {
      const memoryUsage = performanceMonitor.getMemoryUsage();
      const recentMetrics = performanceMonitor.getMetrics({ limit: 10 });
      setMetrics({
        memory: memoryUsage,
        recentMetrics: recentMetrics.slice(-5),
        timestamp: Date.now()
      });
    };
    updateMetrics();
    const interval = setInterval(updateMetrics, 1000);
    return () => clearInterval(interval);
  });

  return (
    <div class="fixed bottom-4 right-4 z-[1100]"> {/* Ensure high z-index */}
      <button
        onClick={() => setIsOpen(!isOpen())}
        class="bg-neutral-900/90 border border-neutral-700 text-neutral-400 p-2 rounded-full hover:bg-neutral-800 transition-colors duration-200"
        title="Performance Debug Panel"
      >
        📊
      </button>
      <Show when={isOpen()}>
        <div class="absolute bottom-12 right-0 w-80 bg-black/95 border border-neutral-700 rounded-lg p-4 text-sm font-mono">
          <div class="text-cyan-400 font-semibold mb-3">Performance Debug</div>
          <Show when={metrics().memory}>
            <div class="mb-3">
              <div class="text-neutral-500 text-xs">Memory Usage</div>
              <div class="text-neutral-300">
                {(metrics().memory.usedJSHeapSize / 1024 / 1024).toFixed(1)} MB
              </div>
              <div class="text-neutral-500 text-xs">
                {metrics().memory.usage_percentage?.toFixed(1)}% of limit
              </div>
            </div>
          </Show>
          <div class="mb-3">
            <div class="text-neutral-500 text-xs mb-1">Recent Metrics</div>
            <div class="space-y-1">
              <Show when={Array.isArray(metrics().recentMetrics)}>
                {metrics().recentMetrics.map((metric: any) => (
                  <div class="flex justify-between text-xs">
                    <span class="text-neutral-400 truncate">{metric.name}</span>
                    <span class="text-neutral-300">
                      {typeof metric.value === 'number' ? metric.value.toFixed(1) : 'N/A'}
                      {metric.unit}
                    </span>
                  </div>
                ))}
              </Show>
            </div>
          </div>
          <div class="flex justify-between text-xs">
            <button onClick={() => performanceMonitor.getSnapshot()} class="text-cyan-400 hover:text-cyan-300">Snapshot</button>
            <button onClick={() => console.log('Performance Metrics:', performanceMonitor.getMetrics())} class="text-cyan-400 hover:text-cyan-300">Log All</button>
          </div>
        </div>
      </Show>
    </div>
  );
};
</file>

<file path="src/routes/[...404].tsx">
// src/routes/[...404].tsx (Temporary Simplification)
import { Component } from 'solid-js';
import { Title } from "@solidjs/meta";

const MinimalNotFound: Component = () => {
  return (
    <>
      <Title>404 - Page Not Found</Title>
      <div>
        <h1>404 - Page Not Found</h1>
        <p>The requested page could not be found.</p>
      </div>
    </>
  );
};

export default MinimalNotFound;
</file>

<file path="src/routes/index.tsx">
/*
 * Index route component serving as the home page for the performance showcase application.
 * This file uses SolidStart's file-based routing where routes/index.tsx maps to the "/" path.
 */

import { Component } from 'solid-js';
import Home from '../pages/Home';

const IndexRoute: Component = () => {
  console.log("[routes/index.tsx] ROUTE COMPONENT EXECUTED!");
  return <Home />;
};

export default IndexRoute;
</file>

<file path="src/routes/performance.tsx ">
/*
 * Performance route component for displaying system metrics and benchmarks.
 * This file maps to the "/performance" path in SolidStart's file-based routing system.
 */

import { Component } from 'solid-js';
import Performance from '../pages/Performance';

const PerformanceRoute: Component = () => {
  return <Performance />;
};

export default PerformanceRoute;
</file>

<file path="src/routes/projects.tsx">
/*
 * Projects route component for displaying GitHub repositories.
 * This file maps to the "/projects" path in SolidStart's file-based routing system.
 */

import { Component } from 'solid-js';
import Projects from '../pages/Projects';

const ProjectsRoute: Component = () => {
  return <Projects />;
};

export default ProjectsRoute;
</file>

<file path="src/services/api.ts">
/*
 * Core API service providing robust HTTP client configuration and error handling for all backend communication.
 * I'm implementing comprehensive request/response interceptors, retry logic, and performance monitoring for reliable API integration across the application.
 */

interface ApiResponse<T> {
    data: T;
    timestamp: string;
    status: number;
}

interface ApiError {
    code: string;
    message: string;
    details?: any;
    timestamp: string;
}

interface RequestConfig {
    timeout?: number;
    retries?: number;
    retryDelay?: number;
    skipCache?: boolean;
    requireAuth?: boolean;
}

class ApiClient {
    private baseURL: string;
    private defaultTimeout: number;
    private requestInterceptors: ((config: RequestInit) => RequestInit)[];
    private responseInterceptors: ((response: Response) => Promise<Response>)[];

    constructor() {
        // I'm setting up the base configuration from the environment
        this.baseURL = import.meta.env.VITE_API_URL || 'http://localhost:3001';
        this.defaultTimeout = 30000; // 30 seconds default timeout
        this.requestInterceptors = [];
        this.responseInterceptors = [];

        // Set up default interceptors
        this.setupDefaultInterceptors();
    }

    private setupDefaultInterceptors() {
        // I'm adding request timing and correlation ID tracking
        this.addRequestInterceptor((config: RequestInit) => {
            const correlationId = crypto.randomUUID();

            return {
                ...config,
                headers: {
                    'Content-Type': 'application/json',
                    'X-Correlation-ID': correlationId,
                    'X-Request-Start': Date.now().toString(),
                                   ...config.headers,
                },
            };
        });

        // I'm adding response timing and error standardization
        this.addResponseInterceptor(async (response: Response) => {
            const requestStart = response.headers.get('X-Request-Start');
            if (requestStart) {
                const duration = Date.now() - parseInt(requestStart);
                console.debug(`API Request completed in ${duration}ms`, {
                    url: response.url,
                    status: response.status,
                    duration,
                });
            }

            return response;
        });
    }

    addRequestInterceptor(interceptor: (config: RequestInit) => RequestInit) {
        this.requestInterceptors.push(interceptor);
    }

    addResponseInterceptor(interceptor: (response: Response) => Promise<Response>) {
        this.responseInterceptors.push(interceptor);
    }

    private async executeRequest<T>(
        endpoint: string,
        config: RequestInit = {},
        options: RequestConfig = {}
    ): Promise<T> {
        const {
            timeout = this.defaultTimeout,
            retries = 3,
            retryDelay = 1000,
            skipCache = false,
        } = options;

        let lastError: Error | null = null;

        // I'm implementing exponential backoff retry logic
        for (let attempt = 0; attempt <= retries; attempt++) {
            try {
                // Apply request interceptors
                let finalConfig = { ...config };
                for (const interceptor of this.requestInterceptors) {
                    finalConfig = interceptor(finalConfig);
                }

                // Add cache control if specified
                if (skipCache) {
                    finalConfig.headers = {
                        ...finalConfig.headers,
                        'Cache-Control': 'no-cache',
                    };
                }

                // I'm setting up timeout handling with AbortController
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), timeout);

                finalConfig.signal = controller.signal;

                const response = await fetch(`${this.baseURL}${endpoint}`, finalConfig);
                clearTimeout(timeoutId);

                // Apply response interceptors
                let finalResponse = response;
                for (const interceptor of this.responseInterceptors) {
                    finalResponse = await interceptor(finalResponse);
                }

                if (!finalResponse.ok) {
                    throw await this.createApiError(finalResponse);
                }

                const data = await finalResponse.json();
                return data;

            } catch (error) {
                lastError = error instanceof Error ? error : new Error('Unknown error');

                // Don't retry on client errors (4xx) or abort errors
                if (error instanceof Error) {
                    if (error.name === 'AbortError') {
                        throw new Error(`Request timeout after ${timeout}ms`);
                    }

                    if (error.message.includes('4')) {
                        throw error; // Client errors shouldn't be retried
                    }
                }

                // I'm implementing exponential backoff for retries
                if (attempt < retries) {
                    const delay = retryDelay * Math.pow(2, attempt);
                    console.warn(`API request failed (attempt ${attempt + 1}/${retries + 1}), retrying in ${delay}ms`, {
                        endpoint,
                        error: lastError.message,
                    });
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        throw lastError || new Error('Max retries exceeded');
    }

    private async createApiError(response: Response): Promise<ApiError> {
        let errorData: any = {};

        try {
            errorData = await response.json();
        } catch {
            // If response isn't JSON, create a generic error
            errorData = {
                message: response.statusText || 'Unknown error',
                code: `HTTP_${response.status}`,
            };
        }

        return {
            code: errorData.code || `HTTP_${response.status}`,
            message: errorData.message || response.statusText || 'Request failed',
            details: errorData.details,
            timestamp: new Date().toISOString(),
        };
    }

    // I'm implementing all the HTTP methods with consistent error handling
    async get<T>(endpoint: string, options?: RequestConfig): Promise<T> {
        return this.executeRequest<T>(endpoint, { method: 'GET' }, options);
    }

    async post<T>(endpoint: string, data?: any, options?: RequestConfig): Promise<T> {
        return this.executeRequest<T>(
            endpoint,
            {
                method: 'POST',
                body: data ? JSON.stringify(data) : undefined,
            },
            options
        );
    }

    async put<T>(endpoint: string, data?: any, options?: RequestConfig): Promise<T> {
        return this.executeRequest<T>(
            endpoint,
            {
                method: 'PUT',
                body: data ? JSON.stringify(data) : undefined,
            },
            options
        );
    }

    async delete<T>(endpoint: string, options?: RequestConfig): Promise<T> {
        return this.executeRequest<T>(endpoint, { method: 'DELETE' }, options);
    }

    async patch<T>(endpoint: string, data?: any, options?: RequestConfig): Promise<T> {
        return this.executeRequest<T>(
            endpoint,
            {
                method: 'PATCH',
                body: data ? JSON.stringify(data) : undefined,
            },
            options
        );
    }

    // I'm adding WebSocket support for real-time updates
    createWebSocket(endpoint: string, protocols?: string[]): WebSocket {
        const wsUrl = this.baseURL.replace(/^https?/, 'ws') + endpoint;
        return new WebSocket(wsUrl, protocols);
    }

    // I'm providing health check functionality
    async healthCheck(): Promise<{ status: string; timestamp: string }> {
        try {
            const health = await this.get<{ status: string; timestamp: string }>('/health');
            return health;
        } catch (error) {
            return {
                status: 'unhealthy',
                timestamp: new Date().toISOString(),
            };
        }
    }

    // I'm adding performance monitoring utilities
    async getPerformanceMetrics(): Promise<any> {
        return this.get('/api/performance/metrics');
    }

    async getSystemInfo(): Promise<any> {
        return this.get('/api/performance/system');
    }

    async runBenchmark(): Promise<any> {
        return this.post('/api/performance/benchmark', {}, { timeout: 120000 }); // 2 minute timeout for benchmarks
    }
}

// I'm creating a singleton instance for use throughout the application
export const apiClient = new ApiClient();

// I'm exporting types for use in other modules
export type { ApiResponse, ApiError, RequestConfig };

// I'm providing utility functions for common operations
export const createApiUrl = (endpoint: string, params?: Record<string, string | number>): string => {
    const url = new URL(endpoint, apiClient['baseURL']);

    if (params) {
        Object.entries(params).forEach(([key, value]) => {
            url.searchParams.append(key, value.toString());
        });
    }

    return url.toString();
};

export const isApiError = (error: any): error is ApiError => {
    return error && typeof error === 'object' && 'code' in error && 'message' in error;
};

// I'm adding development utilities
if (import.meta.env.DEV) {
    // Add debug logging in development
    apiClient.addRequestInterceptor((config) => {
        console.debug('API Request:', config);
        return config;
    });

    apiClient.addResponseInterceptor(async (response) => {
        console.debug('API Response:', {
            url: response.url,
            status: response.status,
            headers: Object.fromEntries(response.headers.entries()),
        });
        return response;
    });
}
</file>

<file path="src/services/fractals.ts">
/*
 * Fractal generation API service managing computation requests, progress tracking, and result processing for interactive mathematical visualization.
 * I'm implementing smart parameter optimization, computation caching, and real-time performance monitoring to deliver smooth fractal rendering experiences.
 */

import { apiClient } from './api';

interface FractalRequest {
    width: number;
    height: number;
    center_x: number;
    center_y: number;
    zoom: number;
    max_iterations: number;
    fractal_type: 'mandelbrot' | 'julia';
    c_real?: number;
    c_imag?: number;
}

interface FractalResponse {
    data: number[];
    width: number;
    height: number;
    computation_time_ms: number;
    zoom_level: number;
    parameters: {
        center_x: number;
        center_y: number;
        max_iterations: number;
        fractal_type: string;
        c_real?: number;
        c_imag?: number;
    };
    performance_metrics: {
        pixels_per_second: number;
        parallel_efficiency: number;
        memory_usage_mb: number;
        cpu_utilization: number;
    };
}

interface BenchmarkResult {
    benchmark_results: Array<{
        complexity: string;
        resolution: string;
        total_pixels: number;
        mandelbrot: {
            computation_time_ms: number;
            pixels_per_ms: number;
            performance_rating: string;
        };
        julia: {
            computation_time_ms: number;
            pixels_per_ms: number;
            performance_rating: string;
        };
    }>;
    system_context: {
        cpu_model: string;
        cpu_cores: number;
        memory_total_gb: number;
        rust_version: string;
        parallel_processing: boolean;
    };
    performance_analysis: {
        language: string;
        framework: string;
        optimization_level: string;
    };
}

interface FractalPreset {
    name: string;
    description: string;
    parameters: Partial<FractalRequest>;
    thumbnail?: string;
}

class FractalService {
    private cache: Map<string, { data: FractalResponse; timestamp: number }>;
    private readonly CACHE_TTL = 10 * 60 * 1000; // 10 minutes
    private activeRequests: Map<string, Promise<FractalResponse>>;

    constructor() {
        this.cache = new Map();
        this.activeRequests = new Map();

        // I'm setting up cache cleanup to prevent memory bloat
        setInterval(() => this.cleanupCache(), 2 * 60 * 1000); // Cleanup every 2 minutes
    }

    private cleanupCache() {
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
            if (now - entry.timestamp > this.CACHE_TTL) {
                this.cache.delete(key);
            }
        }
    }

    private getCacheKey(request: FractalRequest): string {
        // I'm creating a deterministic cache key from fractal parameters
        const params = {
            type: request.fractal_type,
            w: request.width,
            h: request.height,
            cx: Number(request.center_x.toFixed(10)),
            cy: Number(request.center_y.toFixed(10)),
            z: Number(request.zoom.toFixed(10)),
            i: request.max_iterations,
            ...(request.fractal_type === 'julia' && {
                cr: Number((request.c_real || 0).toFixed(10)),
                ci: Number((request.c_imag || 0).toFixed(10)),
            }),
        };

        return JSON.stringify(params);
    }

    private getFromCache(key: string): FractalResponse | null {
        const entry = this.cache.get(key);
        if (!entry) return null;

        const now = Date.now();
        if (now - entry.timestamp > this.CACHE_TTL) {
            this.cache.delete(key);
            return null;
        }

        return entry.data;
    }

    private setCache(key: string, data: FractalResponse) {
        this.cache.set(key, {
            data,
            timestamp: Date.now(),
        });
    }

    async generateMandelbrot(params: {
        width?: number;
        height?: number;
        center_x: number;
        center_y: number;
        zoom: number;
        max_iterations?: number;
    }): Promise<FractalResponse> {
        const request: FractalRequest = {
            fractal_type: 'mandelbrot',
            width: params.width || 800,
            height: params.height || 600,
            center_x: params.center_x,
            center_y: params.center_y,
            zoom: params.zoom,
            max_iterations: params.max_iterations || this.calculateOptimalIterations(params.zoom),
        };

        return this.executeGeneration(request);
    }

    async generateJulia(params: {
        width?: number;
        height?: number;
        center_x: number;
        center_y: number;
        zoom: number;
        c_real: number;
        c_imag: number;
        max_iterations?: number;
    }): Promise<FractalResponse> {
        const request: FractalRequest = {
            fractal_type: 'julia',
            width: params.width || 800,
            height: params.height || 600,
            center_x: params.center_x,
            center_y: params.center_y,
            zoom: params.zoom,
            c_real: params.c_real,
            c_imag: params.c_imag,
            max_iterations: params.max_iterations || this.calculateOptimalIterations(params.zoom, 'julia'),
        };

        return this.executeGeneration(request);
    }

    private async executeGeneration(request: FractalRequest): Promise<FractalResponse> {
        const cacheKey = this.getCacheKey(request);

        // I'm checking cache first for instant results
        const cached = this.getFromCache(cacheKey);
        if (cached) {
            console.debug('Returning cached fractal result');
            return cached;
        }

        // I'm preventing duplicate requests for the same fractal
        const activeKey = cacheKey;
        if (this.activeRequests.has(activeKey)) {
            console.debug('Waiting for existing fractal request');
            return this.activeRequests.get(activeKey)!;
        }

        // I'm creating the API request with proper endpoint and parameters
        const endpoint = request.fractal_type === 'mandelbrot'
        ? '/api/fractals/mandelbrot'
        : '/api/fractals/julia';

        const queryParams = new URLSearchParams({
            width: request.width.toString(),
                                                height: request.height.toString(),
                                                center_x: request.center_x.toString(),
                                                center_y: request.center_y.toString(),
                                                zoom: request.zoom.toString(),
                                                max_iterations: request.max_iterations.toString(),
        });

        if (request.fractal_type === 'julia') {
            queryParams.append('c_real', (request.c_real || 0).toString());
            queryParams.append('c_imag', (request.c_imag || 0).toString());
        }

        const requestPromise = this.makeRequest(`${endpoint}?${queryParams}`, request);
        this.activeRequests.set(activeKey, requestPromise);

        try {
            const result = await requestPromise;

            // I'm caching successful results
            this.setCache(cacheKey, result);
            return result;

        } finally {
            this.activeRequests.delete(activeKey);
        }
    }

    private async makeRequest(url: string, request: FractalRequest): Promise<FractalResponse> {
        try {
            // I'm using a longer timeout for complex fractal computations
            const timeout = this.calculateTimeout(request);

            const response = await apiClient.post<FractalResponse>(url, {}, { timeout });

            // I'm validating the response structure
            if (!this.validateFractalResponse(response)) {
                throw new Error('Invalid fractal response format');
            }

            return response;

        } catch (error) {
            console.error('Fractal generation failed:', error);
            throw error;
        }
    }

    private validateFractalResponse(response: any): response is FractalResponse {
        return (
            response &&
            Array.isArray(response.data) &&
            typeof response.width === 'number' &&
            typeof response.height === 'number' &&
            typeof response.computation_time_ms === 'number' &&
            response.performance_metrics &&
            typeof response.performance_metrics.pixels_per_second === 'number'
        );
    }

    private calculateOptimalIterations(zoom: number, type: 'mandelbrot' | 'julia' = 'mandelbrot'): number {
        // I'm calculating optimal iteration count based on zoom level and fractal type
        const baseIterations = type === 'mandelbrot' ? 100 : 150;
        const zoomFactor = Math.log10(Math.max(1, zoom));
        const optimalIterations = Math.floor(baseIterations + (zoomFactor * 50));

        return Math.max(50, Math.min(2000, optimalIterations));
    }

    private calculateTimeout(request: FractalRequest): number {
        // I'm calculating timeout based on fractal complexity
        const pixelCount = request.width * request.height;
        const complexityFactor = request.max_iterations / 100;
        const zoomComplexity = Math.log10(Math.max(1, request.zoom));

        const baseTimeout = 30000; // 30 seconds base
        const complexityTimeout = (pixelCount / 100000) * complexityFactor * zoomComplexity * 1000;

        return Math.min(baseTimeout + complexityTimeout, 120000); // Max 2 minutes
    }

    async runBenchmark(): Promise<BenchmarkResult> {
        try {
            console.log('Starting fractal benchmark suite');

            const result = await apiClient.post<BenchmarkResult>(
                '/api/fractals/benchmark',
                {},
                { timeout: 300000 } // 5 minute timeout for comprehensive benchmarks
            );

            return result;

        } catch (error) {
            console.error('Benchmark execution failed:', error);
            throw error;
        }
    }

    // I'm providing preset management for common fractal configurations
    getPresets(): FractalPreset[] {
        return [
            {
                name: 'Classic Mandelbrot',
                description: 'The classic Mandelbrot set view',
                parameters: {
                    fractal_type: 'mandelbrot',
                    center_x: -0.5,
                    center_y: 0.0,
                    zoom: 1.0,
                    max_iterations: 100,
                },
            },
            {
                name: 'Seahorse Valley',
                description: 'Intricate spiral patterns in the Mandelbrot set',
                parameters: {
                    fractal_type: 'mandelbrot',
                    center_x: -0.743643887037151,
                    center_y: 0.13182590420533,
                    zoom: 1000,
                    max_iterations: 300,
                },
            },
            {
                name: 'Lightning',
                description: 'Electric-like branching patterns',
                parameters: {
                    fractal_type: 'mandelbrot',
                    center_x: -1.8,
                    center_y: 0,
                    zoom: 100,
                    max_iterations: 250,
                },
            },
            {
                name: 'Classic Julia',
                description: 'Traditional Julia set with beautiful symmetry',
                parameters: {
                    fractal_type: 'julia',
                    center_x: 0.0,
                    center_y: 0.0,
                    zoom: 1.0,
                    c_real: -0.7,
                    c_imag: 0.27015,
                    max_iterations: 150,
                },
            },
            {
                name: 'Dragon Julia',
                description: 'Dragon-like Julia set formation',
                parameters: {
                    fractal_type: 'julia',
                    center_x: 0.0,
                    center_y: 0.0,
                    zoom: 1.0,
                    c_real: -0.8,
                    c_imag: 0.156,
                    max_iterations: 200,
                },
            },
            {
                name: 'Spiral Julia',
                description: 'Hypnotic spiral patterns',
                parameters: {
                    fractal_type: 'julia',
                    center_x: 0.0,
                    center_y: 0.0,
                    zoom: 1.0,
                    c_real: -0.4,
                    c_imag: 0.6,
                    max_iterations: 180,
                },
            },
        ];
    }

    // I'm providing utility functions for fractal mathematics
    coordinateToComplex(x: number, y: number, width: number, height: number, centerX: number, centerY: number, zoom: number): { real: number; imag: number } {
        const scale = 4.0 / zoom;
        const real = centerX + (x - width / 2) * scale / width;
        const imag = centerY + (y - height / 2) * scale / height;

        return { real, imag };
    }

    complexToCoordinate(real: number, imag: number, width: number, height: number, centerX: number, centerY: number, zoom: number): { x: number; y: number } {
        const scale = 4.0 / zoom;
        const x = (real - centerX) * width / scale + width / 2;
        const y = (imag - centerY) * height / scale + height / 2;

        return { x, y };
    }

    // I'm providing performance analysis utilities
    analyzePerformance(response: FractalResponse): {
        rating: string;
        efficiency: string;
        recommendations: string[];
    } {
        const { performance_metrics } = response;
        const pixelsPerSecond = performance_metrics.pixels_per_second;

        let rating: string;
        if (pixelsPerSecond > 10000) rating = 'Exceptional';
        else if (pixelsPerSecond > 5000) rating = 'Excellent';
        else if (pixelsPerSecond > 2000) rating = 'Very Good';
        else if (pixelsPerSecond > 1000) rating = 'Good';
        else if (pixelsPerSecond > 500) rating = 'Fair';
        else rating = 'Needs Optimization';

        const efficiency = performance_metrics.parallel_efficiency > 0.8 ? 'Excellent' :
        performance_metrics.parallel_efficiency > 0.6 ? 'Good' :
        performance_metrics.parallel_efficiency > 0.4 ? 'Fair' : 'Poor';

        const recommendations: string[] = [];

        if (performance_metrics.parallel_efficiency < 0.6) {
            recommendations.push('Consider reducing resolution for better parallel efficiency');
        }

        if (performance_metrics.memory_usage_mb > 100) {
            recommendations.push('High memory usage detected - consider lower iteration count');
        }

        if (pixelsPerSecond < 1000) {
            recommendations.push('Performance below optimal - try lower zoom or iteration count');
        }

        return { rating, efficiency, recommendations };
    }

    // I'm providing cache management utilities
    getCacheStats() {
        const entries = Array.from(this.cache.entries());
        const now = Date.now();

        return {
            totalEntries: entries.length,
            validEntries: entries.filter(([_, entry]) => now - entry.timestamp <= this.CACHE_TTL).length,
            memoryUsage: entries.reduce((total, [_, entry]) => total + entry.data.data.length * 4, 0), // Approximate bytes
            cacheHitRate: 0, // Would be calculated from actual usage statistics
        };
    }

    clearCache() {
        this.cache.clear();
        console.log('Fractal cache cleared');
    }

    // I'm providing export utilities for fractal data
    exportFractalData(response: FractalResponse, format: 'json' | 'csv' = 'json'): string {
        if (format === 'json') {
            return JSON.stringify({
                parameters: response.parameters,
                performance: response.performance_metrics,
                computation_time: response.computation_time_ms,
                timestamp: new Date().toISOString(),
            }, null, 2);
        } else {
            // CSV format for data analysis
            const csvData = [
                'x,y,iteration_count',
                ...response.data.map((value, index) => {
                    const x = index % response.width;
                    const y = Math.floor(index / response.width);
                    return `${x},${y},${value}`;
                }),
            ].join('\n');

            return csvData;
        }
    }
}

// I'm creating and exporting a singleton instance
export const fractalService = new FractalService();

// I'm exporting types for use in other modules
export type { FractalRequest, FractalResponse, BenchmarkResult, FractalPreset };
</file>

<file path="src/services/github.ts">
/*
 * GitHub API service layer providing data transformation, caching strategies, and error recovery for repository information.
 * I'm implementing intelligent caching, rate limit handling, and seamless integration with the backend GitHub service while providing clean interfaces for frontend components.
 */

import { apiClient } from './api';
import type { Repository, RepositoryDetailed, RepositoryFilter } from '../hooks/useGitHub';

interface RepositoryResponse {
    repositories: Repository[];
    pagination: {
        current_page: number;
        per_page: number;
        total_pages: number;
        total_count: number;
        has_next_page: boolean;
        has_previous_page: boolean;
    };
    statistics: {
        total_stars: number;
        total_forks: number;
        average_stars: number;
        most_starred_repo: string;
        language_count: number;
        topics_count: number;
    };
    rate_limit: {
        limit: number;
        remaining: number;
        reset_at: string;
        percentage_used: number;
    };
}

interface LanguageDistribution {
    languages: Array<{
        name: string;
        repository_count: number;
        total_size_kb: number;
        percentage: number;
        average_stars: number;
    }>;
    summary: {
        total_languages: number;
        total_repositories_analyzed: number;
        most_used_language?: string;
        language_diversity_score: number;
    };
}

class GitHubService {
    private cache: Map<string, { data: any; timestamp: number; ttl: number }>;
    private readonly DEFAULT_TTL = 5 * 60 * 1000; // 5 minutes

    constructor() {
        this.cache = new Map();

        // I'm setting up cache cleanup to prevent memory leaks
        setInterval(() => this.cleanupCache(), 60000); // Cleanup every minute
    }

    private cleanupCache() {
        const now = Date.now();
        for (const [key, entry] of this.cache.entries()) {
            if (now - entry.timestamp > entry.ttl) {
                this.cache.delete(key);
            }
        }
    }

    private getCacheKey(endpoint: string, params?: Record<string, any>): string {
        const paramString = params ? JSON.stringify(params) : '';
        return `${endpoint}:${paramString}`;
    }

    private getFromCache<T>(key: string): T | null {
        const entry = this.cache.get(key);
        if (!entry) return null;

        const now = Date.now();
        if (now - entry.timestamp > entry.ttl) {
            this.cache.delete(key);
            return null;
        }

        return entry.data;
    }

    private setCache<T>(key: string, data: T, ttl: number = this.DEFAULT_TTL) {
        this.cache.set(key, {
            data,
            timestamp: Date.now(),
                       ttl,
        });
    }

    async getRepositories(params: {
        page?: number;
        per_page?: number;
        sort?: string;
        direction?: string;
        language?: string;
        min_stars?: number;
        max_stars?: number;
        is_fork?: boolean;
        is_archived?: boolean;
        search?: string;
    } = {}): Promise<RepositoryResponse> {
        const cacheKey = this.getCacheKey('/api/github/repos', params);

        // I'm checking cache first for performance optimization
        const cached = this.getFromCache<RepositoryResponse>(cacheKey);
        if (cached) {
            return cached;
        }

        try {
            const queryParams = new URLSearchParams();

            // I'm building query parameters with proper type conversion
            Object.entries(params).forEach(([key, value]) => {
                if (value !== undefined && value !== null && value !== '') {
                    queryParams.append(key, value.toString());
                }
            });

            const endpoint = `/api/github/repos${queryParams.toString() ? `?${queryParams}` : ''}`;
            const response = await apiClient.get<RepositoryResponse>(endpoint);

            // I'm caching successful responses with TTL based on rate limit status
            const cacheTtl = response.rate_limit.remaining > 100
            ? this.DEFAULT_TTL
            : this.DEFAULT_TTL * 2; // Cache longer when rate limit is low

            this.setCache(cacheKey, response, cacheTtl);
            return response;

        } catch (error) {
            console.error('Failed to fetch repositories:', error);
            throw error;
        }
    }

    async getRepositoryDetails(owner: string, name: string): Promise<RepositoryDetailed> {
        const cacheKey = this.getCacheKey(`/api/github/repo/${owner}/${name}`);

        const cached = this.getFromCache<RepositoryDetailed>(cacheKey);
        if (cached) {
            return cached;
        }

        try {
            const response = await apiClient.get<RepositoryDetailed>(`/api/github/repo/${owner}/${name}`);

            // I'm caching detailed repository data for longer since it changes less frequently
            this.setCache(cacheKey, response, this.DEFAULT_TTL * 2);
            return response;

        } catch (error) {
            console.error(`Failed to fetch repository details for ${owner}/${name}:`, error);
            throw error;
        }
    }

    async getRepositoryStats(owner: string, name: string): Promise<any> {
        const cacheKey = this.getCacheKey(`/api/github/repo/${owner}/${name}/stats`);

        const cached = this.getFromCache<any>(cacheKey);
        if (cached) {
            return cached;
        }

        try {
            const response = await apiClient.get<any>(`/api/github/repo/${owner}/${name}/stats`);

            // I'm caching stats for a shorter time since they're more dynamic
            this.setCache(cacheKey, response, this.DEFAULT_TTL);
            return response;

        } catch (error) {
            console.error(`Failed to fetch repository stats for ${owner}/${name}:`, error);
            throw error;
        }
    }

    async getLanguageDistribution(): Promise<LanguageDistribution> {
        const cacheKey = this.getCacheKey('/api/github/language-distribution');

        const cached = this.getFromCache<LanguageDistribution>(cacheKey);
        if (cached) {
            return cached;
        }

        try {
            const response = await apiClient.get<LanguageDistribution>('/api/github/language-distribution');

            // I'm caching language distribution for longer since it changes slowly
            this.setCache(cacheKey, response, this.DEFAULT_TTL * 4);
            return response;

        } catch (error) {
            console.error('Failed to fetch language distribution:', error);
            throw error;
        }
    }

    // I'm implementing utility methods for data transformation and analysis
    calculateRepositoryHealth(repo: Repository): 'excellent' | 'good' | 'fair' | 'poor' {
        if (repo.is_archived) return 'poor';

        let score = 0;

        // I'm scoring based on various repository health indicators
        if (repo.description) score += 1;
        if (repo.topics && repo.topics.length > 0) score += 1;
        if (repo.license_name) score += 1;

        // Check if recently updated (within 90 days)
        const daysSinceUpdate = (new Date().getTime() - new Date(repo.updated_at).getTime()) / (1000 * 60 * 60 * 24);
        if (daysSinceUpdate <= 90) score += 1;

        switch (score) {
            case 4: return 'excellent';
            case 3: return 'good';
            case 2: return 'fair';
            default: return 'poor';
        }
    }

    calculateActivityScore(repo: Repository): number {
        const daysSinceUpdate = (new Date().getTime() - new Date(repo.updated_at).getTime()) / (1000 * 60 * 60 * 24);
        const recentActivityBonus = daysSinceUpdate < 30 ? 20 : daysSinceUpdate < 90 ? 10 : 0;
        const starScore = Math.log(repo.stargazers_count + 1) * 5;
        const forkScore = Math.log(repo.forks_count + 1) * 3;
        const sizeScore = Math.min(Math.log(repo.size_kb + 1), 10);

        return Math.min(recentActivityBonus + starScore + forkScore + sizeScore, 100);
    }

    formatSize(sizeKb: number): string {
        if (sizeKb < 1024) return `${sizeKb} KB`;
        const sizeMb = sizeKb / 1024;
        if (sizeMb < 1024) return `${sizeMb.toFixed(1)} MB`;
        const sizeGb = sizeMb / 1024;
        return `${sizeGb.toFixed(1)} GB`;
    }

    formatRelativeTime(dateString: string): string {
        const date = new Date(dateString);
        const now = new Date();
        const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

        if (diffInSeconds < 60) return 'just now';
        if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)} minutes ago`;
        if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)} hours ago`;
        if (diffInSeconds < 604800) return `${Math.floor(diffInSeconds / 86400)} days ago`;
        if (diffInSeconds < 2629746) return `${Math.floor(diffInSeconds / 604800)} weeks ago`;
        if (diffInSeconds < 31556952) return `${Math.floor(diffInSeconds / 2629746)} months ago`;
        return `${Math.floor(diffInSeconds / 31556952)} years ago`;
    }

    getLanguageColor(language: string): string {
        // I'm providing a comprehensive color mapping for popular languages
        const colors: Record<string, string> = {
            'JavaScript': '#f1e05a',
            'TypeScript': '#2b7489',
            'Python': '#3572A5',
            'Java': '#b07219',
            'C++': '#f34b7d',
            'C': '#555555',
            'C#': '#239120',
            'PHP': '#4F5D95',
            'Ruby': '#701516',
            'Go': '#00ADD8',
            'Rust': '#dea584',
            'Swift': '#ffac45',
            'Kotlin': '#F18E33',
            'Scala': '#c22d40',
            'HTML': '#e34c26',
            'CSS': '#1572B6',
            'Shell': '#89e051',
            'Dockerfile': '#384d54',
            'Makefile': '#427819',
            'Vue': '#4FC08D',
            'Svelte': '#ff3e00',
            'Dart': '#00B4AB',
            'Elixir': '#6e4a7e',
            'Haskell': '#5e5086',
            'Lua': '#000080',
            'R': '#198CE7',
            'MATLAB': '#e16737',
        };

        return colors[language] || '#586069';
    }

    // I'm adding search and filtering utilities
    filterRepositories(repositories: Repository[], filters: RepositoryFilter): Repository[] {
        return repositories.filter(repo => {
            if (filters.language && repo.language !== filters.language) return false;
            if (filters.min_stars && repo.stargazers_count < filters.min_stars) return false;
            if (filters.max_stars && repo.stargazers_count > filters.max_stars) return false;
            if (filters.is_fork !== undefined && repo.is_fork !== filters.is_fork) return false;
            if (filters.is_archived !== undefined && repo.is_archived !== filters.is_archived) return false;

            if (filters.search) {
                const searchTerm = filters.search.toLowerCase();
                const searchableText = `${repo.name} ${repo.description || ''} ${repo.topics.join(' ')}`.toLowerCase();
                if (!searchableText.includes(searchTerm)) return false;
            }

            return true;
        });
    }

    sortRepositories(repositories: Repository[], sortBy: string, direction: 'asc' | 'desc' = 'desc'): Repository[] {
        const sorted = [...repositories].sort((a, b) => {
            let comparison = 0;

            switch (sortBy) {
                case 'name':
                    comparison = a.name.localeCompare(b.name);
                    break;
                case 'stars':
                    comparison = a.stargazers_count - b.stargazers_count;
                    break;
                case 'forks':
                    comparison = a.forks_count - b.forks_count;
                    break;
                case 'updated':
                    comparison = new Date(a.updated_at).getTime() - new Date(b.updated_at).getTime();
                    break;
                case 'created':
                    comparison = new Date(a.created_at).getTime() - new Date(b.created_at).getTime();
                    break;
                case 'size':
                    comparison = a.size_kb - b.size_kb;
                    break;
                case 'activity':
                    comparison = this.calculateActivityScore(a) - this.calculateActivityScore(b);
                    break;
                default:
                    comparison = new Date(a.updated_at).getTime() - new Date(b.updated_at).getTime();
            }

            return direction === 'desc' ? -comparison : comparison;
        });

        return sorted;
    }

    // I'm providing cache management utilities
    clearCache() {
        this.cache.clear();
    }

    getCacheStats() {
        const entries = Array.from(this.cache.entries());
        const now = Date.now();

        return {
            totalEntries: entries.length,
            validEntries: entries.filter(([_, entry]) => now - entry.timestamp <= entry.ttl).length,
            memoryUsage: JSON.stringify(Object.fromEntries(entries)).length,
        };
    }

    // I'm adding prefetch capabilities for performance optimization
    async prefetchRepository(owner: string, name: string) {
        try {
            // I'm prefetching both details and stats in parallel
            await Promise.all([
                this.getRepositoryDetails(owner, name),
                              this.getRepositoryStats(owner, name),
            ]);
        } catch (error) {
            console.warn(`Failed to prefetch repository ${owner}/${name}:`, error);
        }
    }

    async prefetchRepositories(repositories: Repository[]) {
        // I'm prefetching the most likely to be viewed repositories
        const priorityRepos = repositories
        .filter(repo => !repo.is_archived && repo.stargazers_count > 0)
        .slice(0, 5); // Prefetch top 5 repositories

        await Promise.allSettled(
            priorityRepos.map(repo => this.prefetchRepository(repo.owner, repo.name))
        );
    }
}

// I'm creating and exporting a singleton instance
export const githubService = new GitHubService();

// I'm exporting types for use in other modules
export type { RepositoryResponse, LanguageDistribution };
</file>

<file path="src/services/performance.ts">
/*
 * Performance monitoring service providing real-time metrics collection, WebSocket integration, and comprehensive system performance analysis.
 * I'm implementing intelligent data aggregation, alerting capabilities, and seamless integration with the backend performance monitoring system for live dashboard updates.
 */

import { apiClient } from './api';

interface SystemMetrics {
    timestamp: string;
    cpu_usage_percent: number;
    memory_usage_percent: number;
    memory_total_gb: number;
    memory_available_gb: number;
    disk_usage_percent: number;
    load_average_1m: number;
    load_average_5m: number;
    load_average_15m: number;
    cpu_cores: number;
    cpu_threads: number;
    cpu_model: string;
    uptime_seconds: number;
    active_processes: number;
    system_temperature?: number;
}

interface ApplicationMetrics {
    requests_handled: number;
    average_response_time_ms: number;
    fractal_computations: number;
    github_api_calls: number;
    cache_hit_rate: number;
    database_connections: number;
    memory_usage_mb: number;
}

interface PerformanceSnapshot {
    timestamp: string;
    system: SystemMetrics;
    application: ApplicationMetrics;
    hardware: {
        cpu_model: string;
        cpu_cores: number;
        cpu_threads: number;
        architecture: string;
        total_memory_gb: number;
    };
    runtime: {
        rust_version: string;
        build_type: string;
        optimization_level: string;
        features_enabled: string[];
    };
}

interface BenchmarkResult {
    benchmark_id: string;
    timestamp: string;
    total_duration_ms: number;
    system_info: any;
    benchmarks: {
        cpu: any;
        memory: any;
    };
    performance_rating: string;
}

interface MetricsHistory {
    timestamp: string;
    period_minutes: number;
    data_points: number;
    metrics: {
        cpu_usage: Array<{ timestamp: string; value: number }>;
        memory_usage: Array<{ timestamp: string; value: number }>;
        disk_usage: Array<{ timestamp: string; value: number }>;
        load_average: Array<{ timestamp: string; value: number }>;
        response_times: Array<{ timestamp: string; value: number }>;
    };
    summary: {
        average_cpu: number;
        peak_cpu: number;
        average_memory: number;
        peak_memory: number;
        incidents: number;
        uptime_percentage: number;
    };
}

interface AlertConfig {
    metric: string;
    threshold: number;
    operator: '>' | '<' | '=';
    duration: number; // milliseconds
    enabled: boolean;
}

interface Alert {
    id: string;
    timestamp: string;
    metric: string;
    value: number;
    threshold: number;
    severity: 'low' | 'medium' | 'high' | 'critical';
    message: string;
    acknowledged: boolean;
}

class PerformanceService {
    private wsConnection: WebSocket | null = null;
    private metricsCache: Map<string, { data: any; timestamp: number }>;
    private realTimeMetrics: SystemMetrics | null = null;
    private alertConfig: AlertConfig[];
    private activeAlerts: Map<string, Alert>;
    private metricsHistory: Array<{ timestamp: number; metrics: SystemMetrics }>;
    private subscribers: Map<string, Set<(data: any) => void>>;

    constructor() {
        this.metricsCache = new Map();
        this.alertConfig = this.getDefaultAlertConfig();
        this.activeAlerts = new Map();
        this.metricsHistory = [];
        this.subscribers = new Map();

        // I'm setting up automatic cache cleanup
        setInterval(() => this.cleanupCache(), 60000); // Every minute

        // I'm initializing real-time monitoring
        this.initializeRealTimeMonitoring();
    }

    private getDefaultAlertConfig(): AlertConfig[] {
        return [
            {
                metric: 'cpu_usage_percent',
                threshold: 85,
                operator: '>',
                duration: 30000, // 30 seconds
                enabled: true,
            },
            {
                metric: 'memory_usage_percent',
                threshold: 90,
                operator: '>',
                duration: 30000,
                enabled: true,
            },
            {
                metric: 'disk_usage_percent',
                threshold: 95,
                operator: '>',
                duration: 60000, // 1 minute
                enabled: true,
            },
            {
                metric: 'load_average_1m',
                threshold: 10,
                operator: '>',
                duration: 60000,
                enabled: true,
            },
        ];
    }

    private cleanupCache() {
        const now = Date.now();
        const maxAge = 5 * 60 * 1000; // 5 minutes

        for (const [key, entry] of this.metricsCache.entries()) {
            if (now - entry.timestamp > maxAge) {
                this.metricsCache.delete(key);
            }
        }

        // I'm also cleaning up old metrics history
        const maxHistoryAge = 60 * 60 * 1000; // 1 hour
        this.metricsHistory = this.metricsHistory.filter(
            entry => now - entry.timestamp < maxHistoryAge
        );
    }

    private initializeRealTimeMonitoring() {
        // I'm starting with a 5-second polling interval, will upgrade to WebSocket later
        setInterval(async () => {
            try {
                const metrics = await this.getCurrentMetrics();
                this.processRealTimeMetrics(metrics.system);
            } catch (error) {
                console.warn('Failed to fetch real-time metrics:', error);
            }
        }, 5000);
    }

    private processRealTimeMetrics(metrics: SystemMetrics) {
        this.realTimeMetrics = metrics;

        // I'm storing metrics in history for trend analysis
        this.metricsHistory.push({
            timestamp: Date.now(),
                                 metrics,
        });

        // I'm checking for alert conditions
        this.checkAlerts(metrics);

        // I'm notifying subscribers
        this.notifySubscribers('metrics', metrics);
    }

    private checkAlerts(metrics: SystemMetrics) {
        for (const config of this.alertConfig) {
            if (!config.enabled) continue;

            const value = (metrics as any)[config.metric];
            if (typeof value !== 'number') continue;

            const alertId = `${config.metric}_${config.threshold}`;
            const shouldAlert = this.evaluateAlertCondition(value, config.threshold, config.operator);

            if (shouldAlert && !this.activeAlerts.has(alertId)) {
                // I'm creating a new alert
                const alert: Alert = {
                    id: alertId,
                    timestamp: new Date().toISOString(),
                    metric: config.metric,
                    value,
                    threshold: config.threshold,
                    severity: this.calculateAlertSeverity(config.metric, value, config.threshold),
                    message: this.generateAlertMessage(config.metric, value, config.threshold),
                    acknowledged: false,
                };

                this.activeAlerts.set(alertId, alert);
                this.notifySubscribers('alert', alert);

            } else if (!shouldAlert && this.activeAlerts.has(alertId)) {
                // I'm clearing resolved alerts
                this.activeAlerts.delete(alertId);
                this.notifySubscribers('alert_cleared', { id: alertId });
            }
        }
    }

    private evaluateAlertCondition(value: number, threshold: number, operator: string): boolean {
        switch (operator) {
            case '>': return value > threshold;
            case '<': return value < threshold;
            case '=': return Math.abs(value - threshold) < 0.01;
            default: return false;
        }
    }

    private calculateAlertSeverity(metric: string, value: number, threshold: number): Alert['severity'] {
        const excess = Math.abs(value - threshold) / threshold;

        if (excess > 0.3) return 'critical';
        if (excess > 0.2) return 'high';
        if (excess > 0.1) return 'medium';
        return 'low';
    }

    private generateAlertMessage(metric: string, value: number, threshold: number): string {
        const metricNames: Record<string, string> = {
            cpu_usage_percent: 'CPU usage',
            memory_usage_percent: 'Memory usage',
            disk_usage_percent: 'Disk usage',
            load_average_1m: 'Load average',
        };

        const friendlyName = metricNames[metric] || metric;
        return `${friendlyName} is ${value.toFixed(1)}%, exceeding threshold of ${threshold}%`;
    }

    // Public API methods

    async getCurrentMetrics(): Promise<PerformanceSnapshot> {
        const cacheKey = 'current_metrics';
        const cached = this.metricsCache.get(cacheKey);

        if (cached && Date.now() - cached.timestamp < 5000) { // 5 second cache
            return cached.data;
        }

        try {
            const response = await apiClient.get<PerformanceSnapshot>('/api/performance/metrics');

            this.metricsCache.set(cacheKey, {
                data: response,
                timestamp: Date.now(),
            });

            return response;

        } catch (error) {
            console.error('Failed to fetch current metrics:', error);
            throw error;
        }
    }

    async getSystemInfo(): Promise<any> {
        const cacheKey = 'system_info';
        const cached = this.metricsCache.get(cacheKey);

        if (cached && Date.now() - cached.timestamp < 60000) { // 1 minute cache
            return cached.data;
        }

        try {
            const response = await apiClient.get('/api/performance/system');

            this.metricsCache.set(cacheKey, {
                data: response,
                timestamp: Date.now(),
            });

            return response;

        } catch (error) {
            console.error('Failed to fetch system info:', error);
            throw error;
        }
    }

    async runBenchmark(): Promise<BenchmarkResult> {
        try {
            console.log('Starting performance benchmark');

            const response = await apiClient.post<BenchmarkResult>(
                '/api/performance/benchmark',
                {},
                { timeout: 120000 } // 2 minute timeout
            );

            // I'm notifying subscribers about benchmark completion
            this.notifySubscribers('benchmark_complete', response);

            return response;

        } catch (error) {
            console.error('Benchmark execution failed:', error);
            throw error;
        }
    }

    async getMetricsHistory(limitMinutes: number = 60): Promise<MetricsHistory> {
        try {
            const response = await apiClient.get<MetricsHistory>(
                `/api/performance/history?limit=${Math.floor(limitMinutes / 5)}` // 5-minute intervals
            );

            return response;

        } catch (error) {
            console.error('Failed to fetch metrics history:', error);
            throw error;
        }
    }

    // Real-time data subscription system
    subscribe(event: string, callback: (data: any) => void): () => void {
        if (!this.subscribers.has(event)) {
            this.subscribers.set(event, new Set());
        }

        this.subscribers.get(event)!.add(callback);

        // I'm returning an unsubscribe function
        return () => {
            const eventSubscribers = this.subscribers.get(event);
            if (eventSubscribers) {
                eventSubscribers.delete(callback);
            }
        };
    }

    private notifySubscribers(event: string, data: any) {
        const eventSubscribers = this.subscribers.get(event);
        if (eventSubscribers) {
            eventSubscribers.forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error('Error in performance subscriber callback:', error);
                }
            });
        }
    }

    // Alert management
    getActiveAlerts(): Alert[] {
        return Array.from(this.activeAlerts.values());
    }

    acknowledgeAlert(alertId: string) {
        const alert = this.activeAlerts.get(alertId);
        if (alert) {
            alert.acknowledged = true;
            this.notifySubscribers('alert_acknowledged', alert);
        }
    }

    clearAlert(alertId: string) {
        if (this.activeAlerts.delete(alertId)) {
            this.notifySubscribers('alert_cleared', { id: alertId });
        }
    }

    updateAlertConfig(config: AlertConfig[]) {
        this.alertConfig = config;
    }

    // Performance analysis utilities
    analyzePerformance(metrics: SystemMetrics): {
        overall_health: 'excellent' | 'good' | 'fair' | 'poor';
        bottlenecks: string[];
        recommendations: string[];
        score: number;
    } {
        let score = 100;
        const bottlenecks: string[] = [];
        const recommendations: string[] = [];

        // I'm analyzing CPU performance
        if (metrics.cpu_usage_percent > 80) {
            score -= 20;
            bottlenecks.push('High CPU usage');
            recommendations.push('Consider optimizing CPU-intensive operations');
        }

        // I'm analyzing memory performance
        if (metrics.memory_usage_percent > 85) {
            score -= 15;
            bottlenecks.push('High memory usage');
            recommendations.push('Monitor memory leaks and optimize memory usage');
        }

        // I'm analyzing disk usage
        if (metrics.disk_usage_percent > 90) {
            score -= 10;
            bottlenecks.push('Low disk space');
            recommendations.push('Clean up disk space or add more storage');
        }

        // I'm analyzing load average
        if (metrics.load_average_1m > metrics.cpu_cores * 2) {
            score -= 15;
            bottlenecks.push('High system load');
            recommendations.push('Reduce concurrent processes or scale resources');
        }

        let overall_health: 'excellent' | 'good' | 'fair' | 'poor';
        if (score >= 90) overall_health = 'excellent';
        else if (score >= 75) overall_health = 'good';
        else if (score >= 60) overall_health = 'fair';
        else overall_health = 'poor';

        return {
            overall_health,
            bottlenecks,
            recommendations,
            score: Math.max(0, score),
        };
    }

    // Performance comparison utilities
    compareWithHistorical(current: SystemMetrics, historicalPeriodMinutes: number = 60): {
        cpu_trend: 'improving' | 'stable' | 'degrading';
        memory_trend: 'improving' | 'stable' | 'degrading';
        performance_delta: number;
    } {
        const cutoffTime = Date.now() - (historicalPeriodMinutes * 60 * 1000);
        const historicalMetrics = this.metricsHistory
        .filter(entry => entry.timestamp > cutoffTime)
        .map(entry => entry.metrics);

        if (historicalMetrics.length === 0) {
            return {
                cpu_trend: 'stable',
                memory_trend: 'stable',
                performance_delta: 0,
            };
        }

        const avgCpu = historicalMetrics.reduce((sum, m) => sum + m.cpu_usage_percent, 0) / historicalMetrics.length;
        const avgMemory = historicalMetrics.reduce((sum, m) => sum + m.memory_usage_percent, 0) / historicalMetrics.length;

        const cpuDelta = current.cpu_usage_percent - avgCpu;
        const memoryDelta = current.memory_usage_percent - avgMemory;

        return {
            cpu_trend: cpuDelta > 5 ? 'degrading' : cpuDelta < -5 ? 'improving' : 'stable',
            memory_trend: memoryDelta > 5 ? 'degrading' : memoryDelta < -5 ? 'improving' : 'stable',
            performance_delta: (cpuDelta + memoryDelta) / 2,
        };
    }

    // Utility methods
    getRealTimeMetrics(): SystemMetrics | null {
        return this.realTimeMetrics;
    }

    getCacheStats() {
        return {
            entries: this.metricsCache.size,
            alerts: this.activeAlerts.size,
            subscribers: Array.from(this.subscribers.entries()).reduce(
                (total, [_, subs]) => total + subs.size, 0
            ),
            historyPoints: this.metricsHistory.length,
        };
    }

    clearCache() {
        this.metricsCache.clear();
    }

    // Export functionality
    exportMetrics(format: 'json' | 'csv' = 'json'): string {
        const data = {
            current: this.realTimeMetrics,
            history: this.metricsHistory.slice(-100), // Last 100 points
            alerts: Array.from(this.activeAlerts.values()),
            timestamp: new Date().toISOString(),
        };

        if (format === 'json') {
            return JSON.stringify(data, null, 2);
        } else {
            // I'm creating CSV format for data analysis
            const csvLines = [
                'timestamp,cpu_usage,memory_usage,disk_usage,load_average',
                ...this.metricsHistory.slice(-100).map(entry =>
                `${new Date(entry.timestamp).toISOString()},${entry.metrics.cpu_usage_percent},${entry.metrics.memory_usage_percent},${entry.metrics.disk_usage_percent},${entry.metrics.load_average_1m}`
                ),
            ];

            return csvLines.join('\n');
        }
    }
}

// I'm creating and exporting a singleton instance
export const performanceService = new PerformanceService();

// I'm exporting types for use in other modules
export type {
    SystemMetrics,
    ApplicationMetrics,
    PerformanceSnapshot,
    BenchmarkResult,
    MetricsHistory,
    Alert,
    AlertConfig
};
</file>

<file path="src/styles/components.css">
/*
 * Component-specific styles providing specialized styling for complex UI elements like fractal canvas, performance charts, and interactive components.
 * I'm implementing component-scoped styles that complement Tailwind utilities while maintaining the dark, eerie aesthetic throughout all interactive elements.
 */

/* I'm styling the fractal canvas and its interactive controls */
.fractal-canvas-container {
  position: relative;
  background: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius-lg);
  overflow: hidden;
}

.fractal-canvas {
  display: block;
  cursor: crosshair;
  transition: cursor 0.1s ease;
}

.fractal-canvas:active {
  cursor: grabbing;
}

.fractal-canvas-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  z-index: 10;
}

.fractal-controls {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background: rgba(0, 0, 0, 0.9);
  backdrop-filter: blur(10px);
  border: 1px solid var(--border-secondary);
  border-radius: var(--border-radius);
  padding: 1rem;
  min-width: 200px;
  font-family: var(--font-mono);
  font-size: 0.75rem;
}

.fractal-controls-header {
  color: var(--color-primary);
  font-weight: 600;
  margin-bottom: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.fractal-parameter {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
  color: var(--text-secondary);
}

.fractal-parameter-value {
  color: var(--text-primary);
  font-weight: 500;
}

.fractal-slider {
  width: 100%;
  height: 4px;
  background: var(--border-primary);
  border-radius: 2px;
  outline: none;
  -webkit-appearance: none;
  appearance: none;
  margin: 0.5rem 0;
}

.fractal-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  background: var(--color-primary);
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.2s ease;
}

.fractal-slider::-webkit-slider-thumb:hover {
  transform: scale(1.2);
  box-shadow: 0 0 10px var(--color-primary);
}

.fractal-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: var(--color-primary);
  border-radius: 50%;
  cursor: pointer;
  border: none;
  transition: all 0.2s ease;
}

.fractal-slider::-moz-range-thumb:hover {
  transform: scale(1.2);
  box-shadow: 0 0 10px var(--color-primary);
}

/* I'm creating performance chart styles */
.performance-chart {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius-lg);
  padding: 1.5rem;
  position: relative;
}

.performance-chart-title {
  font-family: var(--font-mono);
  font-size: 0.875rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  margin-bottom: 1rem;
}

.performance-metric-card {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius);
  padding: 1rem;
  transition: all var(--duration-fast) ease;
}

.performance-metric-card:hover {
  border-color: var(--border-secondary);
  background: rgba(255, 255, 255, 0.05);
}

.performance-metric-label {
  font-size: 0.75rem;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: 0.25rem;
}

.performance-metric-value {
  font-family: var(--font-mono);
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text-primary);
  line-height: 1;
}

.performance-metric-unit {
  font-size: 0.875rem;
  color: var(--text-secondary);
  margin-left: 0.25rem;
}

.performance-trend-up {
  color: var(--color-success);
}

.performance-trend-down {
  color: var(--color-error);
}

.performance-trend-stable {
  color: var(--text-muted);
}

/* I'm styling the system monitor component */
.system-monitor-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
}

.system-resource-card {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius-lg);
  padding: 1.25rem;
  position: relative;
  overflow: hidden;
}

.system-resource-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--color-primary), transparent);
  opacity: 0;
  transition: opacity var(--duration-medium) ease;
}

.system-resource-card:hover::before {
  opacity: 1;
}

.resource-usage-bar {
  width: 100%;
  height: 8px;
  background: var(--border-primary);
  border-radius: 4px;
  overflow: hidden;
  margin: 0.75rem 0;
}

.resource-usage-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--color-primary), var(--color-secondary));
  border-radius: 4px;
  transition: width 0.5s ease;
  position: relative;
}

.resource-usage-fill::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 20px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3));
  animation: shine 2s infinite;
}

@keyframes shine {
  0% { transform: translateX(-20px); }
  100% { transform: translateX(20px); }
}

/* I'm creating GitHub repository card styles */
.repo-card {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius-lg);
  padding: 1.5rem;
  transition: all var(--duration-medium) ease;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.repo-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(34, 211, 238, 0.1), transparent);
  transition: left 0.6s ease;
}

.repo-card:hover::before {
  left: 100%;
}

.repo-card:hover {
  border-color: var(--border-secondary);
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
}

.repo-title {
  font-family: var(--font-mono);
  font-size: 1.125rem;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 0.5rem;
  transition: color var(--duration-fast) ease;
}

.repo-card:hover .repo-title {
  color: var(--color-primary);
}

.repo-description {
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 1rem;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.repo-stats {
  display: flex;
  align-items: center;
  gap: 1rem;
  font-size: 0.75rem;
  color: var(--text-tertiary);
}

.repo-stat {
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.repo-language-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}

.repo-topics {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-top: 0.75rem;
}

.repo-topic {
  background: var(--bg-secondary);
  color: var(--text-tertiary);
  padding: 0.25rem 0.5rem;
  border-radius: var(--border-radius);
  font-size: 0.675rem;
  font-family: var(--font-mono);
  border: 1px solid var(--border-primary);
  transition: all var(--duration-fast) ease;
}

.repo-topic:hover {
  border-color: var(--color-primary);
  color: var(--color-primary);
}

/* I'm styling the tech stack information component */
.tech-stack-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
}

.tech-card {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius-lg);
  padding: 2rem;
  transition: all var(--duration-medium) ease;
  cursor: pointer;
  position: relative;
}

.tech-card:hover {
  border-color: var(--color-primary);
  box-shadow: 0 0 30px rgba(34, 211, 238, 0.1);
}

.tech-card-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 1rem;
}

.tech-name {
  font-family: var(--font-mono);
  font-size: 1.25rem;
  font-weight: 600;
  color: var(--text-primary);
}

.tech-version {
  font-size: 0.75rem;
  color: var(--text-muted);
  font-family: var(--font-mono);
  background: var(--bg-secondary);
  padding: 0.25rem 0.5rem;
  border-radius: var(--border-radius);
}

.tech-description {
  color: var(--text-secondary);
  line-height: 1.6;
  margin-bottom: 1.5rem;
}

.tech-features {
  list-style: none;
  padding: 0;
  margin: 0;
}

.tech-feature {
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
  color: var(--text-tertiary);
}

.tech-feature::before {
  content: '▶';
  color: var(--color-primary);
  font-size: 0.75rem;
  margin-top: 0.125rem;
}

/* I'm creating benchmark comparison chart styles */
.benchmark-chart {
  background: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius-lg);
  padding: 2rem;
}

.benchmark-bar {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 1rem;
}

.benchmark-label {
  min-width: 80px;
  font-family: var(--font-mono);
  font-size: 0.875rem;
  color: var(--text-secondary);
}

.benchmark-bar-container {
  flex: 1;
  height: 24px;
  background: var(--border-primary);
  border-radius: 12px;
  position: relative;
  overflow: hidden;
}

.benchmark-bar-fill {
  height: 100%;
  border-radius: 12px;
  position: relative;
  transition: width 1s ease;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  padding-right: 0.75rem;
}

.benchmark-bar-fill.rust {
  background: linear-gradient(90deg, #ce422b, #dea584);
}

.benchmark-bar-fill.javascript {
  background: linear-gradient(90deg, #f0db4f, #f7df1e);
}

.benchmark-bar-fill.python {
  background: linear-gradient(90deg, #306998, #3776ab);
}

.benchmark-bar-fill.java {
  background: linear-gradient(90deg, #ed8b00, #f89820);
}

.benchmark-value {
  font-family: var(--font-mono);
  font-size: 0.75rem;
  font-weight: 600;
  color: white;
  text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
}

/* I'm styling loading and error states */
.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 3rem;
  text-align: center;
}

.loading-spinner {
  width: 3rem;
  height: 3rem;
  border: 3px solid var(--border-primary);
  border-top-color: var(--color-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 1rem;
}

.loading-text {
  font-family: var(--font-mono);
  color: var(--text-secondary);
  font-size: 0.875rem;
}

.error-container {
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid #dc2626;
  border-radius: var(--border-radius-lg);
  padding: 1.5rem;
  text-align: center;
}

.error-title {
  color: #ef4444;
  font-family: var(--font-mono);
  font-size: 1rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.error-message {
  color: var(--text-secondary);
  font-size: 0.875rem;
  line-height: 1.5;
}

/* I'm creating navigation styles */
.nav-link {
  position: relative;
  font-family: var(--font-mono);
  font-size: 0.875rem;
  color: var(--text-secondary);
  text-decoration: none;
  padding: 0.5rem 0;
  transition: color var(--duration-fast) ease;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.nav-link:hover {
  color: var(--text-primary);
}

.nav-link.active {
  color: var(--color-primary);
}

.nav-link::after {
  content: '';
  position: absolute;
  bottom: -1px;
  left: 0;
  width: 0;
  height: 1px;
  background: var(--color-primary);
  transition: width var(--duration-medium) ease;
}

.nav-link:hover::after,
.nav-link.active::after {
  width: 100%;
}

/* I'm creating alert and notification styles */
.alert {
  border-radius: var(--border-radius);
  padding: 1rem 1.25rem;
  margin-bottom: 1rem;
  display: flex;
  align-items: flex-start;
  gap: 0.75rem;
}

.alert-success {
  background: rgba(34, 197, 94, 0.1);
  border: 1px solid #22c55e;
  color: #22c55e;
}

.alert-warning {
  background: rgba(245, 158, 11, 0.1);
  border: 1px solid #f59e0b;
  color: #f59e0b;
}

.alert-error {
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid #ef4444;
  color: #ef4444;
}

.alert-info {
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid #3b82f6;
  color: #3b82f6;
}

.alert-icon {
  margin-top: 0.125rem;
  flex-shrink: 0;
}

.alert-content {
  flex: 1;
}

.alert-title {
  font-weight: 600;
  margin-bottom: 0.25rem;
}

.alert-message {
  font-size: 0.875rem;
  opacity: 0.9;
}

/* I'm creating responsive utilities for components */
@media (max-width: 768px) {
  .fractal-controls {
    position: static;
    margin-top: 1rem;
    background: var(--bg-tertiary);
  }

  .system-monitor-grid {
    grid-template-columns: 1fr;
  }

  .tech-stack-grid {
    grid-template-columns: 1fr;
  }

  .benchmark-bar {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }

  .benchmark-label {
    min-width: unset;
  }
}
</file>

<file path="src/styles/global.css">
/*
 * Global stylesheet establishing the dark, eerie aesthetic foundation and core design system for the entire application.
 * I'm implementing the Mr. Robot-inspired visual language with custom properties, typography, animations, and component base styles for consistent theming.
 */

@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

/* I'm defining CSS custom properties for dynamic theming */
:root {
  /* Color system - dark theme with eerie accents */
  --color-primary: #22d3ee;
  --color-secondary: #6366f1;
  --color-accent: #a855f7;

  --bg-primary: #000000;
  --bg-secondary: #0a0a0a;
  --bg-tertiary: #171717;
  --bg-card: #1a1a1a;

  --text-primary: #f5f5f5;
  --text-secondary: #a3a3a3;
  --text-tertiary: #737373;
  --text-muted: #525252;

  --border-primary: #262626;
  --border-secondary: #404040;
  --border-accent: #22d3ee;

  --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.5);
  --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.7);
  --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.8);
  --shadow-glow: 0 0 20px rgba(34, 211, 238, 0.3);

  /* Typography scale */
  --font-mono: 'JetBrains Mono', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
  --font-sans: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

  /* Spacing and sizing */
  --border-radius: 0.25rem;
  --border-radius-lg: 0.5rem;

  /* Animation durations */
  --duration-fast: 150ms;
  --duration-medium: 300ms;
  --duration-slow: 500ms;

  /* Z-index scale */
  --z-dropdown: 1000;
  --z-modal: 1050;
  --z-popover: 1100;
  --z-tooltip: 1200;
}

/* I'm establishing base styles for the entire application */
* {
  box-sizing: border-box;
}

html {
  height: 100%;
  scroll-behavior: smooth;
}

body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: var(--font-sans);
  background-color: var(--bg-primary);
  color: var(--text-primary);
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
}

/* I'm setting up smooth focus management */
*:focus {
  outline: none;
}

*:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}

/* I'm defining typography hierarchy */
h1, h2, h3, h4, h5, h6 {
  margin: 0;
  font-weight: 300;
  letter-spacing: 0.025em;
  line-height: 1.2;
}

h1 { font-size: 2.5rem; }
h2 { font-size: 2rem; }
h3 { font-size: 1.5rem; }
h4 { font-size: 1.25rem; }
h5 { font-size: 1.125rem; }
h6 { font-size: 1rem; }

p {
  margin: 0;
  line-height: 1.6;
}

/* I'm styling code and monospace elements */
code, kbd, samp, pre {
  font-family: var(--font-mono);
  font-size: 0.875em;
}

pre {
  background: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius);
  padding: 1rem;
  overflow-x: auto;
  line-height: 1.4;
}

code {
  background: var(--bg-secondary);
  border-radius: 0.25rem;
  padding: 0.125rem 0.25rem;
  font-size: 0.85em;
}

/* I'm creating smooth link transitions */
a {
  color: var(--color-primary);
  text-decoration: none;
  transition: color var(--duration-fast) ease-in-out;
}

a:hover {
  color: var(--color-secondary);
}

/* I'm establishing form element base styles */
input, textarea, select, button {
  font: inherit;
  color: inherit;
}

input, textarea, select {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius);
  padding: 0.5rem 0.75rem;
  transition: border-color var(--duration-fast) ease-in-out;
}

input:focus, textarea:focus, select:focus {
  border-color: var(--color-primary);
  box-shadow: 0 0 0 2px rgba(34, 211, 238, 0.2);
}

input::placeholder, textarea::placeholder {
  color: var(--text-muted);
}

/* I'm creating custom scrollbar styles */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
  background: var(--border-secondary);
  border-radius: 4px;
  transition: background var(--duration-fast) ease-in-out;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* I'm defining custom animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes slideInLeft {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes slideInRight {
  from {
    opacity: 0;
    transform: translateX(20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@keyframes float {
  0%, 100% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-10px);
  }
}

@keyframes glow {
  0%, 100% {
    box-shadow: 0 0 5px var(--color-primary);
  }
  50% {
    box-shadow: 0 0 20px var(--color-primary);
  }
}

@keyframes matrix-rain {
  0% {
    transform: translateY(-100vh);
    opacity: 0;
  }
  10% {
    opacity: 1;
  }
  90% {
    opacity: 1;
  }
  100% {
    transform: translateY(100vh);
    opacity: 0;
  }
}

/* I'm creating utility animation classes */
.animate-fade-in {
  animation: fadeIn var(--duration-medium) ease-out;
}

.animate-fade-in-up {
  animation: fadeInUp var(--duration-medium) ease-out;
}

.animate-slide-in-left {
  animation: slideInLeft var(--duration-medium) ease-out;
}

.animate-slide-in-right {
  animation: slideInRight var(--duration-medium) ease-out;
}

.animate-pulse-slow {
  animation: pulse 2s ease-in-out infinite;
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

.animate-glow {
  animation: glow 2s ease-in-out infinite;
}

/* I'm defining component base styles */
.card {
  background-color: var(--bg-tertiary);
  border: 1px solid var(--border-primary);
  border-radius: var(--border-radius-lg);
  padding: 1.5rem;
  transition: border-color var(--duration-fast) ease-in-out;
}

.card:hover {
  border-color: var(--border-secondary);
}

.button {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.625rem 1.25rem;
  border-radius: var(--border-radius);
  font-family: var(--font-mono);
  font-size: 0.875rem;
  font-weight: 500;
  letter-spacing: 0.025em;
  text-transform: uppercase;
  transition: all var(--duration-fast) ease-in-out;
  cursor: pointer;
  border: none;
  text-decoration: none;
}

.button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.button-primary {
  background-color: var(--color-primary);
  color: var(--bg-primary);
}

.button-primary:hover:not(:disabled) {
  background-color: var(--color-secondary);
  box-shadow: var(--shadow-glow);
}

.button-secondary {
  background-color: transparent;
  color: var(--text-primary);
  border: 1px solid var(--border-secondary);
}

.button-secondary:hover:not(:disabled) {
  background-color: var(--bg-tertiary);
  border-color: var(--color-primary);
}

.button-ghost {
  background-color: transparent;
  color: var(--text-secondary);
}

.button-ghost:hover:not(:disabled) {
  background-color: var(--bg-secondary);
  color: var(--text-primary);
}

/* I'm creating loading spinner styles */
.spinner {
  width: 2rem;
  height: 2rem;
  border: 2px solid var(--border-primary);
  border-top-color: var(--color-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.spinner-sm {
  width: 1rem;
  height: 1rem;
  border-width: 1px;
}

.spinner-lg {
  width: 3rem;
  height: 3rem;
  border-width: 3px;
}

/* I'm defining modal and overlay styles */
.modal-overlay {
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.8);
  backdrop-filter: blur(4px);
  z-index: var(--z-modal);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem;
}

.modal-content {
  background-color: var(--bg-card);
  border: 1px solid var(--border-secondary);
  border-radius: var(--border-radius-lg);
  max-width: 90vw;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: var(--shadow-lg);
}

/* I'm creating tooltip styles */
.tooltip {
  position: relative;
}

.tooltip::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background-color: var(--bg-card);
  color: var(--text-primary);
  border: 1px solid var(--border-secondary);
  border-radius: var(--border-radius);
  padding: 0.5rem 0.75rem;
  font-size: 0.75rem;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity var(--duration-fast) ease-in-out;
  z-index: var(--z-tooltip);
  margin-bottom: 0.25rem;
}

.tooltip:hover::after {
  opacity: 1;
}

/* I'm creating selection and highlight styles */
::selection {
  background-color: var(--color-primary);
  color: var(--bg-primary);
}

::-moz-selection {
  background-color: var(--color-primary);
  color: var(--bg-primary);
}

/* I'm defining text utility classes */
.text-mono {
  font-family: var(--font-mono);
}

.text-gradient {
  background: linear-gradient(135deg, var(--color-primary), var(--color-secondary));
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
}

.text-glow {
  text-shadow: 0 0 10px currentColor;
}

/* I'm creating layout utilities */
.container {
  width: 100%;
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
  padding-left: 1rem;
  padding-right: 1rem;
}

@media (min-width: 640px) {
  .container {
    padding-left: 1.5rem;
    padding-right: 1.5rem;
  }
}

@media (min-width: 1024px) {
  .container {
    padding-left: 2rem;
    padding-right: 2rem;
  }
}

/* I'm defining responsive grid utilities */
.grid-auto-fit {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
}

.grid-auto-fill {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 1rem;
}

/* I'm creating visual effect utilities */
.backdrop-blur-sm {
  backdrop-filter: blur(4px);
}

.backdrop-blur-md {
  backdrop-filter: blur(8px);
}

.backdrop-blur-lg {
  backdrop-filter: blur(16px);
}

.glass-effect {
  background: rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

/* I'm creating responsive text utilities */
.text-responsive {
  font-size: clamp(1rem, 2.5vw, 1.5rem);
}

.heading-responsive {
  font-size: clamp(2rem, 5vw, 4rem);
}

/* I'm defining focus management for accessibility */
.focus-ring:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}

.focus-ring-inset:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: -2px;
}

/* I'm creating print styles */
@media print {
  * {
    background: transparent !important;
    color: black !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }

  a, a:visited {
    text-decoration: underline;
  }

  .no-print {
    display: none !important;
  }
}

/* I'm handling reduced motion preferences */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

/* I'm creating dark mode specific adjustments */
@media (prefers-color-scheme: dark) {
  /* We're already dark by default, but ensuring consistency */
  body {
    background-color: var(--bg-primary);
    color: var(--text-primary);
  }
}
</file>

<file path="src/utils/animations.ts">
/*
 * Animation utilities providing smooth, eerie transitions and effects that reinforce the dark, contemplative aesthetic throughout the application.
 * I'm implementing performance-optimized animations using CSS transforms and requestAnimationFrame for fluid user interactions without sacrificing the philosophical atmosphere.
 */

interface AnimationConfig {
    duration: number;
    easing: string;
    delay?: number;
    fill?: 'forwards' | 'backwards' | 'both' | 'none';
}

interface SpringConfig {
    tension: number;
    friction: number;
    mass?: number;
}

// I'm creating smooth entrance animations for the dark theme
export const fadeInUp = (element: HTMLElement, config: Partial<AnimationConfig> = {}) => {
    const defaultConfig: AnimationConfig = {
        duration: 800,
        easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
        delay: 0,
        fill: 'forwards'
    };

    const finalConfig = { ...defaultConfig, ...config };

    const keyframes = [
        {
            opacity: 0,
            transform: 'translateY(20px)',
            filter: 'blur(2px)'
        },
        {
            opacity: 1,
            transform: 'translateY(0px)',
            filter: 'blur(0px)'
        }
    ];

    return element.animate(keyframes, {
        duration: finalConfig.duration,
        easing: finalConfig.easing,
        delay: finalConfig.delay,
        fill: finalConfig.fill
    });
};

// I'm implementing staggered animations for list items and grids
export const staggeredFadeIn = (elements: HTMLElement[], staggerDelay: number = 100) => {
    return elements.map((element, index) =>
    fadeInUp(element, { delay: index * staggerDelay })
    );
};

// I'm creating eerie glow effects for interactive elements
export const pulseGlow = (element: HTMLElement, color: string = '#22d3ee') => {
    const keyframes = [
        {
            boxShadow: `0 0 0 0 ${color}00`,
            transform: 'scale(1)'
        },
        {
            boxShadow: `0 0 0 8px ${color}40`,
            transform: 'scale(1.02)'
        },
        {
            boxShadow: `0 0 0 16px ${color}00`,
            transform: 'scale(1)'
        }
    ];

    return element.animate(keyframes, {
        duration: 2000,
        easing: 'ease-in-out',
        iterations: Infinity
    });
};

// I'm implementing smooth morphing transitions
export const morphTransition = (
    element: HTMLElement,
    fromState: Partial<CSSStyleDeclaration>,
    toState: Partial<CSSStyleDeclaration>,
    config: Partial<AnimationConfig> = {}
) => {
    const defaultConfig: AnimationConfig = {
        duration: 400,
        easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
        fill: 'forwards'
    };

    const finalConfig = { ...defaultConfig, ...config };

    // I'm building keyframes from the state objects
    const keyframes = [
        Object.fromEntries(
            Object.entries(fromState).map(([key, value]) => [key, value])
        ),
        Object.fromEntries(
            Object.entries(toState).map(([key, value]) => [key, value])
        )
    ];

    return element.animate(keyframes, finalConfig);
};

// I'm creating typing animation for code/terminal effects
export const typewriterEffect = async (
    element: HTMLElement,
    text: string,
    speed: number = 50,
    cursor: boolean = true
) => {
    element.textContent = '';

    if (cursor) {
        element.style.borderRight = '2px solid #22d3ee';
        element.style.animation = 'blink 1s infinite';
    }

    for (let i = 0; i <= text.length; i++) {
        element.textContent = text.slice(0, i);
        await new Promise(resolve => setTimeout(resolve, speed));
    }

    if (cursor) {
        setTimeout(() => {
            element.style.borderRight = 'none';
            element.style.animation = 'none';
        }, 500);
    }
};

// I'm implementing parallax scroll effects for depth
export const createParallaxScroll = (elements: { element: HTMLElement; speed: number }[]) => {
    let ticking = false;

    const updateParallax = () => {
        const scrollY = window.pageYOffset;

        elements.forEach(({ element, speed }) => {
            const yPos = -(scrollY * speed);
            element.style.transform = `translateY(${yPos}px)`;
        });

        ticking = false;
    };

    const requestTick = () => {
        if (!ticking) {
            requestAnimationFrame(updateParallax);
            ticking = true;
        }
    };

    window.addEventListener('scroll', requestTick, { passive: true });

    return () => window.removeEventListener('scroll', requestTick);
};

// I'm creating smooth spring animations for interactive feedback
export const springAnimation = (
    element: HTMLElement,
    property: string,
    targetValue: number,
    config: SpringConfig = { tension: 280, friction: 60, mass: 1 }
) => {
    const { tension, friction, mass = 1 } = config;

    let currentValue = 0;
    let velocity = 0;
    let startTime: number;

    const animate = (timestamp: number) => {
        if (!startTime) startTime = timestamp;

        const spring = -tension * (currentValue - targetValue);
        const damper = -friction * velocity;
        const acceleration = (spring + damper) / mass;

        velocity += acceleration * 0.016; // 60fps
        currentValue += velocity * 0.016;

        // I'm applying the animated value to the element
        (element.style as any)[property] = `${currentValue}px`;

        // Continue animation if not settled
        if (Math.abs(velocity) > 0.01 || Math.abs(currentValue - targetValue) > 0.01) {
            requestAnimationFrame(animate);
        }
    };

    requestAnimationFrame(animate);
};

// I'm creating matrix-style digital rain effect for backgrounds
export const createMatrixRain = (canvas: HTMLCanvasElement) => {
    const ctx = canvas.getContext('2d')!;

    // I'm setting up the matrix configuration
    const matrix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}";
    const matrixArray = matrix.split("");

    const fontSize = 14;
    const columns = canvas.width / fontSize;
    const drops: number[] = Array(Math.floor(columns)).fill(1);

    const draw = () => {
        // I'm creating the trailing effect
        ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#22d3ee';
        ctx.font = `${fontSize}px monospace`;

        for (let i = 0; i < drops.length; i++) {
            const text = matrixArray[Math.floor(Math.random() * matrixArray.length)];
            ctx.fillText(text, i * fontSize, drops[i] * fontSize);

            if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                drops[i] = 0;
            }

            drops[i]++;
        }
    };

    const interval = setInterval(draw, 35);

    return () => clearInterval(interval);
};

// I'm implementing smooth page transitions
export const pageTransition = {
    enter: (element: HTMLElement) => {
        return fadeInUp(element, { duration: 600, delay: 100 });
    },

    exit: (element: HTMLElement) => {
        const keyframes = [
            {
                opacity: 1,
                transform: 'translateY(0px)',
                filter: 'blur(0px)'
            },
            {
                opacity: 0,
                transform: 'translateY(-20px)',
                filter: 'blur(1px)'
            }
        ];

        return element.animate(keyframes, {
            duration: 400,
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
                               fill: 'forwards'
        });
    }
};

// I'm creating hover animations for interactive elements
export const hoverAnimations = {
    lift: (element: HTMLElement) => {
        element.style.transition = 'transform 0.2s cubic-bezier(0.4, 0, 0.2, 1)';

        const handleMouseEnter = () => {
            element.style.transform = 'translateY(-2px)';
        };

        const handleMouseLeave = () => {
            element.style.transform = 'translateY(0px)';
        };

        element.addEventListener('mouseenter', handleMouseEnter);
        element.addEventListener('mouseleave', handleMouseLeave);

        return () => {
            element.removeEventListener('mouseenter', handleMouseEnter);
            element.removeEventListener('mouseleave', handleMouseLeave);
        };
    },

    glow: (element: HTMLElement, color: string = '#22d3ee') => {
        element.style.transition = 'box-shadow 0.3s ease-in-out';

        const handleMouseEnter = () => {
            element.style.boxShadow = `0 0 20px ${color}40`;
        };

        const handleMouseLeave = () => {
            element.style.boxShadow = 'none';
        };

        element.addEventListener('mouseenter', handleMouseEnter);
        element.addEventListener('mouseleave', handleMouseLeave);

        return () => {
            element.removeEventListener('mouseenter', handleMouseEnter);
            element.removeEventListener('mouseleave', handleMouseLeave);
        };
    }
};

// I'm adding global CSS animations via JavaScript
export const injectGlobalAnimations = () => {
    const style = document.createElement('style');
    style.textContent = `
    @keyframes blink {
        0%, 50% { border-color: transparent; }
        51%, 100% { border-color: #22d3ee; }
    }

    @keyframes float {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
    }

    @keyframes pulse-slow {
        0%, 100% { opacity: 0.8; }
        50% { opacity: 0.4; }
    }

    @keyframes slide-in-left {
        from { transform: translateX(-100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    @keyframes slide-in-right {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }

    .animate-float { animation: float 3s ease-in-out infinite; }
    .animate-pulse-slow { animation: pulse-slow 2s ease-in-out infinite; }
    .animate-slide-in-left { animation: slide-in-left 0.5s ease-out forwards; }
    .animate-slide-in-right { animation: slide-in-right 0.5s ease-out forwards; }
    `;

    document.head.appendChild(style);
};

// I'm providing animation utilities for SolidJS components
export const solidAnimations = {
    // For use with SolidJS createEffect
    onMount: (element: HTMLElement, animation: string = 'fadeInUp') => {
        switch (animation) {
            case 'fadeInUp':
                return fadeInUp(element);
            case 'pulseGlow':
                return pulseGlow(element);
            default:
                return fadeInUp(element);
        }
    },

    // For conditional animations
    toggle: (element: HTMLElement, condition: boolean, trueAnimation: string, falseAnimation: string) => {
        if (condition) {
            return solidAnimations.onMount(element, trueAnimation);
        } else {
            return solidAnimations.onMount(element, falseAnimation);
        }
    }
};

// I'm exporting performance-optimized animation frame utilities
export const animationFrame = {
    throttle: (callback: () => void, delay: number = 16) => {
        let lastTime = 0;

        return () => {
            const currentTime = Date.now();
            if (currentTime - lastTime >= delay) {
                callback();
                lastTime = currentTime;
            }
        };
    },

    debounce: (callback: () => void, delay: number = 16) => {
        let timeoutId: number;

        return () => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(callback, delay);
        };
    }
};
</file>

<file path="src/utils/canvas.ts">
/*
 * Canvas utilities providing high-performance graphics operations for fractal visualization and interactive mathematical rendering.
 * I'm implementing optimized canvas operations with proper pixel manipulation, coordinate transformations, and rendering pipelines for smooth real-time fractal exploration.
 */

interface CanvasConfig {
  width: number;
  height: number;
  pixelRatio?: number;
  alpha?: boolean;
  antialias?: boolean;
}

interface ColorPalette {
  name: string;
  colors: string[];
  interpolation: 'linear' | 'smooth' | 'stepped';
}

interface RenderingContext {
  canvas: HTMLCanvasElement;
  ctx: CanvasRenderingContext2D;
  imageData: ImageData;
  width: number;
  height: number;
  pixelRatio: number;
}

// I'm creating optimized canvas setup for high-DPI displays
export const createCanvas = (config: CanvasConfig): RenderingContext => {
  const { width, height, pixelRatio = window.devicePixelRatio || 1, alpha = false } = config;
  
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d', { alpha })!;
  
  // I'm setting up high-DPI rendering
  canvas.width = width * pixelRatio;
  canvas.height = height * pixelRatio;
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  
  ctx.scale(pixelRatio, pixelRatio);
  ctx.imageSmoothingEnabled = false; // Sharp pixels for mathematical precision
  
  const imageData = ctx.createImageData(width, height);
  
  return {
    canvas,
    ctx,
    imageData,
    width,
    height,
    pixelRatio
  };
};

// I'm implementing fast pixel manipulation for fractal data
export const setPixel = (imageData: ImageData, x: number, y: number, r: number, g: number, b: number, a: number = 255) => {
  const index = (y * imageData.width + x) * 4;
  imageData.data[index] = r;     // Red
  imageData.data[index + 1] = g; // Green
  imageData.data[index + 2] = b; // Blue
  imageData.data[index + 3] = a; // Alpha
};

// I'm creating efficient batch pixel operations
export const setPixelBatch = (imageData: ImageData, pixels: Array<{x: number, y: number, color: [number, number, number, number]}>) => {
  for (const pixel of pixels) {
    setPixel(imageData, pixel.x, pixel.y, ...pixel.color);
  }
};

// I'm implementing fractal-specific color palettes
export const fractalPalettes: ColorPalette[] = [
  {
    name: 'Eerie Dark',
    colors: ['#000000', '#0a0a0a', '#1a1a2e', '#16213e', '#0f3460'],
    interpolation: 'smooth'
  },
  {
    name: 'Cyber Glow',
    colors: ['#000000', '#001122', '#003366', '#0066cc', '#22d3ee'],
    interpolation: 'smooth'
  },
  {
    name: 'Void Purple',
    colors: ['#000000', '#0d0815', '#1a0f2e', '#2e1065', '#6366f1'],
    interpolation: 'smooth'
  },
  {
    name: 'Matrix Green',
    colors: ['#000000', '#001100', '#003300', '#00ff00', '#66ff66'],
    interpolation: 'linear'
  },
  {
    name: 'Rust Orange',
    colors: ['#000000', '#2d1b0e', '#5d3a1a', '#cc6600', '#ff9900'],
    interpolation: 'smooth'
  }
];

// I'm creating smooth color interpolation for iteration mapping
export const interpolateColor = (
  color1: [number, number, number],
  color2: [number, number, number],
  factor: number
): [number, number, number] => {
  const [r1, g1, b1] = color1;
  const [r2, g2, b2] = color2;
  
  return [
    Math.round(r1 + (r2 - r1) * factor),
    Math.round(g1 + (g2 - g1) * factor),
    Math.round(b1 + (b2 - b1) * factor)
  ];
};

// I'm implementing palette-based coloring for fractal iterations
export const getColorFromPalette = (
  iterations: number,
  maxIterations: number,
  palette: ColorPalette
): [number, number, number, number] => {
  if (iterations === maxIterations) {
    return [0, 0, 0, 255]; // Black for points in the set
  }
  
  const normalizedIterations = iterations / maxIterations;
  const colorCount = palette.colors.length;
  
  if (palette.interpolation === 'stepped') {
    const colorIndex = Math.floor(normalizedIterations * (colorCount - 1));
    const color = hexToRgb(palette.colors[colorIndex]);
    return [...color, 255] as [number, number, number, number];
  }
  
  // Smooth interpolation between colors
  const position = normalizedIterations * (colorCount - 1);
  const colorIndex = Math.floor(position);
  const factor = position - colorIndex;
  
  const color1 = hexToRgb(palette.colors[Math.min(colorIndex, colorCount - 1)]);
  const color2 = hexToRgb(palette.colors[Math.min(colorIndex + 1, colorCount - 1)]);
  
  const interpolated = interpolateColor(color1, color2, factor);
  return [...interpolated, 255] as [number, number, number, number];
};

// I'm implementing coordinate transformations for fractal navigation
export const screenToComplex = (
  screenX: number,
  screenY: number,
  width: number,
  height: number,
  centerReal: number,
  centerImag: number,
  zoom: number
): { real: number; imag: number } => {
  const scale = 4.0 / zoom;
  const real = centerReal + (screenX - width / 2) * scale / width;
  const imag = centerImag + (screenY - height / 2) * scale / height;
  
  return { real, imag };
};

// I'm implementing reverse coordinate transformation
export const complexToScreen = (
  real: number,
  imag: number,
  width: number,
  height: number,
  centerReal: number,
  centerImag: number,
  zoom: number
): { x: number; y: number } => {
  const scale = 4.0 / zoom;
  const x = (real - centerReal) * width / scale + width / 2;
  const y = (imag - centerImag) * height / scale + height / 2;
  
  return { x, y };
};

// I'm creating efficient fractal rendering from backend data
export const renderFractalData = (
  ctx: RenderingContext,
  fractalData: number[],
  width: number,
  height: number,
  palette: ColorPalette = fractalPalettes[0]
) => {
  const { imageData } = ctx;
  
  // I'm finding the max iteration count for normalization
  const maxIterations = Math.max(...fractalData);
  
  for (let i = 0; i < fractalData.length; i++) {
    const x = i % width;
    const y = Math.floor(i / width);
    const iterations = fractalData[i];
    
    const color = getColorFromPalette(iterations, maxIterations, palette);
    setPixel(imageData, x, y, ...color);
  }
  
  ctx.ctx.putImageData(imageData, 0, 0);
};

// I'm implementing smooth zoom animations for fractal exploration
export const animateZoom = (
  ctx: RenderingContext,
  startZoom: number,
  endZoom: number,
  duration: number,
  onUpdate: (zoom: number) => void
): Promise<void> => {
  return new Promise((resolve) => {
    const startTime = performance.now();
    
    const animate = (currentTime: number) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // I'm using smooth easing for natural zoom feel
      const easeProgress = 1 - Math.pow(1 - progress, 3);
      const currentZoom = startZoom + (endZoom - startZoom) * easeProgress;
      
      onUpdate(currentZoom);
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        resolve();
      }
    };
    
    requestAnimationFrame(animate);
  });
};

// I'm creating performance optimization utilities
export const canvasOptimizations = {
  // Double buffering for smooth updates
  createDoubleBuffer: (width: number, height: number) => {
    const frontBuffer = createCanvas({ width, height });
    const backBuffer = createCanvas({ width, height });
    
    return {
      front: frontBuffer,
      back: backBuffer,
      swap: () => {
        frontBuffer.ctx.drawImage(backBuffer.canvas, 0, 0);
      }
    };
  },
  
  // Dirty rectangle tracking for partial updates
  createDirtyRegion: () => {
    let minX = Infinity, minY = Infinity;
    let maxX = -Infinity, maxY = -Infinity;
    
    return {
      markDirty: (x: number, y: number, width: number, height: number) => {
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x + width);
        maxY = Math.max(maxY, y + height);
      },
      
      getDirtyRect: () => ({
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      }),
      
      clear: () => {
        minX = minY = Infinity;
        maxX = maxY = -Infinity;
      }
    };
  },
  
  // WebGL context for GPU acceleration (when available)
  createWebGLContext: (canvas: HTMLCanvasElement) => {
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
    
    if (!gl) {
      console.warn('WebGL not supported, falling back to 2D canvas');
      return null;
    }
    
    // I'm setting up basic WebGL state
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    
    return gl;
  }
};

// I'm implementing drawing utilities for UI overlays
export const drawingUtils = {
  // Performance metrics overlay
  drawMetricsOverlay: (
    ctx: CanvasRenderingContext2D,
    metrics: {
      computationTime: number;
      renderTime: number;
      totalPixels: number;
      zoom: number;
    }
  ) => {
    const padding = 10;
    const lineHeight = 16;
    
    ctx.save();
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(padding, padding, 200, 80);
    
    ctx.fillStyle = '#22d3ee';
    ctx.font = '12px monospace';
    ctx.fillText(`Computation: ${metrics.computationTime}ms`, padding + 5, padding + lineHeight);
    ctx.fillText(`Render: ${metrics.renderTime}ms`, padding + 5, padding + lineHeight * 2);
    ctx.fillText(`Pixels: ${metrics.totalPixels.toLocaleString()}`, padding + 5, padding + lineHeight * 3);
    ctx.fillText(`Zoom: ${metrics.zoom.toExponential(2)}`, padding + 5, padding + lineHeight * 4);
    ctx.restore();
  },
  
  // Crosshair for precise navigation
  drawCrosshair: (ctx: CanvasRenderingContext2D, x: number, y: number, size: number = 20) => {
    ctx.save();
    ctx.strokeStyle = '#22d3ee';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    
    ctx.beginPath();
    ctx.moveTo(x - size, y);
    ctx.lineTo(x + size, y);
    ctx.moveTo(x, y - size);
    ctx.lineTo(x, y + size);
    ctx.stroke();
    ctx.restore();
  },
  
  // Selection rectangle for zoom regions
  drawSelectionRect: (
    ctx: CanvasRenderingContext2D,
    startX: number,
    startY: number,
    endX: number,
    endY: number
  ) => {
    ctx.save();
    ctx.strokeStyle = '#22d3ee';
    ctx.fillStyle = 'rgba(34, 211, 238, 0.1)';
    ctx.lineWidth = 2;
    
    const width = endX - startX;
    const height = endY - startY;
    
    ctx.fillRect(startX, startY, width, height);
    ctx.strokeRect(startX, startY, width, height);
    ctx.restore();
  }
};

// I'm providing utility functions for color manipulation
export const colorUtils = {
  hexToRgb: (hex: string): [number, number, number] => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result
      ? [
          parseInt(result[1], 16),
          parseInt(result[2], 16),
          parseInt(result[3], 16)
        ]
      : [0, 0, 0];
  },
  
  rgbToHex: (r: number, g: number, b: number): string => {
    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
  },
  
  hslToRgb: (h: number, s: number, l: number): [number, number, number] => {
    h /= 360;
    s /= 100;
    l /= 100;
    
    const hue2rgb = (p: number, q: number, t: number) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };
    
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    
    return [
      Math.round(hue2rgb(p, q, h + 1/3) * 255),
      Math.round(hue2rgb(p, q, h) * 255),
      Math.round(hue2rgb(p, q, h - 1/3) * 255)
    ];
  }
};

// I'm re-exporting the hexToRgb function for backward compatibility
export const hexToRgb = colorUtils.hexToRgb;

// I'm creating image export utilities
export const exportUtils = {
  canvasToBlob: (canvas: HTMLCanvasElement, quality: number = 0.9): Promise<Blob> => {
    return new Promise((resolve) => {
      canvas.toBlob((blob) => {
        resolve(blob!);
      }, 'image/png', quality);
    });
  },
  
  downloadCanvas: async (canvas: HTMLCanvasElement, filename: string = 'fractal.png') => {
    const blob = await exportUtils.canvasToBlob(canvas);
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.click();
    
    URL.revokeObjectURL(url);
  },
  
  canvasToDataURL: (canvas: HTMLCanvasElement, format: string = 'image/png'): string => {
    return canvas.toDataURL(format);
  }
};
</file>

<file path="src/utils/performance.ts">
/*
 * Comprehensive performance monitoring utilities providing real-time metrics collection, analysis, and optimization insights for the showcase application.
 * I'm implementing client-side performance tracking, system resource monitoring, and computational efficiency analysis that aligns with the philosophical focus on precision and measurement inherent in the dark aesthetic.
 */

interface PerformanceMetric {
  name: string;
  value: number;
  unit: string;
  timestamp: number;
  context?: string;
}

interface SystemResources {
  cpuUsage?: number;
  memoryUsage?: number;
  networkLatency?: number;
  diskIO?: number;
  gpuUsage?: number;
}

interface PerformanceSnapshot {
  timestamp: number;
  metrics: PerformanceMetric[];
  resources: SystemResources;
  userAgent: string;
  url: string;
}

interface BenchmarkResult {
  name: string;
  duration: number;
  iterations: number;
  averageTime: number;
  minTime: number;
  maxTime: number;
  standardDeviation: number;
  samples: number[];
}

class PerformanceMonitor {
  private metrics: PerformanceMetric[] = [];
  private observers: PerformanceObserver[] = [];
  private benchmarks: Map<string, number[]> = new Map();
  private isMonitoring: boolean = false;

  constructor() {
    this.initializeObservers();
  }

  // I'm setting up comprehensive performance observers
  private initializeObservers() {
    if (typeof PerformanceObserver === 'undefined') {
      console.warn('PerformanceObserver not supported');
      return;
    }

    try {
      // Navigation timing observer
      const navigationObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
          if (entry.entryType === 'navigation') {
            this.recordNavigationMetrics(entry as PerformanceNavigationTiming);
          }
        });
      });
      navigationObserver.observe({ entryTypes: ['navigation'] });
      this.observers.push(navigationObserver);

      // Resource timing observer
      const resourceObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
          if (entry.entryType === 'resource') {
            this.recordResourceMetric(entry as PerformanceResourceTiming);
          }
        });
      });
      resourceObserver.observe({ entryTypes: ['resource'] });
      this.observers.push(resourceObserver);

      // Measure observer for custom metrics
      const measureObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
          if (entry.entryType === 'measure') {
            this.recordMeasure(entry as PerformanceMeasure);
          }
        });
      });
      measureObserver.observe({ entryTypes: ['measure'] });
      this.observers.push(measureObserver);

      // Paint timing observer
      const paintObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
          this.recordPaintMetric(entry as PerformancePaintTiming);
        });
      });
      paintObserver.observe({ entryTypes: ['paint'] });
      this.observers.push(paintObserver);

    } catch (error) {
      console.warn('Failed to initialize performance observers:', error);
    }
  }

  // I'm recording navigation timing metrics
  private recordNavigationMetrics(entry: PerformanceNavigationTiming) {
    const metrics = [
      { name: 'dns_lookup', value: entry.domainLookupEnd - entry.domainLookupStart, unit: 'ms' },
      { name: 'tcp_connect', value: entry.connectEnd - entry.connectStart, unit: 'ms' },
      { name: 'request_response', value: entry.responseEnd - entry.requestStart, unit: 'ms' },
      { name: 'dom_content_loaded', value: entry.domContentLoadedEventEnd - entry.domContentLoadedEventStart, unit: 'ms' },
      { name: 'load_complete', value: entry.loadEventEnd - entry.loadEventStart, unit: 'ms' },
      { name: 'total_load_time', value: entry.loadEventEnd - entry.navigationStart, unit: 'ms' }
    ];

    metrics.forEach(metric => this.addMetric(metric.name, metric.value, metric.unit, 'navigation'));
  }

  // I'm recording resource loading metrics
  private recordResourceMetric(entry: PerformanceResourceTiming) {
    const resourceType = this.getResourceType(entry.name);
    const duration = entry.responseEnd - entry.startTime;

    this.addMetric(
      `resource_load_${resourceType}`,
      duration,
      'ms',
      `resource: ${entry.name}`
    );
  }

  // I'm recording custom measurements
  private recordMeasure(entry: PerformanceMeasure) {
    this.addMetric(
      entry.name,
      entry.duration,
      'ms',
      'custom_measure'
    );
  }

  // I'm recording paint timing metrics
  private recordPaintMetric(entry: PerformancePaintTiming) {
    this.addMetric(
      entry.name.replace('-', '_'),
      entry.startTime,
      'ms',
      'paint'
    );
  }

  // I'm providing utility to determine resource type
  private getResourceType(url: string): string {
    if (url.includes('.js')) return 'script';
    if (url.includes('.css')) return 'stylesheet';
    if (url.match(/\.(png|jpg|jpeg|gif|svg|webp)$/)) return 'image';
    if (url.includes('.woff')) return 'font';
    if (url.includes('/api/')) return 'api';
    return 'other';
  }

  // I'm adding metrics to the collection
  addMetric(name: string, value: number, unit: string, context?: string) {
    const metric: PerformanceMetric = {
      name,
      value,
      unit,
      timestamp: Date.now(),
      context
    };

    this.metrics.push(metric);

    // Keep only last 1000 metrics to prevent memory bloat
    if (this.metrics.length > 1000) {
      this.metrics = this.metrics.slice(-1000);
    }
  }

  // I'm implementing timing utilities for custom measurements
  time(name: string): () => void {
    const startTime = performance.now();
    
    return () => {
      const duration = performance.now() - startTime;
      this.addMetric(name, duration, 'ms', 'custom_timing');
    };
  }

  // I'm providing async timing wrapper
  async timeAsync<T>(name: string, operation: () => Promise<T>): Promise<T> {
    const startTime = performance.now();
    
    try {
      const result = await operation();
      const duration = performance.now() - startTime;
      this.addMetric(name, duration, 'ms', 'async_operation');
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      this.addMetric(`${name}_error`, duration, 'ms', 'async_operation_error');
      throw error;
    }
  }

  // I'm implementing benchmark utilities
  benchmark(name: string, iterations: number, operation: () => void): BenchmarkResult {
    const samples: number[] = [];
    
    // Warm up
    for (let i = 0; i < Math.min(iterations, 10); i++) {
      operation();
    }

    // Actual benchmarking
    for (let i = 0; i < iterations; i++) {
      const start = performance.now();
      operation();
      const duration = performance.now() - start;
      samples.push(duration);
    }

    // Calculate statistics
    const totalDuration = samples.reduce((sum, sample) => sum + sample, 0);
    const averageTime = totalDuration / samples.length;
    const minTime = Math.min(...samples);
    const maxTime = Math.max(...samples);
    
    // Calculate standard deviation
    const variance = samples.reduce((sum, sample) => sum + Math.pow(sample - averageTime, 2), 0) / samples.length;
    const standardDeviation = Math.sqrt(variance);

    const result: BenchmarkResult = {
      name,
      duration: totalDuration,
      iterations,
      averageTime,
      minTime,
      maxTime,
      standardDeviation,
      samples
    };

    // Store benchmark results
    this.benchmarks.set(name, samples);
    this.addMetric(`benchmark_${name}`, averageTime, 'ms', 'benchmark');

    return result;
  }

  // I'm implementing memory usage monitoring
  getMemoryUsage(): any {
    if ('memory' in performance) {
      const memory = (performance as any).memory;
      return {
        usedJSHeapSize: memory.usedJSHeapSize,
        totalJSHeapSize: memory.totalJSHeapSize,
        jsHeapSizeLimit: memory.jsHeapSizeLimit,
        usage_percentage: (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100
      };
    }
    return null;
  }

  // I'm implementing Web Vitals monitoring
  getWebVitals(): Promise<any> {
    return new Promise((resolve) => {
      const vitals = {
        fcp: 0,
        lcp: 0,
        fid: 0,
        cls: 0,
        ttfb: 0
      };

      // First Contentful Paint
      const paintEntries = performance.getEntriesByType('paint');
      const fcpEntry = paintEntries.find(entry => entry.name === 'first-contentful-paint');
      if (fcpEntry) {
        vitals.fcp = fcpEntry.startTime;
      }

      // Time to First Byte
      const navigationEntries = performance.getEntriesByType('navigation');
      if (navigationEntries.length > 0) {
        const navEntry = navigationEntries[0] as PerformanceNavigationTiming;
        vitals.ttfb = navEntry.responseStart - navEntry.requestStart;
      }

      // Observer for LCP
      if ('PerformanceObserver' in window) {
        const lcpObserver = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          const lastEntry = entries[entries.length - 1];
          vitals.lcp = lastEntry.startTime;
        });

        try {
          lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
        } catch (e) {
          console.warn('LCP observer not supported');
        }

        // Observer for FID
        const fidObserver = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          entries.forEach((entry) => {
            vitals.fid = entry.processingStart - entry.startTime;
          });
        });

        try {
          fidObserver.observe({ entryTypes: ['first-input'] });
        } catch (e) {
          console.warn('FID observer not supported');
        }

        // Observer for CLS
        const clsObserver = new PerformanceObserver((list) => {
          const entries = list.getEntries();
          entries.forEach((entry: any) => {
            if (!entry.hadRecentInput) {
              vitals.cls += entry.value;
            }
          });
        });

        try {
          clsObserver.observe({ entryTypes: ['layout-shift'] });
        } catch (e) {
          console.warn('CLS observer not supported');
        }
      }

      setTimeout(() => {
        resolve(vitals);
      }, 100);
    });
  }

  // I'm providing metrics querying utilities
  getMetrics(filter?: {
    name?: string;
    context?: string;
    since?: number;
    limit?: number;
  }): PerformanceMetric[] {
    let filtered = this.metrics;

    if (filter) {
      if (filter.name) {
        filtered = filtered.filter(m => m.name.includes(filter.name!));
      }
      if (filter.context) {
        filtered = filtered.filter(m => m.context?.includes(filter.context!));
      }
      if (filter.since) {
        filtered = filtered.filter(m => m.timestamp > filter.since!);
      }
      if (filter.limit) {
        filtered = filtered.slice(-filter.limit);
      }
    }

    return filtered;
  }

  // I'm providing performance snapshot functionality
  getSnapshot(): PerformanceSnapshot {
    return {
      timestamp: Date.now(),
      metrics: [...this.metrics],
      resources: {
        memoryUsage: this.getMemoryUsage()?.usage_percentage,
        // Other resources would be populated by system monitoring
      },
      userAgent: navigator.userAgent,
      url: window.location.href
    };
  }

  // I'm implementing cleanup
  dispose() {
    this.observers.forEach(observer => observer.disconnect());
    this.observers = [];
    this.metrics = [];
    this.benchmarks.clear();
  }
}

// I'm creating a global performance monitor instance
export const performanceMonitor = new PerformanceMonitor();

// I'm providing utility functions for common performance tasks
export const performanceUtils = {
  // Measure function execution time
  measure: <T>(name: string, fn: () => T): T => {
    const stop = performanceMonitor.time(name);
    const result = fn();
    stop();
    return result;
  },

  // Measure async function execution time
  measureAsync: async <T>(name: string, fn: () => Promise<T>): Promise<T> => {
    return performanceMonitor.timeAsync(name, fn);
  },

  // Monitor frame rate
  monitorFPS: (callback: (fps: number) => void, duration: number = 1000) => {
    let frameCount = 0;
    let lastTime = performance.now();

    const measureFrame = () => {
      frameCount++;
      const currentTime = performance.now();
      
      if (currentTime - lastTime >= duration) {
        const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        callback(fps);
        frameCount = 0;
        lastTime = currentTime;
      }
      
      requestAnimationFrame(measureFrame);
    };

    requestAnimationFrame(measureFrame);
  },

  // Monitor memory usage
  monitorMemory: (callback: (usage: any) => void, interval: number = 1000) => {
    const monitor = () => {
      const usage = performanceMonitor.getMemoryUsage();
      if (usage) {
        callback(usage);
      }
    };

    monitor();
    const intervalId = setInterval(monitor, interval);
    return () => clearInterval(intervalId);
  },

  // Detect performance issues
  detectPerformanceIssues: (): string[] => {
    const issues: string[] = [];
    const metrics = performanceMonitor.getMetrics({ limit: 100 });

    // Check for slow API calls
    const apiMetrics = metrics.filter(m => m.context === 'api');
    const slowAPICalls = apiMetrics.filter(m => m.value > 1000);
    if (slowAPICalls.length > 0) {
      issues.push(`Slow API calls detected: ${slowAPICalls.length} calls > 1000ms`);
    }

    // Check for memory issues
    const memoryUsage = performanceMonitor.getMemoryUsage();
    if (memoryUsage && memoryUsage.usage_percentage > 80) {
      issues.push(`High memory usage: ${memoryUsage.usage_percentage.toFixed(1)}%`);
    }

    // Check for slow render times
    const renderMetrics = metrics.filter(m => m.name.includes('render'));
    const slowRenders = renderMetrics.filter(m => m.value > 16); // 60fps = 16ms per frame
    if (slowRenders.length > 5) {
      issues.push(`Slow rendering detected: ${slowRenders.length} renders > 16ms`);
    }

    return issues;
  },

  // Get performance grade
  getPerformanceGrade: (): { grade: string; score: number; details: any } => {
    const metrics = performanceMonitor.getMetrics({ limit: 100 });
    
    // Calculate scores for different aspects
    const scores = {
      loading: 100,
      rendering: 100,
      memory: 100,
      network: 100
    };

    // Adjust scores based on metrics
    const loadMetrics = metrics.filter(m => m.name.includes('load'));
    const avgLoadTime = loadMetrics.reduce((sum, m) => sum + m.value, 0) / loadMetrics.length;
    if (avgLoadTime > 1000) scores.loading = Math.max(0, 100 - (avgLoadTime - 1000) / 10);

    const renderMetrics = metrics.filter(m => m.name.includes('render'));
    const avgRenderTime = renderMetrics.reduce((sum, m) => sum + m.value, 0) / renderMetrics.length;
    if (avgRenderTime > 16) scores.rendering = Math.max(0, 100 - (avgRenderTime - 16) * 2);

    const memoryUsage = performanceMonitor.getMemoryUsage();
    if (memoryUsage) {
      scores.memory = Math.max(0, 100 - memoryUsage.usage_percentage);
    }

    const totalScore = Object.values(scores).reduce((sum, score) => sum + score, 0) / 4;
    
    let grade = 'F';
    if (totalScore >= 90) grade = 'A';
    else if (totalScore >= 80) grade = 'B';
    else if (totalScore >= 70) grade = 'C';
    else if (totalScore >= 60) grade = 'D';

    return { grade, score: totalScore, details: scores };
  }
};

// I'm providing React/SolidJS integration utilities
export const usePerformanceMonitoring = () => {
  return {
    monitor: performanceMonitor,
    utils: performanceUtils,
    
    // Hook for measuring component render time
    measureRender: (componentName: string) => {
      const startTime = performance.now();
      
      return () => {
        const duration = performance.now() - startTime;
        performanceMonitor.addMetric(
          `render_${componentName}`,
          duration,
          'ms',
          'component_render'
        );
      };
    },

    // Hook for measuring effect execution time
    measureEffect: (effectName: string, fn: () => void) => {
      const stop = performanceMonitor.time(`effect_${effectName}`);
      fn();
      stop();
    }
  };
};

// I'm exporting types and interfaces
export type {
  PerformanceMetric,
  SystemResources,
  PerformanceSnapshot,
  BenchmarkResult
};
</file>

<file path="src/utils/theme.ts">
/*
 * Theme management utilities providing consistent dark aesthetic, color systems, and visual hierarchy throughout the application.
 * I'm implementing the eerie, contemplative Mr. Robot-inspired design system with programmatic theme switching and dynamic color generation for the philosophical atmosphere.
 */

interface ColorPalette {
  name: string;
  primary: string;
  secondary: string;
  accent: string;
  background: {
    primary: string;
    secondary: string;
    tertiary: string;
  };
  text: {
    primary: string;
    secondary: string;
    tertiary: string;
    muted: string;
  };
  border: {
    primary: string;
    secondary: string;
    accent: string;
  };
  semantic: {
    success: string;
    warning: string;
    error: string;
    info: string;
  };
}

interface TypographyScale {
  xs: string;
  sm: string;
  base: string;
  lg: string;
  xl: string;
  '2xl': string;
  '3xl': string;
  '4xl': string;
  '5xl': string;
  '6xl': string;
}

interface SpacingScale {
  '0': string;
  '1': string;
  '2': string;
  '3': string;
  '4': string;
  '6': string;
  '8': string;
  '12': string;
  '16': string;
  '20': string;
  '24': string;
  '32': string;
}

// I'm defining the core dark theme palette inspired by Mr. Robot's aesthetic
export const darkTheme: ColorPalette = {
  name: 'Dark Contemplation',
  primary: '#22d3ee', // Cyan accent for technical elements
  secondary: '#6366f1', // Indigo for secondary actions
  accent: '#a855f7', // Purple for highlights and special elements
  background: {
    primary: '#000000', // Pure black for maximum contrast
    secondary: '#0a0a0a', // Subtle variation for layering
    tertiary: '#171717', // Cards and elevated surfaces
  },
  text: {
    primary: '#f5f5f5', // Almost white for primary text
    secondary: '#a3a3a3', // Gray for secondary text
    tertiary: '#737373', // Darker gray for tertiary text
    muted: '#525252', // Muted text for less important info
  },
  border: {
    primary: '#262626', // Subtle borders
    secondary: '#404040', // More visible borders
    accent: '#22d3ee', // Accent borders for highlights
  },
  semantic: {
    success: '#22c55e', // Green for success states
    warning: '#f59e0b', // Amber for warnings
    error: '#ef4444', // Red for errors
    info: '#3b82f6', // Blue for informational states
  }
};

// I'm creating alternative theme variations for different moods
export const themeVariations = {
  matrix: {
    ...darkTheme,
    name: 'Matrix Code',
    primary: '#00ff00',
    accent: '#66ff66',
    background: {
      primary: '#000000',
      secondary: '#001100',
      tertiary: '#002200',
    }
  },

  cyberpunk: {
    ...darkTheme,
    name: 'Cyberpunk Neon',
    primary: '#ff0080',
    secondary: '#8000ff',
    accent: '#00ffff',
    background: {
      primary: '#0a0a0a',
      secondary: '#1a0a1a',
      tertiary: '#2a1a2a',
    }
  },

  void: {
    ...darkTheme,
    name: 'Void Meditation',
    primary: '#6366f1',
    secondary: '#8b5cf6',
    accent: '#a855f7',
    background: {
      primary: '#000000',
      secondary: '#0f0f0f',
      tertiary: '#1f1f1f',
    }
  }
};

// I'm defining typography scales for consistent text hierarchy
export const typography: TypographyScale = {
  xs: '0.75rem',    // 12px
  sm: '0.875rem',   // 14px
  base: '1rem',     // 16px
  lg: '1.125rem',   // 18px
  xl: '1.25rem',    // 20px
  '2xl': '1.5rem',  // 24px
  '3xl': '1.875rem', // 30px
  '4xl': '2.25rem', // 36px
  '5xl': '3rem',    // 48px
  '6xl': '4rem',    // 64px
};

// I'm defining spacing scale for consistent layout
export const spacing: SpacingScale = {
  '0': '0',
  '1': '0.25rem', // 4px
  '2': '0.5rem',  // 8px
  '3': '0.75rem', // 12px
  '4': '1rem',    // 16px
  '6': '1.5rem',  // 24px
  '8': '2rem',    // 32px
  '12': '3rem',   // 48px
  '16': '4rem',   // 64px
  '20': '5rem',   // 80px
  '24': '6rem',   // 96px
  '32': '8rem',   // 128px
};

// I'm creating CSS custom properties for dynamic theming
export const generateCSSVariables = (theme: ColorPalette): string => {
  return `
    :root {
      --color-primary: ${theme.primary};
      --color-secondary: ${theme.secondary};
      --color-accent: ${theme.accent};

      --bg-primary: ${theme.background.primary};
      --bg-secondary: ${theme.background.secondary};
      --bg-tertiary: ${theme.background.tertiary};

      --text-primary: ${theme.text.primary};
      --text-secondary: ${theme.text.secondary};
      --text-tertiary: ${theme.text.tertiary};
      --text-muted: ${theme.text.muted};

      --border-primary: ${theme.border.primary};
      --border-secondary: ${theme.border.secondary};
      --border-accent: ${theme.border.accent};

      --color-success: ${theme.semantic.success};
      --color-warning: ${theme.semantic.warning};
      --color-error: ${theme.semantic.error};
      --color-info: ${theme.semantic.info};

      /* Typography scale */
      ${Object.entries(typography).map(([key, value]) =>
        `--text-${key}: ${value};`
      ).join('\n      ')}

      /* Spacing scale */
      ${Object.entries(spacing).map(([key, value]) =>
        `--space-${key}: ${value};`
      ).join('\n      ')}
    }
  `;
};

// I'm creating theme application utilities
export const applyTheme = (theme: ColorPalette = darkTheme) => {
  const style = document.createElement('style');
  style.id = 'theme-variables';

  // Remove existing theme if present
  const existing = document.getElementById('theme-variables');
  if (existing) {
    existing.remove();
  }

  style.textContent = generateCSSVariables(theme);
  document.head.appendChild(style);

  // I'm also updating the document class for theme-specific styles
  document.documentElement.className = `theme-${theme.name.toLowerCase().replace(/\s+/g, '-')}`;
};

// I'm creating dynamic color utilities for programmatic styling
export const colorUtils = {
  // Convert hex to HSL for programmatic manipulation
  hexToHsl: (hex: string): [number, number, number] => {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0, s = 0, l = (max + min) / 2;

    if (max !== min) {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }

    return [h * 360, s * 100, l * 100];
  },

  // Generate color variations
  lighten: (hex: string, amount: number): string => {
    const [h, s, l] = colorUtils.hexToHsl(hex);
    return colorUtils.hslToHex(h, s, Math.min(100, l + amount));
  },

  darken: (hex: string, amount: number): string => {
    const [h, s, l] = colorUtils.hexToHsl(hex);
    return colorUtils.hslToHex(h, s, Math.max(0, l - amount));
  },

  // Convert HSL back to hex
  hslToHex: (h: number, s: number, l: number): string => {
    h = h % 360;
    s = Math.max(0, Math.min(100, s)) / 100;
    l = Math.max(0, Math.min(100, l)) / 100;

    const c = (1 - Math.abs(2 * l - 1)) * s;
    const x = c * (1 - Math.abs((h / 60) % 2 - 1));
    const m = l - c / 2;

    let r = 0, g = 0, b = 0;

    if (0 <= h && h < 60) {
      r = c; g = x; b = 0;
    } else if (60 <= h && h < 120) {
      r = x; g = c; b = 0;
    } else if (120 <= h && h < 180) {
      r = 0; g = c; b = x;
    } else if (180 <= h && h < 240) {
      r = 0; g = x; b = c;
    } else if (240 <= h && h < 300) {
      r = x; g = 0; b = c;
    } else if (300 <= h && h < 360) {
      r = c; g = 0; b = x;
    }

    const red = Math.round((r + m) * 255);
    const green = Math.round((g + m) * 255);
    const blue = Math.round((b + m) * 255);

    return `#${red.toString(16).padStart(2, '0')}${green.toString(16).padStart(2, '0')}${blue.toString(16).padStart(2, '0')}`;
  },

  // Add alpha channel to hex color
  addAlpha: (hex: string, alpha: number): string => {
    const alphaHex = Math.round(alpha * 255).toString(16).padStart(2, '0');
    return `${hex}${alphaHex}`;
  },

  // Generate gradient stops
  generateGradient: (startColor: string, endColor: string, steps: number): string[] => {
    const [h1, s1, l1] = colorUtils.hexToHsl(startColor);
    const [h2, s2, l2] = colorUtils.hexToHsl(endColor);

    const colors = [];
    for (let i = 0; i < steps; i++) {
      const ratio = i / (steps - 1);
      const h = h1 + (h2 - h1) * ratio;
      const s = s1 + (s2 - s1) * ratio;
      const l = l1 + (l2 - l1) * ratio;
      colors.push(colorUtils.hslToHex(h, s, l));
    }

    return colors;
  }
};

// I'm creating responsive breakpoint utilities
export const breakpoints = {
  xs: '0px',
  sm: '640px',
  md: '768px',
  lg: '1024px',
  xl: '1280px',
  '2xl': '1536px',
};

// I'm providing theme-aware component utilities
export const themeComponents = {
  // Generate button variants based on current theme
  generateButtonStyles: (theme: ColorPalette) => ({
    primary: {
      backgroundColor: theme.primary,
      color: theme.background.primary,
      border: `1px solid ${theme.primary}`,
      '&:hover': {
        backgroundColor: colorUtils.lighten(theme.primary, 10),
      }
    },
    secondary: {
      backgroundColor: 'transparent',
      color: theme.text.primary,
      border: `1px solid ${theme.border.secondary}`,
      '&:hover': {
        backgroundColor: theme.background.tertiary,
      }
    },
    ghost: {
      backgroundColor: 'transparent',
      color: theme.text.secondary,
      border: 'none',
      '&:hover': {
        backgroundColor: theme.background.secondary,
        color: theme.text.primary,
      }
    }
  }),

  // Generate card styles
  generateCardStyles: (theme: ColorPalette) => ({
    backgroundColor: theme.background.tertiary,
    border: `1px solid ${theme.border.primary}`,
    color: theme.text.primary,
    '&:hover': {
      borderColor: theme.border.secondary,
    }
  }),

  // Generate input styles
  generateInputStyles: (theme: ColorPalette) => ({
    backgroundColor: theme.background.secondary,
    border: `1px solid ${theme.border.primary}`,
    color: theme.text.primary,
    '&:focus': {
      borderColor: theme.primary,
      outline: 'none',
      boxShadow: `0 0 0 2px ${colorUtils.addAlpha(theme.primary, 0.2)}`,
    },
    '&::placeholder': {
      color: theme.text.muted,
    }
  })
};

// I'm creating theme persistence utilities
export const themeStorage = {
  save: (themeName: string) => {
    try {
      localStorage.setItem('app-theme', themeName);
    } catch (error) {
      console.warn('Failed to save theme preference:', error);
    }
  },

  load: (): string | null => {
    try {
      return localStorage.getItem('app-theme');
    } catch (error) {
      console.warn('Failed to load theme preference:', error);
      return null;
    }
  },

  clear: () => {
    try {
      localStorage.removeItem('app-theme');
    } catch (error) {
      console.warn('Failed to clear theme preference:', error);
    }
  }
};

// I'm providing system theme detection
export const systemTheme = {
  isDarkMode: (): boolean => {
    return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  },

  onChange: (callback: (isDark: boolean) => void) => {
    if (window.matchMedia) {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');

      const handler = (e: MediaQueryListEvent) => {
        callback(e.matches);
      };

      mediaQuery.addEventListener('change', handler);

      return () => mediaQuery.removeEventListener('change', handler);
    }

    return () => {}; // No-op cleanup for unsupported browsers
  }
};

// I'm creating theme initialization with proper defaults
export const initializeTheme = () => {
  // Check for saved preference first
  const savedTheme = themeStorage.load();

  if (savedTheme) {
    const theme = Object.values({ darkTheme, ...themeVariations })
      .find(t => t.name === savedTheme) || darkTheme;
    applyTheme(theme);
    return;
  }

  // Fall back to system preference or default dark theme
  const isDarkSystem = systemTheme.isDarkMode();
  applyTheme(darkTheme); // Always use dark theme for this app's aesthetic

  // Listen for system theme changes
  systemTheme.onChange((isDark) => {
    // We always stay dark for this app, but could adjust intensity
    // For now, just maintain the dark theme
    applyTheme(darkTheme);
  });
};

// I'm providing Tailwind CSS integration utilities
export const tailwindIntegration = {
  // Generate Tailwind config extensions for our theme
  generateTailwindTheme: (theme: ColorPalette) => ({
    extend: {
      colors: {
        primary: theme.primary,
        secondary: theme.secondary,
        accent: theme.accent,
        'bg-primary': theme.background.primary,
        'bg-secondary': theme.background.secondary,
        'bg-tertiary': theme.background.tertiary,
        'text-primary': theme.text.primary,
        'text-secondary': theme.text.secondary,
        'text-tertiary': theme.text.tertiary,
        'text-muted': theme.text.muted,
      },
      fontFamily: {
        mono: ['JetBrains Mono', 'Menlo', 'Monaco', 'monospace'],
      },
      animation: {
        'pulse-slow': 'pulse 3s ease-in-out infinite',
        'float': 'float 6s ease-in-out infinite',
      }
    }
  })
};

// Export the default theme and initialization function
export { darkTheme as defaultTheme, initializeTheme as init };
</file>

<file path="src/app.css">
/*
 * Main application stylesheet implementing the complete dark performance showcase theme with advanced CSS custom properties and animations.
 * I'm establishing comprehensive theming system with CSS variables, sophisticated animations, and accessibility considerations for the eerie aesthetic.
 */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* I'm setting up CSS custom properties for the dark, eerie theme */
:root {
  --background-rgb: 0, 0, 0;
  --foreground-rgb: 245, 245, 245;
  --accent-rgb: 34, 211, 238;
  --secondary-rgb: 99, 102, 241;

  /* I'm defining the color palette for consistent theming */
  --color-primary: rgb(var(--accent-rgb));
  --color-secondary: rgb(var(--secondary-rgb));

  --bg-primary: rgb(var(--background-rgb));
  --bg-secondary: rgb(10, 10, 10);
  --bg-tertiary: rgb(23, 23, 23);

  --text-primary: rgb(var(--foreground-rgb));
  --text-secondary: rgb(163, 163, 163);
  --text-tertiary: rgb(115, 115, 115);
  --text-muted: rgb(82, 82, 82);

  --border-primary: rgb(38, 38, 38);
  --border-secondary: rgb(64, 64, 64);

  /* I'm defining font stacks for the technical aesthetic */
  --font-mono: 'JetBrains Mono', 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
  --font-sans: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

/* I'm establishing the dark theme foundation */
body {
  background: rgb(var(--background-rgb));
  color: rgb(var(--foreground-rgb));
  font-family: var(--font-sans);
  line-height: 1.6;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* I'm ensuring all elements follow the dark theme */
* {
  box-sizing: border-box;
}

/* I'm creating smooth focus states for accessibility */
*:focus {
  outline: none;
}

*:focus-visible {
  outline: 2px solid var(--color-primary);
  outline-offset: 2px;
}

/* I'm defining selection colors for the theme */
::selection {
  background-color: var(--color-primary);
  color: var(--bg-primary);
}

::-moz-selection {
  background-color: var(--color-primary);
  color: var(--bg-primary);
}

/* I'm styling scrollbars to match the dark theme */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

::-webkit-scrollbar-thumb {
  background: var(--border-secondary);
  border-radius: 4px;
  transition: background 0.2s ease;
}

::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* I'm creating utility classes for the performance showcase */
.text-mono {
  font-family: var(--font-mono);
}

.text-gradient {
  background: linear-gradient(135deg, var(--color-primary), var(--color-secondary));
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
}

.glass-effect {
  background: rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

/* I'm defining performance-focused animations */
@keyframes fadeInUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes pulse-slow {
  0%, 100% {
    opacity: 0.8;
  }
  50% {
    opacity: 0.4;
  }
}

@keyframes matrix-glow {
  0%, 100% {
    box-shadow: 0 0 5px var(--color-primary);
  }
  50% {
    box-shadow: 0 0 20px var(--color-primary), 0 0 30px var(--color-primary);
  }
}

@keyframes glitchEffect {
  0%, 100% {
    transform: translate(0);
    filter: hue-rotate(0deg);
  }
  20% {
    transform: translate(-2px, 2px);
    filter: hue-rotate(90deg);
  }
  40% {
    transform: translate(-2px, -2px);
    filter: hue-rotate(180deg);
  }
  60% {
    transform: translate(2px, 2px);
    filter: hue-rotate(270deg);
  }
  80% {
    transform: translate(2px, -2px);
    filter: hue-rotate(360deg);
  }
}

.animate-fade-in-up {
  animation: fadeInUp 0.8s ease-out;
}

.animate-pulse-slow {
  animation: pulse-slow 3s ease-in-out infinite;
}

.animate-matrix-glow {
  animation: matrix-glow 2s ease-in-out infinite;
}

.animate-glitch {
  animation: glitchEffect 0.5s ease-in-out;
}

/* I'm adding animation delay utilities */
.animation-delay-150 {
  animation-delay: 150ms;
}

.animation-delay-300 {
  animation-delay: 300ms;
}

.animation-delay-500 {
  animation-delay: 500ms;
}

/* I'm handling reduced motion preferences for accessibility */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

/* I'm ensuring proper dark theme for form elements */
input, textarea, select {
  background-color: var(--bg-secondary);
  border: 1px solid var(--border-primary);
  color: var(--text-primary);
}

input:focus, textarea:focus, select:focus {
  border-color: var(--color-primary);
  box-shadow: 0 0 0 2px rgba(34, 211, 238, 0.2);
}

input::placeholder, textarea::placeholder {
  color: var(--text-muted);
}

/* I'm adding custom component styles */
.performance-card {
  background: rgba(255, 255, 255, 0.02);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.1);
  transition: all 0.3s ease;
}

.performance-card:hover {
  background: rgba(255, 255, 255, 0.05);
  border-color: rgba(34, 211, 238, 0.3);
  box-shadow: 0 0 20px rgba(34, 211, 238, 0.1);
}

.code-block {
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--border-primary);
  font-family: var(--font-mono);
  font-size: 0.875rem;
  line-height: 1.5;
}

.metric-display {
  font-family: var(--font-mono);
  font-weight: 600;
  letter-spacing: 0.05em;
}

/* I'm creating sophisticated loading states */
.loading-pulse {
  background: linear-gradient(90deg,
    rgba(255, 255, 255, 0.1) 25%,
    rgba(34, 211, 238, 0.2) 50%,
    rgba(255, 255, 255, 0.1) 75%
  );
  background-size: 200% 100%;
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}

/* I'm adding sophisticated border effects */
.border-glow {
  position: relative;
}

.border-glow::before {
  content: '';
  position: absolute;
  inset: -1px;
  background: linear-gradient(45deg, var(--color-primary), var(--color-secondary));
  border-radius: inherit;
  z-index: -1;
  opacity: 0.5;
  filter: blur(1px);
}

/* I'm creating responsive typography */
.heading-main {
  font-size: clamp(2rem, 5vw, 4rem);
  font-weight: 300;
  letter-spacing: -0.02em;
  line-height: 1.1;
}

.heading-section {
  font-size: clamp(1.5rem, 3vw, 2.5rem);
  font-weight: 400;
  letter-spacing: -0.01em;
  line-height: 1.2;
}

/* I'm adding performance-optimized transitions */
.transition-performance {
  transition-property: transform, opacity, background-color, border-color, box-shadow;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 0.15s;
}

/* I'm creating dark theme specific adjustments */
@media (prefers-color-scheme: dark) {
  :root {
    color-scheme: dark;
  }
}
</file>

<file path="src/app.tsx">
/*
 * Root application component that serves as the main entry point for SolidStart.
 * This file is required by SolidStart and provides the app shell that wraps all routes automatically.
 */

import { FileRoutes } from "@solidjs/start/router";
import "./app.css";

export default function App() {
  console.log("[App.tsx] SolidStart App component rendering with FileRoutes");

  return (
    <>
      <FileRoutes />
    </>
  );
}
</file>

<file path="src/entry-client.tsx">
// @refresh reload
import { mount, StartClient } from "@solidjs/start/client";

// I'm mounting the SolidStart client without any custom setup since StartClient handles routing internally
mount(() => <StartClient />, document.getElementById("app")!);

// I'm keeping your performance tracking as-is
if (typeof window !== 'undefined') {
  const hydrationStart = (window as any).__PERFORMANCE_START__ || Date.now();
  window.addEventListener('load', () => {
    const hydrationEnd = Date.now();
    const hydrationTime = hydrationEnd - hydrationStart;
    console.log(`[Client] Hydration completed in ${hydrationTime}ms`);
    if ((import.meta.env as any).VITE_PERFORMANCE_ENDPOINT) {
      fetch((import.meta.env as any).VITE_PERFORMANCE_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          metric: { name: 'hydration_time', value: hydrationTime, timestamp: Date.now() },
          url: window.location.href, userAgent: navigator.userAgent,
        }),
      }).catch(() => {});
    }
  });
  window.addEventListener('error', (event) => { console.error('[Client] Runtime error:', event.error); });
  window.addEventListener('unhandledrejection', (event) => { console.error('[Client] Unhandled promise rejection:', event.reason); });
}
</file>

<file path="src/entry-server.tsx">
// @refresh reload
import { createHandler, StartServer } from "@solidjs/start/server";

export default createHandler(() => (
  <StartServer
    document={({ assets, children, scripts }) => (
      <html lang="en" class="dark">
        <head>
          <meta charSet="utf-8" />
          <meta name="viewport" content="width=device-width, initial-scale=1" />
          <meta name="theme-color" content="#000000" />
          <meta name="color-scheme" content="dark" />
          <link rel="icon" href="/favicon.ico" />
          <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400&display=swap" />
          {assets}
        </head>
        <body>
          <div id="app">{children}</div>
          {scripts}
          <script>window.__PERFORMANCE_START__ = Date.now();</script>
        </body>
      </html>
    )}
  />
));
</file>

<file path="src/global.d.ts">
/// <reference types="@solidjs/start/env" />

// I'm extending the global window interface for performance tracking
declare global {
  interface Window {
    __PERFORMANCE_START__?: number;
    fs?: {
      readFile: (path: string, options?: { encoding?: string }) => Promise<Uint8Array | string>;
    };
  }

  // I'm adding environment variable types for the performance showcase
  namespace NodeJS {
    interface ProcessEnv {
      VITE_API_URL?: string;
      VITE_PERFORMANCE_ENDPOINT?: string;
      VITE_GITHUB_TOKEN?: string;
      VITE_BUILD_MODE?: string;
      NODE_ENV: 'development' | 'production' | 'test';
    }
  }

  // I'm extending the Performance API types for advanced metrics
  interface PerformanceEntry {
    hadRecentInput?: boolean;
    value?: number;
    sources?: PerformanceEntrySource[];
  }

  interface PerformanceEntrySource {
    node?: Node;
    previousRect?: DOMRectReadOnly;
    currentRect?: DOMRectReadOnly;
  }

  // I'm adding Web Vitals types for performance monitoring
  interface PerformanceObserver {
    supportedEntryTypes?: string[];
  }

  // I'm extending the Navigator interface for hardware information
  interface Navigator {
    hardwareConcurrency?: number;
    deviceMemory?: number;
    connection?: NetworkInformation;
  }

  interface NetworkInformation {
    effectiveType?: 'slow-2g' | '2g' | '3g' | '4g';
    downlink?: number;
    rtt?: number;
  }
}

// I'm defining module declarations for assets and imports
declare module '*.css' {
  const content: string;
  export default content;
}

declare module '*.scss' {
  const content: string;
  export default content;
}

declare module '*.svg' {
  const content: string;
  export default content;
}

declare module '*.png' {
  const content: string;
  export default content;
}

declare module '*.jpg' {
  const content: string;
  export default content;
}

declare module '*.jpeg' {
  const content: string;
  export default content;
}

declare module '*.webp' {
  const content: string;
  export default content;
}

declare module '*.ico' {
  const content: string;
  export default content;
}

// I'm defining types for the performance showcase API responses
export interface ApiResponse<T = any> {
  data: T;
  timestamp: string;
  duration_ms?: number;
  pagination?: {
    current_page: number;
    total_pages: number;
    total_count: number;
    has_next_page: boolean;
    has_previous_page: boolean;
  };
}

export interface PerformanceMetrics {
  lcp?: number;
  fid?: number;
  cls?: number;
  fcp?: number;
  ttfb?: number;
  [key: string]: number | undefined;
}

export interface SystemMetrics {
  cpu_usage_percent: number;
  memory_usage_percent: number;
  uptime_seconds: number;
  cpu_cores?: number;
  cpu_threads?: number;
  memory_total_gb?: number;
  load_average_1m?: number;
}

// I'm defining fractal computation types
export interface FractalRequest {
  width: number;
  height: number;
  center_x: number;
  center_y: number;
  zoom: number;
  max_iterations: number;
  fractal_type: 'mandelbrot' | 'julia';
}

export interface FractalResponse {
  data: Uint8Array;
  width: number;
  height: number;
  computation_time_ms: number;
  zoom_level: number;
}

// I'm defining GitHub repository types
export interface Repository {
  id: number;
  name: string;
  full_name: string;
  description?: string;
  html_url: string;
  language?: string;
  stargazers_count: number;
  forks_count: number;
  watchers_count: number;
  open_issues_count: number;
  size_kb: number;
  created_at: string;
  updated_at: string;
  pushed_at?: string;
  is_private: boolean;
  is_fork: boolean;
  is_archived: boolean;
  topics: string[];
  license_name?: string;
}

export {};
</file>

<file path=".gitignore">
dist
.wrangler
.output
.vercel
.netlify
.vinxi
app.config.timestamp_*.js

# Environment
.env
.env*.local

# dependencies
/node_modules

# IDEs and editors
/.idea
.project
.classpath
*.launch
.settings/

# Temp
gitignore

# System Files
.DS_Store
Thumbs.db
</file>

<file path="app.config.ts">
import { defineConfig } from "@solidjs/start/config";
import tailwindcss from "tailwindcss";
import autoprefixer from "autoprefixer";

export default defineConfig({
  server: {
    preset: "node",
  },
  vite: {
    resolve: {
      conditions: ['solid', 'development', 'browser', 'module', 'import', 'default', 'node'],
      alias: {
        '~': '/src',
        '@': '/src',
      },
    },
    build: {
      target: 'esnext',
      minify: 'esbuild',
      sourcemap: true,
      rollupOptions: {
        output: {
          manualChunks: {
            vendor: ['solid-js', '@solidjs/router'],
          },
        },
      },
    },
    server: {
      port: 3000,
      host: '0.0.0.0',
      open: false,
      hmr: {
        clientPort: 3000,
      },
    },
    define: {
      __BUILD_TIME__: JSON.stringify(new Date().toISOString()),
      __VERSION__: JSON.stringify(process.env.npm_package_version || '1.0.0'),
    },
    css: {
      postcss: {
        plugins: [
          tailwindcss(),
          autoprefixer(),
        ],
      },
    },
    optimizeDeps: {
      include: ['solid-js'],
      exclude: ['@solidjs/start'],
    },
    esbuild: {
      target: 'esnext',
      drop: process.env.NODE_ENV === 'production' ? ['console', 'debugger'] : [],
    },
  },
  solid: {
    ssr: true,
  },
});
</file>

<file path="Dockerfile.dev">
# frontend/Dockerfile.dev
FROM node:20-alpine

RUN apk add --no-cache \
    git \
    curl \
    python3 \
    make \
    g++ \
    && rm -rf /var/cache/apk/*

WORKDIR /app

COPY package*.json ./

COPY vite-plugin-solid-patch.js ./

RUN npm ci --legacy-peer-deps || npm install --legacy-peer-deps

COPY . .

ENV NODE_ENV=development
ENV VITE_DEV_MODE=true
ENV VITE_API_URL=http://localhost:3001

EXPOSE 3000

CMD ["npm", "run", "dev"]
</file>

<file path="Dockerfile.prod">
FROM node:20-alpine as builder

RUN apk add --no-cache \
    git \
    python3 \
    make \
    g++ \
    && rm -rf /var/cache/apk/*

RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001 -G nodejs

USER nextjs
WORKDIR /app

COPY --chown=nextjs:nodejs package*.json ./

RUN npm ci --only=production --ignore-scripts --prefer-offline --no-audit && \
    npm cache clean --force

COPY --chown=nextjs:nodejs . .

ENV NODE_ENV=production
ENV VITE_BUILD_MODE=production
ENV VITE_OPTIMIZE_DEPS=true
ENV VITE_MINIFY=true

RUN npm run build

RUN du -sh dist/ && \
    find dist/ -name "*.js" -exec wc -c {} + | tail -1 && \
    find dist/ -name "*.css" -exec wc -c {} + | tail -1

FROM node:20-alpine as compressor

RUN apk add --no-cache brotli gzip && \
    rm -rf /var/cache/apk/*

WORKDIR /app

COPY --from=builder /app/dist ./dist

RUN find dist -type f \( -name "*.js" -o -name "*.css" -o -name "*.html" -o -name "*.svg" -o -name "*.json" \) -exec sh -c 'gzip -9 -k "$1" && brotli -q 11 "$1"' _ {} \;

RUN echo "=== Compression Analysis ===" && \
    find dist -name "*.gz" -exec sh -c 'orig=$(echo "$1" | sed "s/.gz$//"); echo "$(basename "$orig"): $(stat -f%z "$orig") -> $(stat -f%z "$1") bytes ($(echo "scale=1; $(stat -f%z "$1") * 100 / $(stat -f%z "$orig")" | bc)%)"' _ {} \;

FROM nginx:1.27-alpine

# I'm installing additional tools for monitoring and debugging
RUN apk add --no-cache \
    curl \
    jq \
    && rm -rf /var/cache/apk/*

# I'm removing default nginx files
RUN rm -rf /usr/share/nginx/html/* && \
    rm /etc/nginx/conf.d/default.conf

# I'm copying the optimized and compressed static assets
COPY --from=compressor /app/dist /usr/share/nginx/html

# I'm copying the optimized nginx configuration
# COPY --chown=root:root nginx.prod.conf /etc/nginx/nginx.conf:ro

# I'm creating a custom nginx configuration for SPA routing and performance
RUN cat > /etc/nginx/conf.d/app.conf << 'EOF'
# High-performance nginx configuration for SolidJS SPA
server {
    listen 3000;
    listen [::]:3000;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https:;" always;

    # Performance headers
    add_header X-Served-By "nginx-optimized" always;

    # Compression settings
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header Vary "Accept-Encoding";

        # Serve pre-compressed files if available
        location ~* \.(js|css|html|svg|json)$ {
            gzip_static on;
            brotli_static on;
        }
    }

    # HTML files with short cache for updates
    location ~* \.html$ {
        expires 1h;
        add_header Cache-Control "public, must-revalidate";
        add_header Vary "Accept-Encoding";

        gzip_static on;
        brotli_static on;
    }

    # SPA routing - serve index.html for all routes
    location / {
        try_files $uri $uri/ /index.html;
        add_header Cache-Control "no-cache, no-store, must-revalidate";
        add_header Pragma "no-cache";
        add_header Expires "0";
    }

    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\n";
        add_header Content-Type text/plain;
    }

    # API proxy to backend (if needed)
    location /api/ {
        # This would proxy to backend in production
        return 404;
    }
}
EOF

# I'm creating a startup script for environment configuration
RUN cat > /docker-entrypoint.d/10-setup-env.sh << 'EOF'
#!/bin/sh
# I'm configuring environment-specific settings at runtime

echo "=== Frontend Container Starting ==="
echo "Environment: ${NODE_ENV:-production}"
echo "Build time: $(date)"
echo "Nginx version: $(nginx -v 2>&1)"

# I'm listing the built assets for verification
echo "=== Static Assets ==="
find /usr/share/nginx/html -type f -name "*.html" -o -name "*.js" -o -name "*.css" | head -10

echo "=== Asset Sizes ==="
du -sh /usr/share/nginx/html/*

# I'm configuring nginx worker processes based on available CPUs
if [ -f /proc/cpuinfo ]; then
    WORKER_PROCESSES=$(grep -c ^processor /proc/cpuinfo)
    sed -i "s/worker_processes auto;/worker_processes ${WORKER_PROCESSES};/" /etc/nginx/nginx.conf
    echo "Configured nginx with ${WORKER_PROCESSES} worker processes"
fi
EOF

RUN chmod +x /docker-entrypoint.d/10-setup-env.sh

# I'm setting up proper permissions
RUN chown -R nginx:nginx /usr/share/nginx/html && \
    chown -R nginx:nginx /var/cache/nginx && \
    chown -R nginx:nginx /var/log/nginx

# I'm switching to non-root user for security
USER nginx

# I'm exposing the application port
EXPOSE 3000

# I'm setting up health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=30s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# I'm configuring the startup command
CMD ["nginx", "-g", "daemon off;"]

# Build arguments for metadata
ARG BUILD_DATE
ARG GIT_COMMIT
ARG VERSION

# I'm adding comprehensive metadata
LABEL org.opencontainers.image.title="Performance Showcase Frontend"
LABEL org.opencontainers.image.description="High-performance SolidJS frontend with optimized static serving"
LABEL org.opencontainers.image.created=${BUILD_DATE}
LABEL org.opencontainers.image.revision=${GIT_COMMIT}
LABEL org.opencontainers.image.version=${VERSION}
LABEL org.opencontainers.image.source="https://github.com/CarterPerez-dev/kill-pr0cess.inc"

# I'm adding resource recommendations
LABEL resource.cpu.min="0.25"
LABEL resource.cpu.max="1.0"
LABEL resource.memory.min="128Mi"
LABEL resource.memory.max="512Mi"

# I'm configuring security labels
LABEL security.non-root=true
LABEL security.readonly-rootfs=false
</file>

<file path="package.json">
{
  "name": "performance-showcase-frontend",
  "version": "1.0.0",
  "description": "High-performance SolidJS frontend for computational showcase",
  "type": "module",
  "scripts": {
  "postinstall": "echo 'NPM Postinstall: Attempting to run patch script...' && node ./vite-plugin-solid-patch.js && echo 'NPM Postinstall: Patch script finished.'",
    "dev": "vinxi dev --host 0.0.0.0 --port 3000",
    "build": "vinxi build",
    "start": "vinxi start",
    "preview": "vinxi preview",
    "type-check": "tsc --noEmit",
    "lint": "eslint src/**/*.{js,ts,tsx} --fix",
    "format": "prettier --write src/**/*.{js,ts,tsx,css,scss,md}",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:run": "vitest run"
  },
  "dependencies": {
    "@solidjs/router": "^0.14.7",
    "@solidjs/start": "^1.0.8",
    "@solidjs/meta": "^0.29.4",
    "solid-js": "^1.9.3",
    "vinxi": "^0.5.6"
  },
  "devDependencies": {
    "tailwindcss": "^3.4.16",
    "autoprefixer": "^10.4.20",
    "@types/node": "^20.12.7",
    "typescript": "^5.4.5",
    "vite": "^5.2.10",
    "vitest": "^1.6.0",
    "eslint": "^8.57.0",
    "@typescript-eslint/eslint-plugin": "^7.7.1",
    "@typescript-eslint/parser": "^7.7.1",
    "prettier": "^3.2.5",
    "postcss": "^8.4.38"
  },
  "engines": {
    "node": ">=20",
    "npm": ">=9"
  },
  "keywords": [
    "solidjs",
    "performance",
    "rust",
    "typescript",
    "tailwindcss",
    "showcase"
  ],
  "author": "Performance Showcase",
  "license": "MIT"
}
</file>

<file path="postcss.config.js">
/*
 * PostCSS configuration for processing Tailwind CSS and other CSS transformations.
 * I'm setting up the essential plugins for Tailwind CSS processing and browser compatibility.
 */

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="tailwind.config.js">
/*
 * Complete Tailwind CSS configuration optimized for the dark performance showcase theme with comprehensive design tokens.
 * I'm setting up advanced color palettes, animations, custom utilities, and sophisticated design system components to support the eerie aesthetic and performance visualization requirements.
 */

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  darkMode: 'class',
  theme: {
    extend: {
      // I'm customizing the color palette for the dark, eerie aesthetic
      colors: {
        // I'm defining the primary color system
        primary: {
          50: '#ecfeff',
          100: '#cffafe',
          200: '#a5f3fc',
          300: '#67e8f9',
          400: '#22d3ee', // Main accent color
          500: '#06b6d4',
          600: '#0891b2',
          700: '#0e7490',
          800: '#155e75',
          900: '#164e63',
        },
        // I'm defining secondary colors for variety
        secondary: {
          50: '#eef2ff',
          100: '#e0e7ff',
          200: '#c7d2fe',
          300: '#a5b4fc',
          400: '#818cf8',
          500: '#6366f1', // Secondary accent
          600: '#4f46e5',
          700: '#4338ca',
          800: '#3730a3',
          900: '#312e81',
        },
        // I'm extending the neutral palette for fine-grained control
        neutral: {
          25: '#fefefe',
          50: '#fafafa',
          100: '#f5f5f5',
          150: '#ededed',
          200: '#e5e5e5',
          250: '#dedede',
          300: '#d4d4d4',
          350: '#b5b5b5',
          400: '#a3a3a3',
          450: '#8b8b8b',
          500: '#737373',
          550: '#666666',
          600: '#525252',
          650: '#464646',
          700: '#404040',
          750: '#363636',
          800: '#262626',
          850: '#1f1f1f',
          900: '#171717',
          925: '#141414',
          950: '#0a0a0a',
        }
      },
      // I'm customizing fonts for the technical aesthetic
      fontFamily: {
        mono: ['JetBrains Mono', 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', 'Consolas', 'Courier New', 'monospace'],
        sans: ['system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],
      },
      // I'm adding custom animations for the performance showcase
      animation: {
        'fade-in': 'fadeIn 0.5s ease-in-out',
        'fade-in-up': 'fadeInUp 0.8s ease-out',
        'slide-in-left': 'slideInLeft 0.5s ease-out',
        'slide-in-right': 'slideInRight 0.5s ease-out',
        'pulse-slow': 'pulseSlow 3s ease-in-out infinite',
        'float': 'float 6s ease-in-out infinite',
        'glow': 'glow 2s ease-in-out infinite',
        'matrix-rain': 'matrixRain 20s linear infinite',
        'glitch': 'glitch 0.5s ease-in-out',
      },
      // I'm defining custom keyframes for sophisticated animations
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        fadeInUp: {
          '0%': { opacity: '0', transform: 'translateY(20px)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        slideInLeft: {
          '0%': { opacity: '0', transform: 'translateX(-20px)' },
          '100%': { opacity: '1', transform: 'translateX(0)' },
        },
        slideInRight: {
          '0%': { opacity: '0', transform: 'translateX(20px)' },
          '100%': { opacity: '1', transform: 'translateX(0)' },
        },
        pulseSlow: {
          '0%, 100%': { opacity: '0.8' },
          '50%': { opacity: '0.4' },
        },
        float: {
          '0%, 100%': { transform: 'translateY(0px)' },
          '50%': { transform: 'translateY(-10px)' },
        },
        glow: {
          '0%, 100%': { boxShadow: '0 0 5px rgba(34, 211, 238, 0.5)' },
          '50%': { boxShadow: '0 0 20px rgba(34, 211, 238, 0.8)' },
        },
        matrixRain: {
          '0%': { transform: 'translateY(-100vh)', opacity: '0' },
          '10%': { opacity: '1' },
          '90%': { opacity: '1' },
          '100%': { transform: 'translateY(100vh)', opacity: '0' },
        },
        glitch: {
          '0%, 100%': { transform: 'translate(0)' },
          '20%': { transform: 'translate(-2px, 2px)' },
          '40%': { transform: 'translate(-2px, -2px)' },
          '60%': { transform: 'translate(2px, 2px)' },
          '80%': { transform: 'translate(2px, -2px)' },
        },
      },
      // I'm customizing spacing for precise layouts
      spacing: {
        '18': '4.5rem',
        '88': '22rem',
        '128': '32rem',
      },
      // I'm adding custom border radius values
      borderRadius: {
        'xl': '0.75rem',
        '2xl': '1rem',
        '3xl': '1.5rem',
      },
      // I'm customizing shadows for depth and atmosphere
      boxShadow: {
        'glow': '0 0 20px rgba(34, 211, 238, 0.3)',
        'glow-lg': '0 0 40px rgba(34, 211, 238, 0.4)',
        'inner-glow': 'inset 0 0 20px rgba(34, 211, 238, 0.2)',
        'dark': '0 10px 25px rgba(0, 0, 0, 0.5)',
        'dark-lg': '0 20px 40px rgba(0, 0, 0, 0.7)',
      },
      // I'm customizing backdrop blur for glass effects
      backdropBlur: {
        xs: '2px',
        '3xl': '64px',
      },
      // I'm adding custom gradients for the performance theme
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic': 'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
        'grid-pattern': 'radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.15) 1px, transparent 0)',
      },
      // I'm customizing line clamp for text truncation
      lineClamp: {
        7: '7',
        8: '8',
        9: '9',
        10: '10',
      },
    },
  },
  plugins: [
    // I'm adding custom utilities for the performance showcase
    function({ addUtilities, theme }) {
      const newUtilities = {
        '.text-shadow': {
          textShadow: '0 2px 4px rgba(0, 0, 0, 0.5)',
        },
        '.text-shadow-lg': {
          textShadow: '0 4px 8px rgba(0, 0, 0, 0.7)',
        },
        '.border-gradient': {
          border: '1px solid transparent',
          backgroundImage: 'linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0)), linear-gradient(135deg, rgba(34, 211, 238, 0.3), rgba(99, 102, 241, 0.3))',
          backgroundOrigin: 'border-box',
          backgroundClip: 'content-box, border-box',
        },
        '.glass': {
          background: 'rgba(255, 255, 255, 0.05)',
          backdropFilter: 'blur(10px)',
          border: '1px solid rgba(255, 255, 255, 0.1)',
        },
        '.performance-grid': {
          backgroundImage: 'radial-gradient(circle at 1px 1px, rgba(34, 211, 238, 0.15) 1px, transparent 0)',
          backgroundSize: '20px 20px',
        },
      }
      addUtilities(newUtilities)
    },
  ],
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "allowJs": true,
    "noEmit": true,
    "strict": true,
    "types": ["vinxi/types/client", "vite/client"],
    "isolatedModules": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitOverride": true,
    "paths": {
      "~/*": ["./src/*"],
      "@/*": ["./src/*"]
    },
    "baseUrl": ".",
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    "declaration": false,
    "declarationMap": false,
    "sourceMap": true,
    "removeComments": false,
    "importHelpers": true,
    "downlevelIteration": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "useDefineForClassFields": true
  },
  "include": [
    "src/**/*",
    "src/**/*.tsx",
    "src/**/*.ts",
    "app.config.ts",
    "tailwind.config.js",
    "postcss.config.js"
  ],
  "exclude": [
    "node_modules",
    "dist",
    ".solid",
    ".output",
    ".vinxi"
  ]
}
</file>

<file path="vite-plugin-solid-patch.js">
import fs from 'fs';
import path from 'path';

console.log('🔧 Applying vite-plugin-solid patch...');
const scriptCwd = process.cwd();
console.log('Script CWD:', scriptCwd);

const pluginPath = path.resolve(scriptCwd, './node_modules/vite-plugin-solid/dist/esm/index.mjs');
console.log('Attempting to patch file at:', pluginPath);

if (!fs.existsSync(pluginPath)) {
  console.log('❌ Plugin file not found at path:', pluginPath);
  process.exit(1); // Exit with error if file not found
}

try {
  let content = fs.readFileSync(pluginPath, 'utf8');
  let madeChanges = false;

  // --- Client Conditions Patch ---
  const clientOriginal = 'config.resolve.conditions = [...defaultClientConditions];';
  const clientPatched = "config.resolve.conditions = Array.isArray(defaultClientConditions) ? [...defaultClientConditions] : ['browser', 'module', 'import', 'default'];";

  if (content.includes(clientOriginal)) {
    console.log('🎯 Found original client conditions. Patching...');
    content = content.replace(clientOriginal, clientPatched);
    madeChanges = true;
  } else if (content.includes(clientPatched)) {
    console.log('ℹ️ Client conditions already patched.');
  } else {
    console.log('⚠️ Client conditions pattern not found. Original or Patched. Check vite-plugin-solid version/content.');
    // Optional: console.log a snippet for debugging
    // const clientSnippetIndex = content.indexOf('defaultClientConditions');
    // if (clientSnippetIndex > -1) {
    //     console.log("Client snippet:", content.substring(Math.max(0, clientSnippetIndex - 70), clientSnippetIndex + 120));
    // }
  }

  // --- Server Conditions Patch ---
  const serverOriginal = 'config.resolve.conditions = [...defaultServerConditions];';
  const serverPatched = "config.resolve.conditions = Array.isArray(defaultServerConditions) ? [...defaultServerConditions] : ['node', 'module', 'import', 'default'];";

  if (content.includes(serverOriginal)) {
    console.log('🎯 Found original server conditions. Patching...');
    content = content.replace(serverOriginal, serverPatched);
    madeChanges = true;
  } else if (content.includes(serverPatched)) {
    console.log('ℹ️ Server conditions already patched.');
  } else {
    console.log('⚠️ Server conditions pattern not found. Original or Patched. Check vite-plugin-solid version/content.');
    // Optional: console.log a snippet for debugging
    // const serverSnippetIndex = content.indexOf('defaultServerConditions');
    // if (serverSnippetIndex > -1) {
    //     console.log("Server snippet:", content.substring(Math.max(0, serverSnippetIndex - 70), serverSnippetIndex + 120));
    // }
  }

  if (madeChanges) {
    fs.writeFileSync(pluginPath, content, 'utf8');
    console.log('✅ Successfully wrote changes to vite-plugin-solid!');
  } else {
    console.log('ℹ️ No changes were made to the file (either already patched or patterns not found).');
  }

} catch (error) {
  console.error('❌ Error applying patch:', error.message, error.stack);
  process.exit(1);
}
</file>

</files>
